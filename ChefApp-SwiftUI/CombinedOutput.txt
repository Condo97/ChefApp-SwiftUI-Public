ChefAppApp.swift
//
//  ChefAppApp.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/16/23.
//

import GoogleMobileAds
import PDFKit
import SwiftUI

@main
struct ChefAppApp: App {
//    let persistenceController = PersistenceController.shared
    
//    var colorUpdater: ColorUpdater = ColorUpdater()
    
    @Environment(\.colorScheme) private var colorScheme
    @Environment(\.requestReview) private var requestReview
    
    @UIApplicationDelegateAdaptor(AppDelegate.self) private var appDelegate
    
    @StateObject private var constantsUpdater = ConstantsUpdater()
    @StateObject private var premiumUpdater = PremiumUpdater()
    @StateObject private var productUpdater = ProductUpdater()
    @StateObject private var remainingUpdater = RemainingUpdater()
    @StateObject private var screenIdleTimerUpdater = ScreenIdleTimerUpdater()
    
    @StateObject private var openURL_recipeGenerator = RecipeGenerator()
    
    @State private var isShowingIntroView: Bool
    @State private var isShowingUltraView: Bool = false
    @State private var openURL_recipeGenerationSpec: RecipeGenerationSpec?
    
    @State private var openURL_isLoadingExtensionAttachment: Bool = false
    
    
    init() {
//        UIView.appearance().tintColor = UIColor(Colors.elementBackground)
        UIView.appearance(whenContainedInInstancesOf: [UIAlertController.self]).tintColor = UIColor(Colors.elementBackground)
        
        // Start Google Mobile Ads shared instance
        GADMobileAds.sharedInstance().start()
        
        // Ensure AuthHelper to get authToken TODO: Is this a good place to do this?
        Task {
            do {
                try await AuthHelper.ensure()
            } catch {
                // TODO: Handle errors
                print("Error ensuring authToken with AuthHelper in body in BarbackApp... \(error)")
            }
        }
        
        // Set initial variables
        _isShowingIntroView = State(initialValue: !IntroManager.isIntroComplete)
        
        // Start IAPManager transaction observer
        IAPManager()
    }
    
    var body: some Scene {
        WindowGroup {
            ZStack {
                if isShowingIntroView {
                    IntroPresenterView(
                        isShowing: $isShowingIntroView)
                } else {
                    MainContainer()
                }
            }
            .tint(Colors.elementBackground)
            // Ultra view popup
            .ultraViewPopover(isPresented: $isShowingUltraView)
            // Loading attachment view
            .clearFullScreenCover(isPresented: $openURL_isLoadingExtensionAttachment) {
                // Is Loading Extension Attachment View
                ZStack {
                    Colors.foreground
                        .opacity(0.6)
                    VStack {
                        Text("Loading Attachment")
                        ProgressView()
                    }
                }
                .ignoresSafeArea()
            }
            // Handle full-screen cover for recipe generation view
            .fullScreenCover(item: $openURL_recipeGenerationSpec) { newValue in
                RecipeGenerationView(
                    recipeGenerator: openURL_recipeGenerator,
                    recipeGenerationSpec: newValue,
                    onDismiss: { openURL_recipeGenerationSpec = nil },
                    didSaveRecipe: { _ in
                        // Dismiss recipe generation view and entry view, set presenting panel to nil, and reset fields and selected items
                        openURL_recipeGenerationSpec = nil
                    }
                )
                .background(Colors.background)
            }
            .onOpenURL(perform: { url in
                if url.absoluteString == "chefapp://sharedata" {
                    checkForSharedData()
                    return
                }
            })
            .task(priority: .background) {
                // Perform migration
                await MigrationAssistant.migrateCoreDataImagesToAppGroupSaveLocations(in: CDClient.mainManagedObjectContext)
            }
            .task {
                // Update constants
                do {
                    try await constantsUpdater.update()
                } catch {
                    print("Error updating constants in ChefAppApp... \(error)")
                }
                
                // Increment launchCount
                await MainActor.run {
                    constantsUpdater.launchCount += 1
                }
            }
            .task {
                // Ensure authToken
                let authToken: String
                do {
                    authToken = try await AuthHelper.ensure()
                } catch {
                    print("Error ensuring authToken in ChefAppApp, regenerating... \(error)")
                    
                    do {
                        try await AuthHelper.regenerate()
                    } catch {
                        // TODO: Handle Errors
                        print("Error regenerating authToken in ChefAppApp... \(error)")
                    }
                    
                    do {
                        authToken = try await AuthHelper.ensure()
                    } catch {
                        // TODO: Handle Errors
                        print("Error ensuring authToken after regenerating in ChefAppApp... \(error)")
                        return
                    }
                }
                
                // Update premium
                do {
                    try await premiumUpdater.update(authToken: authToken)
                } catch {
                    // TODO: Handle Errors
                    print("Error updating premium in ChefAppApp... \(error)")
                }
                
                // Update remaining
                do {
                    try await remainingUpdater.update(authToken: authToken)
                } catch {
                    // TODO: Handle Errors
                    print("Error updating remaining in ChefAppApp... \(error)")
                }
                
                // Show ultra view if necessary and intro is not showing
                if !premiumUpdater.isPremium && !isShowingIntroView {
                    isShowingUltraView = true
                }
            }
            .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
            .environmentObject(constantsUpdater)
            .environmentObject(premiumUpdater)
            .environmentObject(productUpdater)
            .environmentObject(remainingUpdater)
            .environmentObject(screenIdleTimerUpdater)
        }
    }
    
    func checkForSharedData(triesLeft: Int = 5) {
        guard triesLeft > 0 else {
            return
        }
        
        let fileLoader = AppGroupLoader(appGroupIdentifier: Constants.Additional.appGroupID)

        if let sharedData = fileLoader.loadCodable(SharedData.self, from: "sharedData.json") {
            Task {
                await processSharedData(sharedData)
                fileLoader.deleteFile(named: "sharedData.json")
            }
        } else {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2, execute: {
                checkForSharedData(triesLeft: triesLeft - 1)
            })
        }
    }
    
    func processSharedData(_ sharedData: SharedData) async {
        // Defer setting isLoadingExtensionAttachment to false
        defer {
            DispatchQueue.main.async { openURL_isLoadingExtensionAttachment = false }
        }
        
        // Set isLoadingExtensionAttachment to true
        await MainActor.run {
            openURL_isLoadingExtensionAttachment = true
        }
        
        // Get text from attachment
        guard let text = await getText(from: sharedData) else {
            // TODO: Handle Errors
            print("Could not unwrap text from sharedData in MainContainer!")
            return
        }
        
        // Process Recipe with this as the input and show the creator page
        await MainActor.run {
            openURL_recipeGenerationSpec = RecipeGenerationSpec(
                pantryItems: [],
                suggestions: [],
                input: text,
                generationAdditionalOptions: .normal)
        }
    }
    
    func getText(from sharedData: SharedData) async -> String? {
        if let urlString = sharedData.url,
           let url = URL(string: urlString) {
            do {
                if let receivedText = try await WebpageTextReader.getWebpageText(externalURL: url) {
                    return receivedText
                }
                
                // TODO: Prompt GPT with text
            } catch {
                // TODO: Handle Errors
                print("Error reading webpage text in WriteSmith_SwiftUIApp... \(error)")
            }
        }
        
        if let text = sharedData.text {
            return text
        }
        
        if let pdfAppGroupFilepath = sharedData.pdfAppGroupFilepath {
            if let pdfData = AppGroupLoader(appGroupIdentifier: Constants.Additional.appGroupID)
                .loadData(from: pdfAppGroupFilepath),
               let pdfDocument = PDFDocument(data: pdfData) {
                return PDFReader.readPDF(from: pdfDocument)
            }
        }
        
        return nil
    }
    
}


View+ClearFullScreenCover.swift
//
//  ClearFullScreenCover+View.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 11/16/23.
//
// https://stackoverflow.com/questions/64301041/swiftui-translucent-background-for-fullscreencover

import Foundation
import SwiftUI

struct ClearFullScreenCoverView: UIViewRepresentable {
    
//    private let blurBackground = UIVisualEffectView(effect: UIBlurEffect(style: .dark))
    @State var blurEffectStyle: UIBlurEffect.Style // = .dark
    @State var fadeDelay: CGFloat = 0.1
    @State var fadeDuration: CGFloat = 0.4
    
    func makeUIView(context: Context) -> UIView {
        let view = UIVisualEffectView(effect: UIBlurEffect(style: blurEffectStyle))//UIView()
//        let blurBackground = UIVisualEffectView(effect: UIBlurEffect(style: .light))
//        blurBackground.frame = view.bounds
        view.alpha = 0.0
        
        DispatchQueue.main.async {
            view.superview?.superview?.backgroundColor = .clear
            
            UIView.animate(withDuration: fadeDuration, delay: fadeDelay, animations: {
                view.alpha = 1.0
            })
        }
        
//        view.addSubview(blurBackground)
        
        return view
    }

    func updateUIView(_ uiView: UIView, context: Context) {
        
    }
}

extension View {
    
    func clearFullScreenCover<Content: View>(isPresented: Binding<Bool>, blurStyle: UIBlurEffect.Style = .dark, fadeDelay: CGFloat = 0.1, fadeDuration: CGFloat = 0.4, onDismiss: (()->Void)? = nil, backgroundTapDismisses: Bool = true, @ViewBuilder content: @escaping ()->Content) -> some View {
        self
            .fullScreenCover(isPresented: isPresented, onDismiss: onDismiss, content: {
                ZStack {
                    Color.clear
                    
                    content()
                        .transition(.opacity)
                }
                .background(
                    ClearFullScreenCoverView(
                        blurEffectStyle: blurStyle,
                        fadeDelay: fadeDelay,
                        fadeDuration: fadeDuration)
                    .ignoresSafeArea()
                    .onTapGesture {
                        if backgroundTapDismisses {
                            DispatchQueue.main.async {
                                isPresented.wrappedValue = false
                            }
                        }
                    }
                )
            })
    }
    
}


MeasurementIngredientParser.swift
//
//  MeasurementIngredientParser.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 7/17/23.
//

import Foundation

class MeasurementIngredientParser {
    
    struct ParsedMeasurementIngredient {
        var amount: String?
        var fraction: String?
        var abbreviatedMeasurementArray: [AbbreviatedMeasurement]
        var abbreviatedMeasurementIndex: Int
        var ingredient: String
        var measurementOnLeft: Bool
    }
    
    static let orderedMassMeasurements: [AbbreviatedMeasurement] = [
        AbbreviatedMeasurement(
            abbreviation: "g",
            alternatives: [
                "gram",
                "grams"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "oz",
            alternatives: [
                "ounce",
                "ounces"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "lb",
            alternatives: [
                "lbs",
                "pound",
                "pounds"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "kg",
            alternatives: [
                "kgs",
                "kilogram",
                "kilograms"
            ])
    ]

    static let orderedLengthMeasurements: [AbbreviatedMeasurement] = [
        AbbreviatedMeasurement(
            abbreviation: "mm",
            alternatives: [
                "millimeter",
                "millimeters"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "cm",
            alternatives: [
                "centimeter",
                "centimeters"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "in",
            alternatives: [
                "inch",
                "inches"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "ft",
            alternatives: [
                "foot",
                "feet"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "yd",
            alternatives: [
                "yard",
                "yards"
            ])
    ]

    static let orderedVolumeMeasurements: [AbbreviatedMeasurement] = [
        AbbreviatedMeasurement(
            abbreviation: "ml",
            alternatives: [
                "milliliter",
                "milliliters"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "tsp",
            alternatives: [
                "teaspoon",
                "teaspoons",
                "tsps"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "tbsp",
            alternatives: [
                "tablespoon",
                "tablespoons",
                "tbsps"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "fl oz",
            alternatives: [
                "fluid ounce",
                "fluid ounces"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "cup",
            alternatives: [
                "cup",
                "cups"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "pt",
            alternatives: [
                "pint",
                "pints"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "qt",
            alternatives: [
                "quart",
                "quarts"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "l",
            alternatives: [
                "litre",
                "litres",
                "liter",
                "liters"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "gal",
            alternatives: [
                "gallon",
                "gallons"
            ])
    ]

    static let orderedTemperatureMeasurements: [AbbreviatedMeasurement] = [
        AbbreviatedMeasurement(
            abbreviation: "C",
            alternatives: [
                "C",
                "celsius"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "F",
            alternatives: [
                "F",
                "fahrenheit"
            ])
    ]
    
    static let allOrderedMeasurements: [[AbbreviatedMeasurement]] = [
        orderedMassMeasurements,
        orderedLengthMeasurements,
        orderedVolumeMeasurements,
        orderedTemperatureMeasurements
    ]
    
    
    static func parseFirstMeasurement(from string: String, leastToGreatestPossibleFractionValues: [String]) -> ParsedMeasurementIngredient? {
        for abbreviatedMeasurementArray in allOrderedMeasurements {
            for i in 0..<abbreviatedMeasurementArray.count {
                // Get abbreviatedMeasurement
                let abbreviatedMeasurement = abbreviatedMeasurementArray[i]
                
                // Loop through abbreviation and alternatives for abbreviatedMeasurement
                for j in 0..<(1 + abbreviatedMeasurement.alternatives.count) {
                    // Get measurementString
                    let measurementString = j == 0 ? abbreviatedMeasurement.abbreviation : abbreviatedMeasurement.alternatives[j - 1]
                    
                    // Create regular expression pattern..
                    // Right now it is different than below, and it will match any number with or without decimal and or fraction followed by any amount of whitespace and measurementString
//                    - `\b`: This is a word boundary. This ensures that the match will not be part of a larger word.
//                    - `(?<amount>\d+(?:\.\d+)?(?:\s+\d+\/\d+)?)?`: This is an optional named group (called "amount") that matches amounts with the following pattern `numbers , ( decimal numbers or fractional numbers)`. Numbers can be decimal or fractional as follows:
//                      - `\d+`: Match one or more digits.
//                      - `(?:\.\d+)?`: Non-capturing group (due to `?:`) to optionally match a decimal number i.e `.and any number of digits afterwards`.
//                      - `(?:\s+\d+\/\d+)?`: Non-capturing group (due to `?:`) to optionally match a fraction number `i.e space, digits , slash '/' , digits`
//                    - `\s*`: Match zero or more whitespace characters.
//                    - `(?<unit>\w+)?`: This is an optional named group (called "unit") that matches one or more word characters.
//                    - `\s*`: Match zero or more whitespace characters.
//                    - `(?<ingredient>.*)?`: This is another optional named group (called "ingredient") that matches any character (.) zero or more times (*), i.e., it will match whatever is left in the string after matching the amount and unit.
//                    - `\b`: This is again a word boundary.
//                    let pattern = "\b\d+(\.\d+)?+\s+\b\(measurementString)\b"
//                    let pattern = "(\d+(\.\d+)?\s*)(\d+/\d+\s*)?(\(measurementString)\b)"
//                    let pattern = "\b(?<amount>\d+(?:\.\d+)?(?:\s+\d+\/\d+)?)?(?:\s*(?<unit>\w+))?(?:\s*(?<ingredient>.*))?\b"
                    /* Get Number and Fraction Strings */
                    let amountName = "amount"
//                    let amountMeasurementPattern = "\b(?<\(amountName)>\d+(?:\.\d+)?(?:\s+\d+\/\d+)?)\s+\b\(measurementString)\b"
                    let amountMeasurementPattern = "\b(?<\(amountName)>(?:\d+)?(?:\.\d+)?((?:\d\s+)?(?:\d+\/\d+))?)\s+\b\(measurementString)\b"
                    
                    // Create regular expression with the option of caseInsensitive to search for matching string regardless of case
                    let amountMeasurementRegex = try? NSRegularExpression(pattern: amountMeasurementPattern, options: .caseInsensitive)
                    
                    // Get the first match and unwrap, otherwise continue TODO: Maybe the measurement thing support multiple matches.. is that even necessary?
                    guard let amountMeasurementFirstMatch = amountMeasurementRegex?.firstMatch(in: string, range: NSRange(location: 0, length: string.utf16.count)) else {
                        continue
                    }
                    
                    // Get the amountString from amount in firstMatch
                    let amountNSRange = amountMeasurementFirstMatch.range(withName: amountName)
                    guard amountNSRange.location != NSNotFound, let amountRange = Range(amountNSRange, in: string) else {
                        continue
                    }
                    let amountString = String(string[amountRange])
                    
                    // Parse amountString into amount number and fraction
//                    let numberName = "number"
//                    let fractionName = "fraction"
//                    let amountNumberFractionPattern = "\b(?<\(numberName)>\d+(?:.\d+)?)?(?:(?<\(fractionName)>\s+\d+\/\d+)?)"
                    
                    // Create regular expression with the option of caseInsensitive to serach for matching string regardless of case, even though its numbers here I guess lol
//                    let amountNumberFractionRegex = try? NSRegularExpression(pattern: amountNumberFractionPattern, options: .caseInsensitive)
                    
                    // Get the first match and unwrap, otherwise continue
//                    guard let amountNumberFractionFirstMatch = amountNumberFractionRegex?.firstMatch(in: amountString, range: NSRange(location: 0, length: amountString.utf16.count)) else {
//                        continue
//                    }
                    
                    
                    
                    // Will always be in the format 1, 1.5, 1/2, or 1 1/2
                    // So split by spaces, we get (1), (1.5), (1/2), (1, 1/2)
                    // If the first is a double, get its fraction
                    
                    // Split amountString by space
                    let spaceSplitAmountString = amountString.split(separator: " ")
                    
                    // Ensure spaceString has at least one and no more than 2 values, otherwise continue
                    guard spaceSplitAmountString.count > 0 && spaceSplitAmountString.count <= 2 else {
                        continue
                    }
                    
                    // Get the numberString and fractionString
                    var numberString: String? = nil, fractionString: String? = nil
                    if let intValue = Int(String(spaceSplitAmountString[0])) {
                        // If it's an int, set the numberString as an int
                        numberString = "\(intValue)"
                        
                        // Get the fraction if there is one
                        if spaceSplitAmountString.count == 2, let solvedFractionFromSecondAmountString = StringFractionSolver.solveFraction(from: String(spaceSplitAmountString[1])) {
                            // Set fractionString to the result of getFractionString from DecimalToFractionStringAdapter
                            fractionString = DecimalToFractionStringAdapter.getFractionString(from: solvedFractionFromSecondAmountString, leastToGreatestPossibleValues: leastToGreatestPossibleFractionValues)
                        }
                    } else {
                        // Ensure the count of spaceSplitAmountString is 1 before proceeding, otherwise continue, as there should only be one double or a fraction by itself or with a whole number
                        guard spaceSplitAmountString.count == 1 else {
                            continue
                        }
                        
                        // TODO: If first number is a double or fraction and there is a second number, continue
                        // Not a int, check if it is a double or fraction, setting doubleValue with the double or solved fraction equation, otherwise continue
                        let solvedDoubleValue: Double
                        if let doubleValue = Double(String(spaceSplitAmountString[0])) {
                            // Got double, so set solvedDoubleValue to doubleValue
                            solvedDoubleValue = doubleValue
                        } else {
                            // Solve fraction and set to solvedDoubleValue, otherwise continue
                            guard let solvedFractionFromFirstAmountString = StringFractionSolver.solveFraction(from: String(spaceSplitAmountString[0])) else {
                                continue
                            }
                            solvedDoubleValue = solvedFractionFromFirstAmountString
                        }
                        
                        // numberString is the Int value of solvedDoubleValue
                        numberString = String(Int(solvedDoubleValue))
                        
                        // fractionString is the result of getFractionString from DecimalToFractionStringAdapter
                        fractionString = DecimalToFractionStringAdapter.getFractionString(from: solvedDoubleValue, leastToGreatestPossibleValues: leastToGreatestPossibleFractionValues)
                        
                        // If numberString is 0 and there is a fraction, set numberString to nil
                        if fractionString != nil, numberString != nil, let numberStringInt = Int(numberString!), numberStringInt == 0 {
                            numberString = nil
                        }
                    }
                    
                    
                    
//                    let numberNSRange = amountNumberFractionFirstMatch.range(withName: numberName)
//                    let fractionNSRange = amountNumberFractionFirstMatch.range(withName: fractionName)
//                    if numberNSRange.location != NSNotFound, let numberRange = Range(numberNSRange, in: amountString) {
//                        numberString = String(amountString[numberRange]).trimmingCharacters(in: .whitespaces)
//                    }
//                    if fractionNSRange.location != NSNotFound, let fractionRange = Range(fractionNSRange, in: amountString) {
//                        fractionString = String(amountString[fractionRange]).trimmingCharacters(in: .whitespaces)
//                    }
                    
                    /* Get Ingredient */
                    // Get and unwrap amount measurement measurement range in string from amountMeasurementFirstMatch range, otherwise continue
                    guard let amountMeasurementRangeInString = Range(amountMeasurementFirstMatch.range, in: string) else {
                        continue
                    }
                    
                    // Get ingredient from string if range location is 0 or range location + range length is the length of the string and get measurementOnLeft depending on if the measurement is on the left side of the string, otherwise return TODO: How would I convert these to using the measurementRangeInString?
                    let ingredient: String
                    let measurementOnLeft: Bool
                    if amountMeasurementFirstMatch.range.location == 0 {
                        // If measurement is at the beginning of the string, set ingredient to everything after the range
                        ingredient = String(string[amountMeasurementRangeInString.upperBound...]).trimmingCharacters(in: .whitespaces)
                        measurementOnLeft = true
                    } else if amountMeasurementFirstMatch.range.location + amountMeasurementFirstMatch.range.length == string.count {
                        // If measurement is at the end of the string, set ingredient to everything before the range
                        ingredient = String(string[..<amountMeasurementRangeInString.lowerBound]).trimmingCharacters(in: .whitespaces)
                        measurementOnLeft = false
                    } else {
                        // First match is not at the beginning or end of the string, so continue TODO: Maybe allow for more flexibility?
                        continue
                    }
                    
//                    // Get measurement from string
//                    let measurement = String(string[measurementRangeInString])
//
//                    // Parse the number out of the measurement string, continuing if any optionals fail to unwrap
//                    let numberPattern = "\d+(\.\d+)?"
//                    let numberRegex = try? NSRegularExpression(pattern: numberPattern)
//                    guard let numberFirstMatch = numberRegex?.firstMatch(in: measurement, range: NSRange(location: 0, length: measurement.utf16.count)), let numberRange = Range(numberFirstMatch.range, in: measurement) else {
//                        continue
//                    }
//                    guard let amount = Double(String(measurement[numberRange])) else {
//                        continue
//                    }
                    
                    // Return ParsedMeasurementIngredient with amount, abbreviatedMeasurementArray, index of abbreviated measurement i, ingredient string, and if the measurement is on the left side
                    return ParsedMeasurementIngredient(
                        amount: numberString,
                        fraction: fractionString,
                        abbreviatedMeasurementArray: abbreviatedMeasurementArray,
                        abbreviatedMeasurementIndex: i,
                        ingredient: ingredient,
                        measurementOnLeft: measurementOnLeft)
                }
            }
        }
        
        return nil
        
    }
    
}


ScreenIdleTimerUpdater.swift
//
//  ScreenIdleTimerUpdater.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/3/24.
//

import SwiftUI
import Combine

class ScreenIdleTimerUpdater: ObservableObject {
    
    @Published var keepScreenOn: Bool = false {
        didSet {
            UIApplication.shared.isIdleTimerDisabled = keepScreenOn
        }
    }

    init() {
        self.keepScreenOn = UIApplication.shared.isIdleTimerDisabled
    }
    
}


Int+Word.swift
//
//  Int+Word.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 11/30/23.
//

import Foundation

extension Int {
    
    var word: String {
        switch self {
        case 0: return "zero"
        case 1: return "one"
        case 2: return "two"
        case 3: return "three"
        case 4: return "four"
        case 5: return "five"
        case 6: return "six"
        case 7: return "seven"
        case 8: return "eight"
        case 9: return "nine"
        case 10: return "ten"
        case 11: return "eleven"
        case 12: return "twelve"
        case 13: return "thirteen"
        case 14: return "fourteen"
        case 15: return "fifteen"
        case 16: return "sixteen"
        case 17: return "seventeen"
        case 18: return "eighteen"
        case 19: return "nineteen"
        case 20...29: return "twenty" + (self > 20 ? "-" + (self % 10).word : "")
        case 30...39: return "thirty" + (self > 30 ? "-" + (self % 10).word : "")
        case 40...49: return "forty" + (self > 40 ? "-" + (self % 10).word : "")
        case 50...59: return "fifty" + (self > 50 ? "-" + (self % 10).word : "")
        case 60...69: return "sixty" + (self > 60 ? "-" + (self % 10).word : "")
        case 70...79: return "seventy" + (self > 70 ? "-" + (self % 10).word : "")
        case 80...89: return "eighty" + (self > 80 ? "-" + (self % 10).word : "")
        case 90...99: return "ninety" + (self > 90 ? "-" + (self % 10).word : "")
        case 100: return "one hundred"
        default: return "\(self)"
        }
    }
    
}



DecimalToFractionStringAdapter.swift
//
//  DecimalToFractionStringAdapter.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 7/18/23.
//

import Foundation

class DecimalToFractionStringAdapter {
    
    static func getFractionString(from decimalNumber: Double, leastToGreatestPossibleValues: [String]) -> String? {
        // Get decimal from decimalNumber % 1
        let decimal = decimalNumber.truncatingRemainder(dividingBy: 1)
        
        // Ensure decimal is not 0, otherwise return nil
        guard decimal != 0 else {
            return nil
        }
        
        // Finds the closest possible value as a string converted to a double to the decimal number and returns it
        var prevPossibleValueDouble: Double?
        for i in 0..<leastToGreatestPossibleValues.count {//possibleValue in leastToGreatestPossibleValues {
            // Unwrap possibleValueDouble or continue
            guard let possibleValueDouble = StringFractionSolver.solveFraction(from: leastToGreatestPossibleValues[i]) else {
                continue
            }
            
            // If i > 0 since the value at i - 1 is returned, prevPossibleValueDouble is not nil, and abs(prevPossibleValueDouble - decimalNumber) is less than abs(possibleValueDouble - decimalNumber), then the previous number is the closest number and the string at its index should be returned
            if let prevPossibleValueDouble = prevPossibleValueDouble, abs(prevPossibleValueDouble - decimal) < abs(possibleValueDouble - decimal) {
                return leastToGreatestPossibleValues[i - 1]
            }
            
            // Set prevPossibleValueDouble and prevPossibleValueIndex
            prevPossibleValueDouble = possibleValueDouble
        }
        
        // If the loop finishes without returning a fraction string, return the last fraction string in leastToGreatestPossibleValues
        return leastToGreatestPossibleValues.last
    }
    
}


RegistryHelper.swift
//
//  RegistryHelper.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 3/23/23.
//

import Foundation
import UIKit

class RegistryHelper {
    
    static func instantiateAsView(nibName: String, owner: UIViewController) -> UIView? {
        return UINib(nibName: nibName, bundle: nil).instantiate(withOwner: owner)[0] as? UIView
    }
    
    static func instantiateInitialViewControllerFromStoryboard(storyboardName: String) -> UIViewController? {
        return UIStoryboard(name: storyboardName, bundle: nil).instantiateInitialViewController()
    }
    
    
//    static func register(_ xib_reuseID: XIB_ReuseID, to collectionView: UICollectionView) {
//        register([xib_reuseID], to: collectionView)
//    }
//    
//    static func register(_ xib_reuseIDs: [XIB_ReuseID], to collectionView: UICollectionView) {
//        xib_reuseIDs.forEach({ xib_reuseID in
//            collectionView.register(UINib(nibName: xib_reuseID.xibName, bundle: nil), forCellWithReuseIdentifier: xib_reuseID.reuseID)
//        })
//    }
//    
//    static func register(_ xib_reuseID: XIB_ReuseID, to tableView: UITableView) {
//        register([xib_reuseID], to: tableView)
//    }
//    
//    static func register(_ xib_reuseIDs: [XIB_ReuseID], to tableView: UITableView) {
//        xib_reuseIDs.forEach({ xib_reuseID in
//            tableView.register(UINib(nibName: xib_reuseID.xibName, bundle: nil), forCellReuseIdentifier: xib_reuseID.reuseID)
//        })
//    }
}


AnimatedGifView.swift
//
//  AnimatedGifView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/8/23.
//

import Foundation
import SwiftUI

struct AnimatedGifView: UIViewRepresentable {
    
    @State var imageName: String = "giftGif"

    func makeUIView(context: Context) -> UIImageView {
        let image = UIImage.gifImageWithName(imageName)
        let imageView = UIImageView(image: image)
        imageView.contentMode = .scaleAspectFit
        return imageView
    }

    func updateUIView(_ uiView: UIImageView, context: Context) {
        uiView.image = .gifImageWithName(imageName)
    }
    
}


IntroManager.swift
//
//  IntroManager.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 11/1/23.
//

import Foundation

class IntroManager {
    
    static var isIntroComplete: Bool {
        get {
            UserDefaults.standard.bool(forKey: Constants.UserDefaults.hasFinishedIntro)
        }
        set {
            UserDefaults.standard.set(newValue, forKey: Constants.UserDefaults.hasFinishedIntro)
        }
    }
    
}


AdOrReviewCoordinator.swift
//
//  AdOrReviewCoordinator.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/6/24.
//

import Foundation
import _StoreKit_SwiftUI

class AdOrReviewCoordinator: ObservableObject {
    
    @Published var isShowingInterstitial: Bool = false
    @Published var requestedReview: Bool = false
    
    private var totalShowCallCount: Int = 0
    
    private let cooldown: Int = 3 // Invoke every 3 times
    private let reviewFrequency: Int = 3 // Show review every 3 times unless review has been received
    
    func showWithCooldown(isPremium: Bool) async {
        // Increment totalShowCallCount, doing it first to make sure it shows after cooldown period
        totalShowCallCount += 1
        
        if totalShowCallCount % cooldown == 0 {
            // Show
            await showImmediately(isPremium: isPremium)
        }
    }
    
    func showImmediately(isPremium: Bool) async {
        // Generate random number to see if it equals reviewFrequency to show a review
        let random = Int.random(in: 1...reviewFrequency)
        
        // Show review if random number is reviewFrequency, otherwise if premium show interstitial
        if random == reviewFrequency {
            await showReviewImmediately()
        } else {
            await showAdImmediately(isPremium: isPremium)
        }
    }
    
    func showAdImmediately(isPremium: Bool) async {
        await MainActor.run {
            if !isPremium {
                isShowingInterstitial = true
            }
        }
    }
    
    func showReviewImmediately() async {
        await MainActor.run {
            requestedReview = true
        }
    }
    
}


UIImage+GIF.swift
//
//  UIImage+GIF.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 1/10/23.
//

import UIKit
import ImageIO
// FIXME: comparison operators with optionals were removed from the Swift Standard Libary.
// Consider refactoring the code to use the non-optional operators.
fileprivate func < <T : Comparable>(lhs: T?, rhs: T?) -> Bool {
  switch (lhs, rhs) {
  case let (l?, r?):
    return l < r
  case (nil, _?):
    return true
  default:
    return false
  }
}



extension UIImage {
    
    /***
     Gif Creation
     */
    
    public class func gifImageWithData(_ data: Data) -> UIImage? {
        gifImageWithData(data, timeMultiplier: 1)
    }
    
    public class func gifImageWithData(_ data: Data, timeMultiplier: Double) -> UIImage? {
        guard let source = CGImageSourceCreateWithData(data as CFData, nil) else {
            print("image doesn't exist")
            return nil
        }
        
        return UIImage.animatedImageWithSource(source, timeMultiplier: timeMultiplier)
    }
    
    public class func gifImageWithURL(_ gifUrl: String) -> UIImage? {
        gifImageWithURL(gifUrl, timeMultiplier: 1)
    }
    
    public class func gifImageWithURL(_ gifUrl:String, timeMultiplier: Double) -> UIImage? {
        guard let bundleURL: URL = URL(string: gifUrl)
            else {
                print("image named \"\(gifUrl)\" doesn't exist")
                return nil
        }
        guard let imageData = try? Data(contentsOf: bundleURL) else {
            print("image named \"\(gifUrl)\" into NSData")
            return nil
        }
        
        return gifImageWithData(imageData, timeMultiplier: timeMultiplier)
    }
    
    public class func gifImageWithName(_ name: String) -> UIImage? {
        gifImageWithName(name, timeMultiplier: 1)
    }
    
    public class func gifImageWithName(_ name: String, timeMultiplier: Double) -> UIImage? {
        guard let bundleURL = Bundle.main
            .url(forResource: name, withExtension: "gif") else {
                print("SwiftGif: This image named \"\(name)\" does not exist")
                return nil
        }
        guard let imageData = try? Data(contentsOf: bundleURL) else {
            print("SwiftGif: Cannot turn image named \"\(name)\" into NSData")
            return nil
        }
        
        return gifImageWithData(imageData, timeMultiplier:  timeMultiplier)
    }
    
    /***
     First Frame
     */
    
    public class func gifFirstFrameWithData(_ data: Data) -> UIImage? {
        guard let source = CGImageSourceCreateWithData(data as CFData, nil) else {
            print("image doesn't exist")
            return nil
        }
        
        guard let cgImage = CGImageSourceCreateImageAtIndex(source, 0, nil) else {
            print("Cannot create cgImage from source")
            return nil
        }
        
        return UIImage(cgImage: cgImage)
    }
    
    public class func gifFirstFrameWithURL(_ gifUrl: String) -> UIImage? {
        guard let bundleURL: URL = URL(string: gifUrl) else {
            print("image named \"\(gifUrl)\" doesn't exist")
            return nil
        }
        
        guard let imageData = try? Data(contentsOf: bundleURL) else {
            print("image named \"\(gifUrl)\" into NSData")
            return nil
        }
        
        return gifFirstFrameWithData(imageData)
    }
    
    public class func gifFirstFrameWithName(_ name: String) -> UIImage? {
        guard let bundleURL = Bundle.main
            .url(forResource: name, withExtension: "gif") else {
                print("SwiftGif: This image named \"\(name)\" does not exist")
                return nil
        }
        
        guard let imageData = try? Data(contentsOf: bundleURL) else {
            print("SwiftGif: Cannot turn image named \"\(name)\" into NSData")
            return nil
        }
        
        return gifFirstFrameWithData(imageData)
    }
    
    /**
     Gif To Array
     */
    
    public class func gifToArrayWithData(_ data: Data) -> [UIImage]? {
        guard let source = CGImageSourceCreateWithData(data as CFData, nil) else  {
            print("image doesn't exist")
            return nil
        }
        
        return gifToArrayWithSource(source)
    }
    
    public class func gifToArrayWithURL(_ gifUrl: String) -> [UIImage]? {
        guard let bundleURL: URL = URL(string: gifUrl) else {
            print("image named \"\(gifUrl)\" doesn't exist")
            return nil
        }
        
        guard let imageData = try? Data(contentsOf: bundleURL) else {
            print("image named \"\(gifUrl)\" into NSData")
            return nil
        }
        
        return gifToArrayWithData(imageData)
    }
    
    public class func gifToArrayWithName(_ name: String) -> [UIImage]? {
        guard let bundleURL = Bundle.main.url(forResource: name, withExtension: "gif") else {
            print("SwiftGif: This image named \"\(name)\" does not exist")
            return nil
        }
        
        guard let imageData = try? Data(contentsOf: bundleURL) else {
            print("SwiftGif: Cannot turn image named \"\(name)\" into NSData")
            return nil
        }
        
        return gifToArrayWithData(imageData)
    }
    
    /***
     Private Methods
     */
    
    class func delayForImageAtIndex(_ index: Int, source: CGImageSource!) -> Double {
        var delay = 0.1
        
        let cfProperties = CGImageSourceCopyPropertiesAtIndex(source, index, nil)
        let gifProperties: CFDictionary = unsafeBitCast(
            CFDictionaryGetValue(cfProperties,
                Unmanaged.passUnretained(kCGImagePropertyGIFDictionary).toOpaque()),
            to: CFDictionary.self)
        
        var delayObject: AnyObject = unsafeBitCast(
            CFDictionaryGetValue(gifProperties,
                Unmanaged.passUnretained(kCGImagePropertyGIFUnclampedDelayTime).toOpaque()),
            to: AnyObject.self)
        if delayObject.doubleValue == 0 {
            delayObject = unsafeBitCast(CFDictionaryGetValue(gifProperties,
                Unmanaged.passUnretained(kCGImagePropertyGIFDelayTime).toOpaque()), to: AnyObject.self)
        }
        
        delay = delayObject as! Double
        
        if delay < 0.1 {
            delay = 0.1
        }
        
        return delay
    }
    
    class func gcdForPair(_ a: Int?, _ b: Int?) -> Int {
        var a = a
        var b = b
        if b == nil || a == nil {
            if b != nil {
                return b!
            } else if a != nil {
                return a!
            } else {
                return 0
            }
        }
        
        if a < b {
            let c = a
            a = b
            b = c
        }
        
        var rest: Int
        while true {
            rest = a! % b!
            
            if rest == 0 {
                return b!
            } else {
                a = b
                b = rest
            }
        }
    }
    
    class func gcdForArray(_ array: Array<Int>) -> Int {
        if array.isEmpty {
            return 1
        }
        
        var gcd = array[0]
        
        for val in array {
            gcd = UIImage.gcdForPair(val, gcd)
        }
        
        return gcd
    }
    
    class func animatedImageWithSource(_ source: CGImageSource, timeMultiplier: Double) -> UIImage? {
        let count = CGImageSourceGetCount(source)
        var images = [CGImage]()
        var delays = [Int]()
        
        for i in 0..<count {
            if let image = CGImageSourceCreateImageAtIndex(source, i, nil) {
                images.append(image)
            }
            
            let delaySeconds = UIImage.delayForImageAtIndex(Int(i),
                source: source)
            delays.append(Int(delaySeconds * 340.0 * timeMultiplier)) // Seconds to ms
        }
        
        let duration: Int = {
            var sum = 0
            
            for val: Int in delays {
                sum += val
            }
            
            return sum
        }()
        
        let gcd = gcdForArray(delays)
        var frames = [UIImage]()
        
        var frame: UIImage
        var frameCount: Int
        for i in 0..<count {
            frame = UIImage(cgImage: images[Int(i)])
            frameCount = Int(delays[Int(i)] / gcd)
            
            for _ in 0..<frameCount {
                frames.append(frame)
            }
        }
        
        let animation = UIImage.animatedImage(with: frames,
            duration: Double(duration) / 1000.0)
        
        return animation
    }
    
    private class func gifToArrayWithSource(_ source: CGImageSource) -> [UIImage] {
        let count = CGImageSourceGetCount(source)
        var images: [UIImage] = []
        
        for i in 0..<count {
            if let image = CGImageSourceCreateImageAtIndex(source, i, nil) {
                images.append(UIImage(cgImage: image))
            }
        }
        
        return images
        
    }
    
}


KeyboardDismisser.swift
//
//  KeyboardDismisser.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/20/23.
//

import Foundation
import SwiftUI

class KeyboardDismisser {
    
    static func dismiss() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
    
}


PremiumHelper.swift
////
////  PremiumHelper.swift
////  ChitChat
////
////  Created by Alex Coundouriotis on 4/2/23.
////
//
//import Foundation
//
//class PremiumHelper: Any {
//    
//    /***
//     Gets the current premium status of the user
//     */
//    static func get() -> Bool {
//        return UserDefaults.standard.bool(forKey: Constants.UserDefaults.storedIsPremium)
//    }
//    
//}


Color+Hex.swift
//
//  Color+Hex.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/21/23.
//

import Foundation
import SwiftUI

extension Color {
    init?(hex: String) {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")

        var rgb: UInt64 = 0

        var r: CGFloat = 0.0
        var g: CGFloat = 0.0
        var b: CGFloat = 0.0
        var a: CGFloat = 1.0

        let length = hexSanitized.count

        guard Scanner(string: hexSanitized).scanHexInt64(&rgb) else { return nil }

        if length == 6 {
            r = CGFloat((rgb & 0xFF0000) >> 16) / 255.0
            g = CGFloat((rgb & 0x00FF00) >> 8) / 255.0
            b = CGFloat(rgb & 0x0000FF) / 255.0

        } else if length == 8 {
            r = CGFloat((rgb & 0xFF000000) >> 24) / 255.0
            g = CGFloat((rgb & 0x00FF0000) >> 16) / 255.0
            b = CGFloat((rgb & 0x0000FF00) >> 8) / 255.0
            a = CGFloat(rgb & 0x000000FF) / 255.0

        } else {
            return nil
        }

        self.init(red: r, green: g, blue: b, opacity: a)
    }
}


Color+AdaptiveTextColor.swift
//
//  Color+AdaptiveTextColor.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/5/23.
//

import Foundation
import SwiftUI

extension Color {
    
    func adaptiveTextColor() -> Color {
            // Compute the color perceived brightness
            let baseColor = UIColor(self)
            guard let rgb = baseColor.cgColor.components else { return .black }
            let perceivedBrightness = (0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2])

            // Return white for dark colors and black for light colors
            return perceivedBrightness > 0.5 ? Color.black : Color.white
        }
    
}


IAPManager.swift
//
//  IAPManager.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 4/16/23.
//

//import FirebaseAnalytics
import Foundation
import StoreKit
import UIKit

class IAPManager: NSObject, SKPaymentTransactionObserver {
    
    static var storeKitTaskHandle: Task<Void, Error>?
    
    enum PurchaseError: Error {
        case pending
        case failed
        case cancelled
    }
    
    static func fetchProducts(productIDs: [String]) async throws -> [Product] {
        let storeProducts = try await Product.products(for: Set(productIDs))
        
        return storeProducts
}
    
//    static func getSubscriptionPeriod(product: Product) -> SubscriptionPeriod? {
//        if let subscription = product.subscription {
//
//            let unit = subscription.subscriptionPeriod.unit
//            let value = subscription.subscriptionPeriod.value
//
//            switch unit {
//            case .day:
//                switch value {
//                case 1:
//                    return .daily
//                case 7:
//                    return .weekly
//                default:
//                    return .invalid
//                }
//            case .week:
//                return .weekly
//            case .month:
//                switch value {
//                case 1:
//                    return .monthly
//                case 2:
//                    return .biMonthly
//                case 3:
//                    return .triMonthly
//                case 6:
//                    return .semiYearly
//                default:
//                    return .invalid
//                }
//            case .year:
//                return .yearly
//            @unknown default:
//                return .invalid
//            }
//        }
//
//        return nil
//    }
    
    static func purchase(_ product: Product) async throws -> Transaction {
        let result = try await product.purchase()
        
        switch result {
        case .pending:
            throw PurchaseError.pending
        case .success(let verification):
            switch verification {
            case .verified(let transaction):
//                // Log to Google Analytics
//                Analytics.logTransaction(transaction)
                
                // Finish transaction
                await transaction.finish()
                
                // Return transaction
                return transaction
            case .unverified:
                throw PurchaseError.failed
            }
        case .userCancelled:
            throw PurchaseError.cancelled
        @unknown default:
            assertionFailure("Unexpected result purchasing product in IAPManager")
            throw PurchaseError.failed
        }
        
    }
    
//    static func refreshReceipt() async {
//        class ReceiptRefreshRequestWrapper: NSObject, SKRequestDelegate {
//
//            private var completion: ((Bool)->Void)?
//
//            func doReceiptRefresh(completion: @escaping (Bool)->Void) {
//                self.completion = completion
//
//                let request = SKReceiptRefreshRequest()
//                request.delegate = self
//                request.start()
//            }
//
//            func requestDidFinish(_ request: SKRequest) {
//                completion?(true)
//            }
//
//            func request(_ request: SKRequest, didFailWithError error: Error) {
//                print("Error refreshing receipt: \(error.localizedDescription)")
//                completion?(false)
//            }
//        }
//
//        await withCheckedContinuation { continuation in
//            ReceiptRefreshRequestWrapper().doReceiptRefresh(completion: { success in
//                print("First")
//                continuation.resume()
//            })
//        }
//
////        ReceiptRefreshRequestWrapper().doReceiptRefresh()
//
//        print("Second")
//    }
    
    static func startStoreKitListener() {
        storeKitTaskHandle = listenForStoreKitUpdates()
    }
    
    static func listenForStoreKitUpdates() -> Task<Void, Error> {
        Task.detached {
            for await result in Transaction.updates {
                switch result {
                case .verified(let Transaction):
                    await Transaction.finish()
                    
                    print("Transaction verified in IAPManager listenForStoreKitUpdates")
                    
                    //TODO: Update isPremium, or do a server check with the new receipt
                    return
                case .unverified:
                    print("Transaction unverified in IAPManager listenForStoreKitUpdates")
                }
            }
        }
    }
    
    static func getVerifiedTransactions() async -> [Transaction] {
        var transactionList: [Transaction] = []
        
        for await result in Transaction.currentEntitlements {
            do {
                switch result {
                case .verified(let Transaction):
                    await Transaction.finish()
                    
                    print("Transaction verified in IAPManager getVerifiedTransactions")
                    
                    transactionList.append(Transaction)
                case .unverified:
                    print("Tranaction unverified in IAPManager getVerifiedTransactions")
                }
            }
        }
        
        return transactionList
    }
    
    
    static func refreshReceipt() {
        // Refresh the reciept for Tenjin and stuff
        let refreshReceiptRequest = SKReceiptRefreshRequest(receiptProperties: nil)
//        refreshReceiptRequest.delegate = self // Set delegate to self to receive callbacks
        refreshReceiptRequest.start() // This starts the receipt refresh process
    }
    
//    func requestDidFinish(_ request: SKRequest) {
//        print("Hi")
//    }
    
    
    override init() {
        super.init()
        
        SKPaymentQueue.default().add(self)
    }
    
    deinit {
        SKPaymentQueue.default().remove(self)
    }
    
    func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {
        print("Hi")
    }
    
}



NiceDateFormatter.swift
//
//  NiceDateFormatter.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/29/23.
//

import Foundation

class NiceDateFormatter {
    
    static let dateFormatter: DateFormatter = {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MMM d, h:mm a"
        return dateFormatter
    }()
    
}


NavigationKey.swift
////
////  NavigationKey.swift
////  Barback
////
////  Environment keys, values, and nice modifier method - https://sarunw.com/posts/how-to-define-custom-environment-values-in-swiftui/
////
////  Created by Alex Coundouriotis on 9/23/23.
////
//
//import Foundation
//import SwiftUI
//
//struct NavigationKey: EnvironmentKey {
//    
//    static var defaultValue: String = ""
//    
//}
//
//extension NavigationKey {
//    
//    var theValue: String {
//        get { self[NavigationKey.self] }
//    }
//    
//}


SubscriptionPeriod.swift
//
//  SubscriptionPeriod.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 4/16/23.
//

import Foundation

enum SubscriptionPeriod {
    case daily
    case weekly
    case monthly
    case biMonthly
    case triMonthly
    case semiYearly
    case yearly
    case invalid
}


View+Placeholder.swift
//
//  View+Placeholder.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/5/23.
//

import Foundation
import SwiftUI

extension View {
    func placeholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .leading,
        @ViewBuilder placeholder: () -> Content) -> some View {

        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}


View+FlexibleView.swift
//
//  View+FlexibleView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/20/24.
//

import SwiftUI

struct FlexibleView<Data: Collection, Content: View>: View where Data.Element: Hashable {
    
    let availableWidth: CGFloat
    let data: Data
    let spacing: CGFloat
    let alignment: HorizontalAlignment
    let content: (Data.Element) -> Content
    @State var elementsSize: [Data.Element: CGSize] = [:]
    
    var body : some View {
        VStack(alignment: alignment, spacing: spacing) {
            ForEach(computeRows(), id: \.self) { rowElements in
                HStack(spacing: spacing) {
                    ForEach(rowElements, id: \.self) { element in
                        content(element)
                            .fixedSize()
                            .readSize { size in
                                elementsSize[element] = size
                            }
                    }
                }
            }
        }
    }
    
    func computeRows() -> [[Data.Element]] {
        var rows: [[Data.Element]] = [[]]
        var currentRow = 0
        var remainingWidth = availableWidth
        
        for element in data {
            let elementSize = elementsSize[element, default: CGSize(width: availableWidth, height: 1)]
            
            if remainingWidth - (elementSize.width + spacing) >= 0 {
                rows[currentRow].append(element)
            } else {
                currentRow = currentRow + 1
                rows.append([element])
                remainingWidth = availableWidth
            }
            
            remainingWidth = remainingWidth - (elementSize.width + spacing)
        }
        
        return rows
    }
    
}

extension View {
    func readSize(onChange: @escaping (CGSize) -> Void) -> some View {
        background(
          GeometryReader { geometryProxy in
            Color.clear
              .preference(key: SizePreferenceKey.self, value: geometryProxy.size)
          }
        )
        .onPreferenceChange(SizePreferenceKey.self, perform: onChange)
    }
}

private struct SizePreferenceKey: PreferenceKey {
    static var defaultValue: CGSize = .zero
    static func reduce(value: inout CGSize, nextValue: () -> CGSize) {}
}


RecipeShareURLMaker.swift
//
//  RecipeShareURLMaker.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/5/24.
//

import Foundation

class RecipeShareURLMaker {
    
    private static let baseURL = "https://chitchatserver.com/chefappdeeplink/recipe/"
    
    static func getShareURL(recipeID: Int) -> URL? {
        URL(string: "\(baseURL)\(recipeID)")
    }
    
}


AppGroupLoader.swift
//
//  AppGroupLoader.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 9/13/24.
//

import Foundation

class AppGroupLoader {
    
    private let appGroupIdentifier: String
    private let fileManager: FileManager

    init(appGroupIdentifier: String) {
        self.appGroupIdentifier = appGroupIdentifier
        self.fileManager = FileManager.default
    }

    // Loads a Codable object
    func loadCodable<T: Codable>(_ type: T.Type, from fileName: String) -> T? {
        do {
            if let data = loadData(from: fileName) {
                let object = try JSONDecoder().decode(type, from: data)
                return object
            } else {
                return nil
            }
        } catch {
            print("Error decoding Codable object: \(error)")
            return nil
        }
    }

    // Loads Data from a file
    func loadData(from fileName: String) -> Data? {
        guard let containerURL = fileManager.containerURL(forSecurityApplicationGroupIdentifier: appGroupIdentifier) else {
            print("Error: Could not find container URL for app group.")
            return nil
        }
        let fileURL = containerURL.appendingPathComponent(fileName)

        do {
            let data = try Data(contentsOf: fileURL)
            return data
        } catch {
            print("Error loading file: \(error)")
            return nil
        }
    }

    // Returns the file URL for a given file name
    func fileURL(for fileName: String) -> URL? {
        guard let containerURL = fileManager.containerURL(forSecurityApplicationGroupIdentifier: appGroupIdentifier) else {
            print("Error: Could not find container URL for app group.")
            return nil
        }
        let fileURL = containerURL.appendingPathComponent(fileName)
        if fileManager.fileExists(atPath: fileURL.path) {
            return fileURL
        } else {
            print("Error: File does not exist at \(fileURL.path)")
            return nil
        }
    }

    // Deletes a file
    func deleteFile(named fileName: String) {
        guard let containerURL = fileManager.containerURL(forSecurityApplicationGroupIdentifier: appGroupIdentifier) else {
            return
        }
        let fileURL = containerURL.appendingPathComponent(fileName)
        if fileManager.fileExists(atPath: fileURL.path) {
            do {
                try fileManager.removeItem(at: fileURL)
            } catch {
                print("Error deleting file: \(error)")
            }
        }
    }
    
}


Array+Safe.swift
//
//  Array+Safe.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 9/28/24.
//

import Foundation

// A helper extension to safely access array elements.
extension Array {
    subscript(safe index: Index) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}


VideoViewRepresentable.swift
//
//  VideoViewRepresentable.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 3/2/24.
//

import AVKit
import Foundation
import SwiftUI

struct VideoViewRepresentable : UIViewControllerRepresentable {
    
    @Binding var player: AVPlayer
    
    init(player: Binding<AVPlayer>) {
        self._player = player
    }
    
    func makeUIViewController(context: Context) -> AVPlayerViewController {
//        let controller = AVPlayerViewController()
//        controller.player = player
//        controller.showsPlaybackControls = false
        
//        player.play()
        let controller = AVPlayerViewController()
        controller.player = self.player
        controller.showsPlaybackControls = false
        
        controller.videoGravity = .resizeAspectFill
        
        return controller
    }
    
    func updateUIViewController(_ uiViewController: AVPlayerViewController, context: Context) {
//        let controller = AVPlayerViewController()
        uiViewController.player = player
//        controller.showsPlaybackControls = false
        
//        player.play()
        
//        return controller
    }
    
}


SwiftyGif.swift
//
//  SwiftyGif.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 10/27/23.
//
// https://github.com/kirualex/SwiftyGif/issues/128

import SwiftUI
import SwiftyGif
import UIKit

struct SwiftyGif: UIViewRepresentable {
    private let data: Data?
    private let name: String?
    private let loopCount: Int?
    @Binding var playGif: Bool
    
    init(data: Data, loopCount: Int = -1, playGif: Binding<Bool> = .constant(true)) {
        self.data = data
        self.name = nil
        self.loopCount = loopCount
        self._playGif = playGif
    }
    
    init(name: String, loopCount: Int = -1, playGif: Binding<Bool> = .constant(true)) {
        self.data = nil
        self.name = name
        self.loopCount = loopCount
        self._playGif = playGif
    }
    
    func makeUIView(context: Context) -> UIGIFImageView {
        var gifImageView: UIGIFImageView
        if let data = data {
            gifImageView = UIGIFImageView(data: data, loopCount: loopCount!, playGif: playGif)
        } else {
            gifImageView = UIGIFImageView(name: name!, loopCount: loopCount!, playGif: playGif)
        }
        return gifImageView
    }
    
    func updateUIView(_ gifImageView: UIGIFImageView, context: Context) {
        gifImageView.updateGIF(name: name ?? "", data: data, loopCount: loopCount!)
        
//        gifImageView.imageView.updateCache()
        
        if playGif {
            gifImageView.imageView.loopCount = loopCount ?? 0
            
            gifImageView.imageView.startAnimatingGif()
        } else {
            gifImageView.imageView.stopAnimatingGif()
        }
    }
}

class UIGIFImageView: UIView {
    private var image = UIImage()
    var imageView = UIImageView()
    private var data: Data?
    private var name: String?
    private var loopCount: Int?
    private var playGif: Bool?
    
    override init(frame: CGRect) {
        super.init(frame: frame)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    convenience init(name: String, loopCount: Int, playGif: Bool) {
        self.init()
        self.name = name
        self.loopCount = loopCount
        self.playGif = playGif
        self.layoutSubviews()
    }
    
    convenience init(data: Data, loopCount: Int, playGif: Bool) {
        self.init()
        self.data = data
        self.loopCount = loopCount
        self.playGif = playGif
        self.layoutSubviews()
    }
    
    override func layoutSubviews() {
        super.layoutSubviews()
        imageView.frame = bounds
        self.addSubview(imageView)
    }
    
    func updateGIF(name: String, data: Data?, loopCount: Int) {
        do {
            if let data = data {
                image = try UIImage(gifData: data)
            } else {
                image = try UIImage(gifName: name)
            }
        } catch {
            print("Error updating gif... \(error)")
        }
        
        if let subview = self.subviews.first as? UIImageView {
            // if new gif, remove old to show new
            if image.imageData != subview.gifImage?.imageData {
                imageView = UIImageView(gifImage: image, loopCount: loopCount)
                imageView.contentMode = .scaleAspectFit
                subview.removeFromSuperview()
            }
        } else {
            print("error: no existing subview")
        }
    }
}


AppGroupSaver.swift
//
//  FileSaver.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 9/13/24.
//

import Foundation

class AppGroupSaver {
    
    private let appGroupIdentifier: String
    private let fileManager: FileManager

    init(appGroupIdentifier: String) {
        self.appGroupIdentifier = appGroupIdentifier
        self.fileManager = FileManager.default
    }

    // Saves a Codable object
    func saveCodable<T: Codable>(_ codable: T, to fileName: String) -> Bool {
        do {
            let data = try JSONEncoder().encode(codable)
            return saveData(data, to: fileName)
        } catch {
            print("Error encoding Codable object: \(error)")
            return false
        }
    }

    // Saves Data to a file
    func saveData(_ data: Data, to fileName: String) -> Bool {
        guard let containerURL = fileManager.containerURL(forSecurityApplicationGroupIdentifier: appGroupIdentifier) else {
            print("Error: Could not find container URL for app group.")
            return false
        }
        let fileURL = containerURL.appendingPathComponent(fileName)
        
        do {
            try data.write(to: fileURL)
            return true
        } catch {
            print("Error saving file: \(error)")
            return false
        }
    }

    // Saves a file from a source URL
    func saveFile(from sourceURL: URL, destinationFileName: String) -> Bool {
        guard let containerURL = fileManager.containerURL(forSecurityApplicationGroupIdentifier: appGroupIdentifier) else {
            print("Error: Could not find container URL for app group.")
            return false
        }
        let destinationURL = containerURL.appendingPathComponent(destinationFileName)
        
        do {
            if fileManager.fileExists(atPath: destinationURL.path) {
                try fileManager.removeItem(at: destinationURL)
            }
            try fileManager.copyItem(at: sourceURL, to: destinationURL)
            return true
        } catch {
            print("Error saving file: \(error)")
            return false
        }
    }

    // Saves Data as a file
    func saveFile(data: Data, destinationFileName: String) -> Bool {
        guard let containerURL = fileManager.containerURL(forSecurityApplicationGroupIdentifier: appGroupIdentifier) else {
            print("Error: Could not find container URL for app group.")
            return false
        }
        let destinationURL = containerURL.appendingPathComponent(destinationFileName)
        
        do {
            try data.write(to: destinationURL)
            return true
        } catch {
            print("Error saving file: \(error)")
            return false
        }
    }
    
}


HapticHelper.swift
//
//  HapticHelper.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 4/29/23.
//

import Foundation
import UIKit

class HapticHelper: Any {
    
    static func doLightHaptic() {
        UIImpactFeedbackGenerator(style: .soft).impactOccurred()
    }
    
    static func doMediumHaptic() {
        UIImpactFeedbackGenerator(style: .medium).impactOccurred()
    }
    
    static func doSuccessHaptic() {
        UINotificationFeedbackGenerator().notificationOccurred(.success)
    }
    
    static func doWarningHaptic() {
        UINotificationFeedbackGenerator().notificationOccurred(.warning)
    }
    
}


PasteboardHelper.swift
//
//  PasteboardHelper.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 4/25/23.
//

import Foundation
import UIKit

class PasteboardHelper: Any {
    
    static func copy(_ text: String) {
        copy(text, showFooterIfNotPremium: false, isPremium: false)
    }
    
    static func copy(_ text: String, showFooterIfNotPremium: Bool, isPremium: Bool) {
        // Copy to Pasteboard with or without footer
        //TODO: - Make the footer text an option in settings instead of disabling it for premium entirely
        var toCopyText = ""
        if showFooterIfNotPremium && !isPremium, let shareURL = UserDefaults.standard.string(forKey: Constants.UserDefaults.storedShareURL) {
            toCopyText = "\(text)

\(Constants.Additional.copyFooterText)
\(shareURL)"
        } else {
            toCopyText = "\(text)"
        }
        
        UIPasteboard.general.string = toCopyText
    }
    
    static func paste() -> String? {
        UIPasteboard.general.string
    }
    
}


SingleAxisGeometryReader.swift
//
//  SingleAxisGeometryReader.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/20/24.
//
// https://stackoverflow.com/questions/64778379/how-to-use-geometry-reader-so-that-the-view-does-not-expand

import Foundation
import SwiftUI

struct SingleAxisGeometryReader<Content: View>: View {
    
    private struct SizeKey: PreferenceKey {
        static var defaultValue: CGFloat { 10 }
        static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
            value = max(value, nextValue())
        }
    }

    @State private var size: CGFloat = SizeKey.defaultValue
    var axis: Axis = .horizontal
    var alignment: Alignment = .center
    let content: (CGFloat)->Content

    var body: some View {
        content(size)
            .frame(maxWidth:  axis == .horizontal ? .infinity : nil,
                   maxHeight: axis == .vertical   ? .infinity : nil,
                   alignment: alignment)
            .background(GeometryReader {
                proxy in
                Color.clear.preference(key: SizeKey.self, value: axis == .horizontal ? proxy.size.width : proxy.size.height)
            }).onPreferenceChange(SizeKey.self) { size = $0 }
    }
    
}


WebView.swift
//
//  WebView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/8/23.
//

import SwiftUI
import WebKit
 
struct WebView: UIViewRepresentable {
 
    var url: URL
 
    func makeUIView(context: Context) -> WKWebView {
        return WKWebView()
    }
 
    func updateUIView(_ webView: WKWebView, context: Context) {
        let request = URLRequest(url: url)
        webView.load(request)
    }
}


ObservedNavigationPath.swift
//
//  ObservedNavigationPath.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/23/23.
//

import Foundation
import SwiftUI

class ObservedNavigationPath: ObservableObject {
    
    @Published var navigationPath: NavigationPath = NavigationPath()
    
    func clear() {
        navigationPath.removeLast(navigationPath.count)
    }
    
}


ConstantsUpdater.swift
//
//  ConstantsHelper.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 3/30/23.
//

import Foundation
import SwiftUI

class ConstantsUpdater: ObservableObject {
    
    @AppStorage("EasyPantryUpdateContainerOlderThanDays") var easyPantryUpdateContainerOlderThanDays: Int = 3
    @AppStorage("LaunchCount") var launchCount: Int = 0
    
    static var encodedBingAPIKey: String? {
        get {
            UserDefaults.standard.string(forKey: Constants.UserDefaults.storedEncodedBingAPIKey)
        }
        set {
            UserDefaults.standard.set(newValue, forKey: Constants.UserDefaults.storedEncodedBingAPIKey)
        }
    }
    
    static var shareURL: String {
        get {
            UserDefaults.standard.string(forKey: Constants.UserDefaults.storedShareURL) ?? Constants.Additional.defaultShareURL
        }
        set {
            UserDefaults.standard.set(newValue, forKey: Constants.UserDefaults.storedShareURL)
        }
    }
    
    static var weeklyProductID: String {
        get {
            UserDefaults.standard.string(forKey: Constants.UserDefaults.storedWeeklyProductID) ?? Constants.Additional.fallbackWeeklyProductIdentifier
        }
        set {
            UserDefaults.standard.set(newValue, forKey: Constants.UserDefaults.storedWeeklyProductID)
        }
    }
    
    static var monthlyProductID: String {
        get {
            UserDefaults.standard.string(forKey: Constants.UserDefaults.storedMonthlyProductID) ?? Constants.Additional.fallbackMonthlyProductIdentifier
        }
        set {
            UserDefaults.standard.set(newValue, forKey: Constants.UserDefaults.storedMonthlyProductID)
        }
    }
    
    
    func update() async throws {
        let response = try await ChefAppNetworkService.getImportantConstants()
        
        ConstantsUpdater.encodedBingAPIKey = response.body.bingAPIKey
        
        if let shareURL = response.body.shareURL {
            ConstantsUpdater.shareURL = shareURL
        }
        
//        // Check if iapVarientSuffix is nil or empty, and if so do chance calculation based on priceVAR2DisplayChance and set iapVarientSuffix
//        if iapVarientSuffix == nil || iapVarientSuffix!.isEmpty, let priceVAR2DisplayChance = response.body.priceVAR2DisplayChance {
//            // Get random double
//            let randomDouble = Double.random(in: 0..<1)
//            
//            // Since we're getting a percentage that the price will be VAR2, we can create a random number between 0-1 and check if it is less than priceVAR2DisplayChance.. for example, it the priceVAR2DisplayChance is 0.8, check if our random number is less than or equal to 0.8 and if so then set suffix to VAR2 otherwise VAR1
//            iapVarientSuffix = randomDouble < priceVAR2DisplayChance ? priceVAR2Suffix : priceVAR1Suffix
//        }
        
//        // Set weekly and monthly productID and displayPrice by iapVarientSuffix
//        if iapVarientSuffix == priceVAR2Suffix {
//            // Set VAR2
//            if let responseWeeklyProductID = response.body.weeklyProductID_VAR2 {
//                weeklyProductID = responseWeeklyProductID
//            }
//            
//            if let responseMonthlyProductID = response.body.monthlyProductID_VAR2 {
//                monthlyProductID = responseMonthlyProductID
//            }
//        } else {
            // Default to VAR1
            if let weeklyProductID = response.body.weeklyProductID {
                ConstantsUpdater.weeklyProductID = weeklyProductID
            }
            
            if let monthlyProductID = response.body.monthlyProductID {
                ConstantsUpdater.monthlyProductID = monthlyProductID
            }
//        }
        
    }
    
    private static func setIfNil(_ value: Any, forKey key: String) {
        if UserDefaults.standard.object(forKey: key) == nil {
            UserDefaults.standard.set(value, forKey: key)
        }
    }
    
}


UIImage+Rotated.swift
//
//  CGImage+Rotate.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 2/1/23.
//

import UIKit
import Foundation

extension UIImage {
    func rotated(radians: Float) -> UIImage? {
            var newSize = CGRect(origin: CGPoint.zero, size: self.size).applying(CGAffineTransform(rotationAngle: CGFloat(radians))).size
            // Trim off the extremely small float value to prevent core graphics from rounding it up
            newSize.width = floor(newSize.width)
            newSize.height = floor(newSize.height)

            UIGraphicsBeginImageContextWithOptions(newSize, false, self.scale)
            let context = UIGraphicsGetCurrentContext()!

            // Move origin to middle
            context.translateBy(x: newSize.width/2, y: newSize.height/2)
            // Rotate around middle
            context.rotate(by: CGFloat(radians))
            // Draw the image at its center
            self.draw(in: CGRect(x: -self.size.width/2, y: -self.size.height/2, width: self.size.width, height: self.size.height))

            let newImage = UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()

            return newImage
        }
}


Publisher+KeyboardHeight.swift
////
////  Publisher+KeyboardHeight.swift
////  Barback
////
////  Created by Alex Coundouriotis on 9/20/23.
////
//
//import Combine
//import Foundation
//import UIKit
//
//extension Publishers {
//    // 1.
//    static var keyboardHeight: AnyPublisher<CGFloat, Never> {
//        // 2.
//        let willShow = NotificationCenter.default.publisher(for: UIApplication.keyboardWillShowNotification)
//            .map { $0.keyboardHeight }
//        
//        let willHide = NotificationCenter.default.publisher(for: UIApplication.keyboardWillHideNotification)
//            .map { _ in CGFloat(0) }
//
//        // 3.
//        return MergeMany(willShow, willHide)
//            .eraseToAnyPublisher()
//    }
//}


ImageResizer.swift
//
//  ImageResizer.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 4/10/24.
//

import Foundation
import UIKit

class ImageResizer {
    
    static func resizedJpegDataTo512(from imageData: Data) -> Data? {
        // Create a UIImage from the input data
        guard let image = UIImage(data: imageData) else {
            print("Error: Cannot create image from data")
            return nil
        }
        
        return resizedJpegDataTo512(from: image)
    }
    
    static func resizedJpegDataTo512(from image: UIImage) -> Data? {
        // Calculate the new size to maintain aspect ratio
        let aspectWidth = 512 / image.size.width
        let aspectHeight = 512 / image.size.height
        let aspectRatio = min(aspectWidth, aspectHeight)

        let newSize = CGSize(width: image.size.width * aspectRatio, height: image.size.height * aspectRatio)

        // Create UIGraphics context with new size
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        image.draw(in: CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height))
        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()

        // Convert the resized image back to data
        guard let newImageData = resizedImage?.jpegData(compressionQuality: 0.85) else {
            print("Error: Cannot convert resized image back to Data")
            return nil
        }

        return newImageData
    }
    
}


PDFReader.swift
//
//  PDFReader.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 5/4/24.
//

import Foundation
import PDFKit

class PDFReader {
    
    static func readPDF(from pdf: PDFDocument, maxChars: Int = 6500) -> String? {
        let pageCount = pdf.pageCount
        let content = NSMutableAttributedString()
        
        for i in 0..<pageCount {
            // Get page, otherwise continue
            guard let page = pdf.page(at: i) else {
                continue
            }
            
            // Get pageContent, otherwise continue
            guard let pageContent = page.attributedString else {
                continue
            }
            
            // If pageContent length plus content length is less than maxChars append to content, otherwise break
            if pageContent.length + content.length < maxChars {
                // Append pageContent to content
                content.append(pageContent)
            } else {
                // Break from for loop
                break
            }
        }
        
        return content.string
    }
    
}


ProductUpdater.swift
//
//  ProductUpdater.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/7/23.
//

import Foundation
import StoreKit
import SwiftUI

class ProductUpdater: ObservableObject {
    
    @Published var shouldRetryLoadingOnError: Bool = false
    @Published var subscriptionActive: Bool = false
    
    @Published var weeklyProduct: Product?
    @Published var monthlyProduct: Product?
    
    
    init() {
        Task {
            await refresh()
        }
    }
    
    func refresh() async {
        let weeklyProductID = ConstantsUpdater.weeklyProductID
        let monthlyProductID = ConstantsUpdater.monthlyProductID
        
        do {
            let products = try await IAPManager.fetchProducts(productIDs: [
                weeklyProductID,
                monthlyProductID
            ])
            
            await MainActor.run {
                self.weeklyProduct = products.first(where: {$0.id == weeklyProductID})
                self.monthlyProduct = products.first(where: {$0.id == monthlyProductID})
            }
        } catch {
            // TODO: Handle errors
            print("Error fetching products in UltraViewModel... \(error)")
        }
    }
    
}


UIScreen+Size.swift
//
//  UIScreen+Size.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 3/3/24.
//

import Foundation
import UIKit

extension UIScreen{
   static let screenWidth = UIScreen.main.bounds.size.width
   static let screenHeight = UIScreen.main.bounds.size.height
   static let screenSize = UIScreen.main.bounds.size
}


View+Fonts.swift
//
//  View+Fonts.swift
//  MealPlanChef
//
//  Created by Alex Coundouriotis on 12/1/24.
//

import SwiftUI

extension View {
    
    func font(_ fontWeight: FontWeight, _ size: CGFloat) -> some View {
        self
            .font(.custom(fontWeight.appFontName, size: size))
    }
    
}


AuthHelper.swift
//
//  AuthHelper.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 3/30/23.
//

import Foundation

class AuthHelper {
    
    static func get() -> String? {
        return UserDefaults.standard.string(forKey: Constants.UserDefaults.storedAuthTokenKey)
    }
    
    /***
     Ensure - Gets the authToken either from the server or locally
     
     throws
        - If the client cannot get the AuthToken from the server and there is no AuthToken available locally
     */
    static func ensure() async throws -> String {
        // If authToken, verify it with the server and if not valid set storerd to nil so that it will register a new user
        if let authToken = get() {
            // TODO: Should I be creating the requests somewhere else, and what would I call it?
            // Create authRequest
            let authRequest = AuthRequest(
                authToken: authToken
            )
            
            // If not valid, set to nil
            if try await !ChefAppNetworkService.validateAuthToken(request: authRequest).body.isValid {
                UserDefaults.standard.set(nil, forKey: Constants.UserDefaults.storedAuthTokenKey)
            }
        }
        
        // If there is an authTokne, return it, otherise register the user and update the authToken in UserDefaults
        if let authToken = get() {
            return authToken
        } else {
            let registerUserResponse = try await ChefAppNetworkService.registerUser()
            
            let authToken = registerUserResponse.body.authToken
            
            UserDefaults.standard.set(authToken, forKey: Constants.UserDefaults.storedAuthTokenKey)
                
            return authToken
        }
        
    }
    
    /***
     Regenerate - Deletes current authToken and gets a new one from the server
     
     throws
        - If the client cannot get the AuthToken from the server and there is no AuthToken available locally
     */
    @discardableResult
    static func regenerate() async throws -> String {
        UserDefaults.standard.set(nil, forKey: Constants.UserDefaults.storedAuthTokenKey)
        
        let registerUserResponse = try await ChefAppNetworkService.registerUser()
        
        UserDefaults.standard.set(registerUserResponse.body.authToken, forKey: Constants.UserDefaults.storedAuthTokenKey)
        
        return UserDefaults.standard.string(forKey: Constants.UserDefaults.storedAuthTokenKey)!
    }
    
}


WebpageTextReader.swift
//
//  WebpageTextReader.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 5/4/24.
//

import Foundation
import PDFKit

class WebpageTextReader {
    
    static func getWebpageText(externalURL: URL, maxChars: Int = 6500) async throws -> String? {
        var request = URLRequest(url: externalURL)
//        request.addValue("text/plain", forHTTPHeaderField: "Content-Type")
        request.httpMethod = "GET"
        request.timeoutInterval = 60
        
//        let (data, response) = try await URLSession.shared.data(for: request)
        let (data, response) = try await URLSession.shared.data(from: externalURL)
        
        if let html = String(data: data, encoding: .utf8) {
//            // If html can be unwrapped parse with SwiftSoup to get text and return prefixed to a set amount
//            let document: Document = try SwiftSoup.parse(html)
//            return try String(document.text().prefix(3000))
            
            return await withCheckedContinuation { continuation in
                NSAttributedString.loadFromHTML(data: data, completionHandler: { string, attributes, error in
                    if let trimmedString = string?.string.prefix(maxChars) {
                        continuation.resume(returning: String(trimmedString))
                    } else {
                        continuation.resume(returning: nil)
                    }
                })
            }
        } else {
            // html could be nil because externalURL refers to a file that is not received in data with GET so try decoding it as a PDF and return
            if let pdf = PDFDocument(data: data) {
                return PDFReader.readPDF(
                    from: pdf,
                    maxChars: maxChars)
            }
        }
        
        return nil
        
        
        
//        let html: String
//        do {
//            
//        } catch let error as NSError {
//            if error.code == 264 {
//                // Error is probably because externalURL refers to a file that is not decodable with String(contextOf: ) so try decoding it as a PDF and return
//                if let pdf = PDFDocument(url: externalURL) {
//                    return PDFReader.readPDF(from: pdf)
//                }
//            }
//            
//            throw error
//        }
//        let document: Document = try SwiftSoup.parse(html)
//        return try String(document.text().prefix(3000))
        
//        if let pdf = PDFDocument(data: pdfData) {
//            let pageCount = pdf.pageCount
//            let content = NSMutableAttributedString()
//
//            for i in 0..<pageCount {
//                // Get page, otherwise continue
//                guard let page = pdf.page(at: i) else {
//                    continue
//                }
//
//                // Get pageContent, otherwise continue
//                guard let pageContent = page.attributedString else {
//                    continue
//                }
//
//                // Append pageContent to content
//                content.append(pageContent)
//            }
//
//            return content.string
//        }
//
//        return nil
    }
    
}


Button+DismissesKeyboard.swift
//
//  KeyboardDismissingButton.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/20/23.
//

import Foundation
import SwiftUI

struct KeyboardDismissingButton<Label: View>: View {

    var action: () -> Void
    let content: Label
    
    init(action: @escaping ()->Void, @ViewBuilder label: ()->Label) {
        self.action = action
        self.content = label()
    }
    
    var body: some View {
        Button(action: {
            KeyboardDismisser.dismiss()
            action()
        }) {
            content
        }
    }
    
}


StringFractionSolver.swift
//
//  StringFractionSolver.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 7/18/23.
//

import Foundation

class StringFractionSolver {
    
    static func solveFraction(from string: String) -> Double? {
        // Check if it's a fraction and set solvedDoubleValue to solved fraction
        let forwardSlashSplitFirstAmountString = string.split(separator: "/")
        
        // Ensure forwardSlashSplitFirstAmountString has exactly two values, otherwise return nil
        guard forwardSlashSplitFirstAmountString.count == 2 else {
            return nil
        }
        
        // Unwrap numerator and denomenator as doubles, otherwise return nil
        guard let numerator = Double(String(forwardSlashSplitFirstAmountString[0])), let denomenator = Double(String(forwardSlashSplitFirstAmountString[1])) else {
            return nil
        }
        
        // Solve fraction and set to solvedDoubleValue
        return numerator / denomenator
    }
    
}


NavigationConfigurator.swift
//
//  NavigationConfigurator.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/23/23.
//

import Foundation
import SwiftUI
import UIKit

struct NavigationConfigurator: UIViewControllerRepresentable {
    var configure: (UINavigationController) -> Void = { _ in }

    func makeUIViewController(context: UIViewControllerRepresentableContext<NavigationConfigurator>) -> UIViewController {
        UIViewController()
    }
    func updateUIViewController(_ uiViewController: UIViewController, context: UIViewControllerRepresentableContext<NavigationConfigurator>) {
        if let nc = uiViewController.navigationController {
            self.configure(nc)
        }
    }

}


NetworkClient.swift
//
//  NetworkClient.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 3/29/23.
//

import Foundation

class NetworkClient {
    
    static func get(url: URL, headers: [String: String]?) async throws -> (Data, URLResponse) {
        // Create the request object
        var request = URLRequest(url: url)

        // Set request method
        request.httpMethod = "GET"

        // Set headers if not nil
        if let headers = headers {
            headers.forEach({k, v in
                request.setValue(v, forHTTPHeaderField: k)
            })
        }

        // Get the shared URL Session
        let (data, response) = try await URLSession.shared.data(for: request)

        return (data, response)
    }
    
    static func post(url: URL, body: Codable, headers: [String: String]?) async throws -> (Data, URLResponse) {
        // Try encoding body object to JSON
        let bodyData = try JSONEncoder().encode(body)
        
        // Create the request object
        var request = URLRequest(url: url)
        
        // Set request method and body
        request.httpMethod = "POST"
        request.httpBody = bodyData
        
        // Set headers if not nil
        if headers != nil {
            headers!.forEach({k, v in
                request.setValue(v, forHTTPHeaderField: k)
            })
        }
        
        // Get the shared URL Session
        let session = URLSession.shared
        let (data, response) = try await session.data(for: request)
        
        return (data, response)
    }
    
    
    // TODO: Remove because this is now legacy
    static func post(url: URL, body: Codable, headers: [String: String]?, completion: @escaping (Data?, Error?)->Void) throws {
        // Try encoding body object to JSON
        let bodyData = try JSONEncoder().encode(body)
        
        // Create the request object
        var request = URLRequest(url: url)
        
        // Set request method and body
        request.httpMethod = "POST"
        request.httpBody = bodyData
        
        // Set headers if not nil
        if headers != nil {
            headers!.forEach({k, v in
                request.setValue(v, forHTTPHeaderField: k)
            })
        }
        
        // Get the shared URL Session
        let session = URLSession.shared
        let task = session.dataTask(with: request, completionHandler: {data, response, error in
            // Print error message here first
            if let error = error {
                print("HTTPSClient Post - Error getting response")
                print(error)
            }
            
            // Completion block
            completion(data, error)
        })
        
        task.resume()
    }
    
}


AuthRequest.swift
//
//  AuthRequest.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 3/30/23.
//

import Foundation

struct AuthRequest: Codable {
    
    var authToken: String
    
    enum CodingKeys: String, CodingKey {
        case authToken
    }
    
}


MakeRecipeFromIdeaRequest.swift
//
//  MakeRecipeRequest.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 6/23/23.
//

import Foundation

struct MakeRecipeFromIdeaRequest: Codable {
    
    var authToken: String
    var ideaID: Int64
    var additionalInput: String?
    
    enum CodingKeys: String, CodingKey {
        case authToken
        case ideaID
        case additionalInput
    }
    
}


BlankRequest.swift
//
//  BlankRequest.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 3/30/23.
//

import Foundation

struct BlankRequest: Codable {
    
}


ValidateAndUpdateReceiptRequest.swift
//
//  ValidateAndUpdateReceiptRequest.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 3/30/23.
//

import Foundation

struct ValidateAndUpdateReceiptRequest: Codable {
    
    var authToken: String
    var receiptString: String
    
    enum CodingKeys: String, CodingKey {
        case authToken
        case receiptString
    }
    
}


RegenerateRecipeMeasuredIngredientsAndDirectionsAndIdeaRecipeIngredientsRequest.swift
//
//  RegenerateRecipeDirectionsAndIdeaRecipeIngredientsRequest.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 7/19/23.
//

import Foundation

struct RegenerateRecipeMeasuredIngredientsAndDirectionsAndIdeaRecipeIngredientsRequest: Codable {
    
    var authToken: String
    var recipeID: Int64
    var newName: String?
    var newSummary: String?
    var newServings: Int?
    var measuredIngredients: [String]?
    var additionalInput: String?
    
    enum CodingKeys: String, CodingKey {
        case authToken
        case recipeID
        case newName
        case newSummary
        case newServings
        case measuredIngredients
        case additionalInput
    }
    
}


AddOrRemoveLikeOrDislikeRequest.swift
//
//  AddOrRemoveLikeOrDislikeRequest.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/27/24.
//

import Foundation

struct AddOrRemoveLikeOrDislikeRequest: Codable {
    
    let authToken: String
    let recipeID: Int
    let shouldAdd: Bool
    let isLike: Bool
    
}


ParsePantryItemsRequest.swift
//
//  ParsePantryItemsRequest.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/18/23.
//

import Foundation

struct ParsePantryItemsRequest: Codable {
    
    var authToken: String
    var input: String?
    var imageDataInput: Data?
    
    enum CodingKeys: String, CodingKey {
        case authToken
        case input
        case imageDataInput
    }
    
}


CreateRecipeIdeaRequest.swift
//
//  MakeRecipeIdeaRequest.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 6/23/23.
//

import Foundation

struct CreateRecipeIdeaRequest: Codable {
    
    var authToken: String
    var ingredients: String
    var modifiers: String?
    var expandIngredientsMagnitude: Int
    
    enum CodingKeys: String, CodingKey {
        case authToken
        case ingredients
        case modifiers
        case expandIngredientsMagnitude
    }
    
}


APNSRegistrationRequest.swift
//
//  APNSRegistrationRequest.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 4/2/24.
//

import Foundation

struct APNSRegistrationRequest: Codable {
    
    var authToken: String
    var deviceID: Data
    
    enum CodingKeys: String, CodingKey {
        case authToken
        case deviceID
    }
    
}


LogPinterestConversionRequest.swift
//
//  LogPinterestConversionRequest.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/25/24.
//

import Foundation

struct LogPinterestConversionRequest: Codable {
    
    let authToken: String
    let idfa: String
    let eventName: String
    let eventID: String
    let test: Bool
    
    enum CodingKeys: String, CodingKey {
        case authToken
        case idfa
        case eventName
        case eventID
        case test
    }
    
}


TikTokSearchRequest.swift
//
//  TikTokSearchRequest.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/3/24.
//

import Foundation

struct TikTokSearchRequest: Codable {
    
    enum Category: String, Codable {
        case general = "general"
        case uesrs = "users"
        case videos = "videos"
        case autocomplete = "autocomplete"
    }
    
    let authToken: String
    let category: Category
    let query: String
    let nextCursor: String?
    
    enum CodingKeys: String, CodingKey {
        case authToken
        case category
        case query
        case nextCursor
    }
    
}


TagRecipeIdeaRequest.swift
//
//  TagRecipeIdeaRequest.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 7/6/23.
//

import Foundation

struct TagRecipeIdeaRequest: Codable {
    
    var authToken: String
    var recipeID: Int64
    
    enum CodingKeys: String, CodingKey {
        case authToken
        case recipeID
    }
    
}


GetAndDuplicateRecipeRequest.swift
//
//  GetAndDuplicateRecipeRequest.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/5/24.
//

import Foundation

struct GetAndDuplicateRecipeRequest: Codable {
    
    let authToken: String
    let recipeID: Int
    
    enum CodingKeys: String, CodingKey {
        case authToken
        case recipeID
    }
    
}


UpdateRecipeImageURLRequest.swift
//
//  UpdateRecipeImageURLRequest.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/7/24.
//

import Foundation

struct UpdateRecipeImageURLRequest: Codable {
    
    let authToken: String
    let recipeID: Int
    let imageURL: String
    
    enum CodingKeys: String, CodingKey {
        case authToken
        case recipeID
        case imageURL
    }
    
}


RegisterTransactionRequest.swift
//
//  RegisterTransactionRequest.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 6/16/23.
//

import Foundation

struct RegisterTransactionRequest: Codable {
    
    var authToken: String
    var transactionId: UInt64

    enum CodingKeys: String, CodingKey {
        case authToken
        case transactionId
        
    }
    
}


CategorizeIngredientsRequest.swift
//
//  CategorizeIngredientsRequest.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 7/8/23.
//

import Foundation

struct CategorizeIngredientsRequest: Codable {
    
    var authToken: String
    var ingredients: [String]
    
    enum CodingKeys: String, CodingKey {
        case authToken
        case ingredients
    }
    
}


TransactionHTTPSConnector.swift
//
//  TransactionHTTPSConnector.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 6/16/23.
//

import Foundation

class TransactionHTTPSConnector {
    
    static func registerTransaction(authToken: String, transactionID: UInt64) async throws -> IsPremiumResponse {
        let request = RegisterTransactionRequest(authToken: authToken, transactionId: transactionID)
        
        return try await registerTransaction(request: request)
    }
    
    static func registerTransaction(request: RegisterTransactionRequest) async throws -> IsPremiumResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.registerTransaction)")!,
            body: request,
            headers: nil)
        
        let isPremiumResponse = try JSONDecoder().decode(IsPremiumResponse.self, from: data)
        
        return isPremiumResponse
    }
    
}


ChefAppNetworkService.swift
//
//  ChefAppNetworkService.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/11/23.
//

import Foundation

class ChefAppNetworkService {
    
    static func addOrRemoveLikeOrDislike(request: AddOrRemoveLikeOrDislikeRequest) async throws {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.addOrRemoveLikeOrDislike)")!,
            body: request,
            headers: nil)
    }
    
    static func categorizeIngredients(request: CategorizeIngredientsRequest) async throws -> CategorizeIngredientsResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.categorizeIngredients)")!,
            body: request,
            headers: nil)
        
        do {
            let categorizeIngredientsResponse = try JSONDecoder().decode(CategorizeIngredientsResponse.self, from: data)
            
            return categorizeIngredientsResponse
        } catch {
            print("Error decoding categorizeIngredients response..")
            
            // Try to parse error response, and throw NetworkingError with corresponding value
            let errorResponse = try JSONDecoder().decode(ErrorResponse.self, from: data)
            
            print("Error Response from categorizeIngredients response:
\(errorResponse)")
            
            throw NetworkingError(rawValue: errorResponse.success) ?? NetworkingError.clientUnhandledError
        }
    }
    
    static func createRecipeIdea(request: CreateRecipeIdeaRequest) async throws -> CreateRecipeIdeaResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.createRecipeIdea)")!,
            body: request,
            headers: nil)
        
        do {
            let createRecipeIdeaResponse = try JSONDecoder().decode(CreateRecipeIdeaResponse.self, from: data)
            
            return createRecipeIdeaResponse
        } catch {
            print("Error decoding createRecipeIdea response..")
            
            // Try to parse error response, and throw NetworkingError with corresponding value
            let errorResponse = try JSONDecoder().decode(ErrorResponse.self, from: data)
            
            print("Error Response from createRecipeIdea response:
\(errorResponse)")
            
            throw NetworkingError(rawValue: errorResponse.success) ?? NetworkingError.clientUnhandledError
        }
    }
    
    static func getAllTags(request: AuthRequest) async throws -> GetAllTagsResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.getAllTags)")!,
            body: request,
            headers: nil)
        
        do {
            let getAllTagsResponse = try JSONDecoder().decode(GetAllTagsResponse.self, from: data)
            
            return getAllTagsResponse
        } catch {
            print("Error decoding getAllTags response..")
            
            // Try to parse error response, and throw NetworkingError with corresponding value
            let errorResponse = try JSONDecoder().decode(ErrorResponse.self, from: data)
            
            print("Error Response from getAllTags response:
\(errorResponse)")
            
            throw NetworkingError(rawValue: errorResponse.success) ?? NetworkingError.clientUnhandledError
        }
    }
    
    public static func getAndDuplicateRecipe(request: GetAndDuplicateRecipeRequest) async throws -> GetAndDuplicateRecipeResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.getAndDuplicateRecipe)")!,
            body: request,
            headers: nil)
        
        do {
            let getAndDuplicateRecipeResponse = try JSONDecoder().decode(GetAndDuplicateRecipeResponse.self, from: data)
            
            return getAndDuplicateRecipeResponse
        } catch {
            print("Error decoding getAndDuplicateRecipe response..")
            
            // Try to parse error response, and throw NetworkingError with corresponding value
            let errorResponse = try JSONDecoder().decode(ErrorResponse.self, from: data)
            
            print("Error Response from getAndDuplicateRecipe response:
\(errorResponse)")
            
            throw NetworkingError(rawValue: errorResponse.success) ?? NetworkingError.clientUnhandledError
        }
    }
    
    public static func getCreatePanels() async throws -> GetCreatePanelsResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.getCreatePanels)")!,
            body: BlankRequest(),
            headers: nil)
        
        do {
            let createPanelsResponse = try JSONDecoder().decode(GetCreatePanelsResponse.self, from: data)
            
            return createPanelsResponse
        } catch {
            print("Error decoding CreatePanelsResponse in getCreatePanels in BarbackNetworkService... \(error)")
            
            // Try to parse error response, and throw NetworkingError with corresponding value
            let errorResponse = try JSONDecoder().decode(ErrorResponse.self, from: data)
            
            print("Error Response from getAllTags response:
\(errorResponse)")
            
            throw NetworkingError(rawValue: errorResponse.success) ?? NetworkingError.clientUnhandledError
        }
    }
    
    static func getIAPStuff(completion: @escaping (GetIAPStuffResponse)->Void) {
        do {
            try NetworkClient.post(
                url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.getIAPStuff)")!,
                body: BlankRequest(),
                headers: nil,
                completion: {data, error in
                    if let error = error {
                        print("Error getting IAP stuff")
                        print(error.localizedDescription)
                    } else if let data = data {
                        do {
                            // Try decoding to GetIAPStuffResponse
                            let getIAPStuffResponse = try JSONDecoder().decode(GetIAPStuffResponse.self, from: data)

                            // Call completion block
                            completion(getIAPStuffResponse)
                        } catch {
                            print("Error decoding to GetIAPStuffResponse")
                            print(error.localizedDescription)
                        }
                    }
                }
            )
        } catch {
            print("Error making POST requet in getIAPStuff")
            print(error.localizedDescription)
        }
    }

    static func getImportantConstants() async throws -> GetImportantConstantsResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.getImportantConstants)")!,
            body: BlankRequest(),
            headers: nil)
        
        do {
            let getImportantConstantsResponse = try JSONDecoder().decode(GetImportantConstantsResponse.self, from: data)
            
            return getImportantConstantsResponse
        } catch {
            // Catch as StatusResponse
            let statusResponse = try JSONDecoder().decode(StatusResponse.self, from: data)
            
            // Regenerate AuthToken if necessary
            if statusResponse.success == 5 {
                Task {
                    do {
                        try await AuthHelper.regenerate()
                    } catch {
                        print("Error regenerating authToken in HTTPSConnector... \(error)")
                    }
                }
            }
            
            throw error
        }
    }
    
    static func getIsPremium(request: AuthRequest) async throws -> IsPremiumResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.getIsPremium)")!,
            body: request,
            headers: nil)

        let isPremiumResponse = try JSONDecoder().decode(IsPremiumResponse.self, from: data)

        return isPremiumResponse
    }
    
    static func getRemaining(request: AuthRequest) async throws -> GetRemainingResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.getRemaining)")!,
            body: request,
            headers: nil)

        let getRemainingResponse = try JSONDecoder().decode(GetRemainingResponse.self, from: data)

        return getRemainingResponse
    }

    // TODO: Legacy need to delete
    static func getRemaining(request: AuthRequest, completion: @escaping (GetRemainingResponse)->Void) {
        do {
            try NetworkClient.post(
                url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.getRemaining)")!,
                body: request,
                headers: nil,
                completion: {data, error in
                    if let error = error {
                        print("Error getting remaining")
                        print(error.localizedDescription)
                    } else if let data = data {
                        do {
                            // Try decoding to GetRemainingResponse
                            let getRemainingResponse = try JSONDecoder().decode(GetRemainingResponse.self, from: data)

                            // Call completion block
                            completion(getRemainingResponse)
                        } catch {
                            print("Error decoding to GetRemainingResponse")
                            print(error.localizedDescription)
                        }
                    }
                }
            )
        } catch {
            print("Error making POST request in getRemaining")
            print(error.localizedDescription)
        }
    }
    
    static func logPinterestConversion(request: LogPinterestConversionRequest) async throws -> LogPinterestConversionResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.logPinterestConversion)")!,
            body: request,
            headers: nil)
        
        do {
            let logPinterestConversionResponse = try JSONDecoder().decode(LogPinterestConversionResponse.self, from: data)
            
            return logPinterestConversionResponse
        } catch {
            print("Error decoding logPinterestConversionResponse response..")
            
            // Try to parse error response, and throw NetworkingError with corresponding value
            let errorResponse = try JSONDecoder().decode(ErrorResponse.self, from: data)
            
            print("Error Response from logPinterestConversion response:
\(errorResponse)")
            
            throw NetworkingError(rawValue: errorResponse.success) ?? NetworkingError.clientUnhandledError
        }
    }
    
    static func makeRecipeFromIdea(request: MakeRecipeFromIdeaRequest) async throws -> MakeRecipeFromIdeaResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.makeRecipeFromIdea)")!,
            body: request,
            headers: nil)
        
        do {
            let makeRecipeFromIdeaResponse = try JSONDecoder().decode(MakeRecipeFromIdeaResponse.self, from: data)
            
            return makeRecipeFromIdeaResponse
        } catch {
            print("Error decoding makeRecipeFromIdea response..")
            
            // Try to parse error response, and throw NetworkingError with corresponding value
            let errorResponse = try JSONDecoder().decode(ErrorResponse.self, from: data)
            
            print("Error Response from makeRecipeFromIdea response:
\(errorResponse)")
            
            throw NetworkingError(rawValue: errorResponse.success) ?? NetworkingError.clientUnhandledError
        }
    }
    
    static func parsePantryItems(request: ParsePantryItemsRequest) async throws -> ParsePantryItemsResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.parsePantryItems)")!,
            body: request,
            headers: nil)
        
        do {
            return try JSONDecoder().decode(ParsePantryItemsResponse.self, from: data)
        } catch {
            throw NetworkingError(rawValue: try JSONDecoder().decode(ErrorResponse.self, from: data).success) ?? .unknown
        }
    }
    
    static func regenerateRecipeDirectionsAndIdeaRecipeIngredients(request: RegenerateRecipeMeasuredIngredientsAndDirectionsAndIdeaRecipeIngredientsRequest) async throws -> RegenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.regenerateRecipeDirectionsAndIdeaRecipeIngredients)")!,
            body: request,
            headers: nil)
        
        do {
            let regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse = try JSONDecoder().decode(RegenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse.self, from: data)
            
            return regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse
        } catch {
            let errorResponse = try JSONDecoder().decode(ErrorResponse.self, from: data)
            
            throw NetworkingError(rawValue: errorResponse.success) ?? .unknown
        }
    }
    
    static func registerAPNS(request: APNSRegistrationRequest) async throws -> StatusResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.registerAPNS)")!,
            body: request,
            headers: nil)
        
        let statusResponse = try JSONDecoder().decode(StatusResponse.self, from: data)
        
        return statusResponse
    }
    
    static func registerUser() async throws -> RegisterUserResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.registerUser)")!,
            body: BlankRequest(),
            headers: nil)

        do {
            let registerUserResponse = try JSONDecoder().decode(RegisterUserResponse.self, from: data)

            return registerUserResponse
        } catch {
            let errorResponse = try JSONDecoder().decode(ErrorResponse.self, from: data)
            
            throw NetworkingError(rawValue: errorResponse.success) ?? .unknown
        }
    }
    
    // TODO: Legacy so need to delete
    static func registerUser(completion: @escaping (RegisterUserResponse)->Void) {
        do {
            try NetworkClient.post(
                url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.registerUser)")!,
                body: BlankRequest(),
                headers: nil,
                completion: {data, error in
                    if let error = error {
                        print("Error registering user")
                        print(error)
                    } else if let data = data {
                        do {
                            // Try decoding to RegisterUserResponse
                            let registerUserResponse = try JSONDecoder().decode(RegisterUserResponse.self, from: data)

                            // Call completion block
                            completion(registerUserResponse)
                        } catch {
                            print("Error decoding to RegisterUserResponse")
                            print(error.localizedDescription)
                        }
                    }
                }
            )
        } catch {
            print("Error making POST request in registerUser")
            print(error.localizedDescription)
        }
    }
    
    static func tagRecipeIdea(request: TagRecipeIdeaRequest) async throws -> TagRecipeIdeaResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.tagRecipeIdea)")!,
            body: request,
            headers: nil)
        
        do {
            let tagRecipeIdeaResponse = try JSONDecoder().decode(TagRecipeIdeaResponse.self, from: data)
            
            return tagRecipeIdeaResponse
        } catch {
            print("Error decoding tagRecipeIdea response..")
            
            // Try to parse error response, and throw NetworkingError with corresponding value
            let errorResponse = try JSONDecoder().decode(ErrorResponse.self, from: data)
            
            print("Error Response from tagRecipeIdea response:
\(errorResponse)")
            
            throw NetworkingError(rawValue: errorResponse.success) ?? NetworkingError.clientUnhandledError
        }
    }
    
    static func tikTokSearch(request: TikTokSearchRequest) async throws -> TikTokSearchResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.tikTokSearch)")!,
            body: request,
            headers: nil)
        
        do {
            let tikTokSearchResponse = try JSONDecoder().decode(TikTokSearchResponse.self, from: data)
            
            return tikTokSearchResponse
        } catch {
            print("Error decoding tikTokSearch response.. \(error)")
            
            // Try to parse error response, and throw NetworkingError with corresponding value
            let errorResponse = try JSONDecoder().decode(ErrorResponse.self, from: data)
            
            print("Error Response from tikTokSearch response:
\(errorResponse)")
            
            throw NetworkingError(rawValue: errorResponse.success) ?? NetworkingError.clientUnhandledError
        }
    }
    
    static func updateRecipeImageURL(request: UpdateRecipeImageURLRequest) async throws {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.updateRecipeImageURL)")!,
            body: request,
            headers: nil)
    }
    
    static func validateAuthToken(request: AuthRequest) async throws -> ValidateAuthTokenResponse {
        let (data, response) = try await NetworkClient.post(
            url: URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.validateAuthToken)")!,
            body: request,
            headers: nil)
        
        do {
            let validateAuthTokenResponse = try JSONDecoder().decode(ValidateAuthTokenResponse.self, from: data)
            
            return validateAuthTokenResponse
        } catch {
            print("Error decoding validateAuthToken response..")
            
            // Try to parse error response, and throw NetworkingError with corresponding value
            let errorResponse = try JSONDecoder().decode(ErrorResponse.self, from: data)
            
            print("Error Response from validateAuthToken response:
\(errorResponse)")
            
            throw NetworkingError(rawValue: errorResponse.success) ?? NetworkingError.clientUnhandledError
        }
    }
    
}


BingSearchResponse.swift
//
//  BingSearchResponse.swift
//  BingSearchPopup
//
//  Created by Alex Coundouriotis on 6/30/23.
//

import Foundation
import UIKit

struct BingSearchResponse: Decodable {
    
    struct Value: Decodable {
        
        var contentUrl: String?
        
    }
    
    var nextOffset: Int?
    var totalEstimatedMatches: Int?
    var value: [Value]
    
}


IAPHTTPSClient.swift
//
//  IAPHTTPSClient.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 6/30/23.
//

import Foundation

//protocol IAPHTTPSClientDelegate {
//    func didGetIAPStuffFromServer(json: [String: Any])
//}

class IAPHTTPSClient {
    
    static func getIAPStuffFromServer(authToken: String) async throws -> [String: Any]? {
        let url = URL(string: "\(Constants.HTTPSConstants.chitChatServer)\(Constants.HTTPSConstants.getIAPStuff)")!
        let postBody = """
        {
            "authToken": "\(authToken)"
        }
        """
        
        var request = URLRequest(url: url)
        
        request.httpMethod = "POST"
        request.httpBody = postBody.data(using: .utf8)
        
        let session = URLSession.shared
        let (data, response) = try await session.data(for: request)
        
        return try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any]
        
//        , completionHandler: { (data, response) in
//            if let error = error {
//                print("Error in GetIAPStuffFromServer")
//                print(error)
//            } else if let data = data {
//                DispatchQueue.main.async {
//                    do {
//                        let json = try JSONSerialization.jsonObject(with: data, options:[]) as? [String: Any]
//                        
//                        delegate.didGetIAPStuffFromServer(json: json!)
//                    } catch {
//                        print(error)
//                    }
//                }
//            }
//        })
//        
//        task.resume()
    }
    
}


ValidateAuthTokenResponse.swift
//
//  ValidateAuthTokenResponse.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 6/24/23.
//

import Foundation

struct ValidateAuthTokenResponse: Codable {
    
    struct Body: Codable {
        
        var isValid: Bool
        
        enum CodingKeys: String, CodingKey {
            case isValid
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


MakeRecipeFromIdeaResponse.swift
//
//  MakeRecipeResponse.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 6/23/23.
//

import Foundation

struct MakeRecipeFromIdeaResponse: Codable {
    
    struct Body: Codable {
        
        var directions: [Int: String]
        var allIngredientsAndMeasurements: [String]
        var estimatedTotalCalories: Int?
        var estimatedTotalMinutes: Int?
        var estimatedServings: Int?
        var feasibility: Int?
        
        enum CodingKeys: String, CodingKey {
            case directions = "instructions"
            case allIngredientsAndMeasurements
            case estimatedTotalCalories
            case estimatedTotalMinutes
            case estimatedServings
            case feasibility
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


LogPinterestConversionResponse.swift
//
//  LogPinterestConversionResponse.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/25/24.
//

import Foundation

struct LogPinterestConversionResponse: Codable {
    
    struct Body: Codable {
        
        var didLog: Bool
        
        enum CodingKeys: String, CodingKey {
            case didLog
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


GetImportantConstantsResponse.swift
//
//  GetImportantConstantsResponse.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 3/30/23.
//

import Foundation

struct GetImportantConstantsResponse: Codable {
    
    struct Body: Codable {
        
        var annualDisplayPrice: String?
        var bingAPIKey: String?
        var freeEssayCap: Int?
        var monthlyProductID: String?
        var shareURL: String?
        var weeklyProductID: String?
        
        // DEPRECATED
        var monthlyDisplayPrice: String?
        var weeklyDisplayPrice: String?
        
        enum CodingKeys: String, CodingKey {
            case annualDisplayPrice
            case bingAPIKey
            case freeEssayCap
            case monthlyProductID
            case shareURL
            case weeklyProductID
            
            // DEPRECATED
            case monthlyDisplayPrice
            case weeklyDisplayPrice
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


RegisterUserResponse.swift
//
//  RegisterUserResponse.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 3/29/23.
//

import Foundation

struct RegisterUserResponse: Codable {
    
    struct Body: Codable {
        
        var authToken: String
        
        enum CodingKeys: String, CodingKey {
            case authToken
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


IsPremiumResponse.swift
//
//  IsPremiumResponse.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 6/16/23.
//

import Foundation

struct IsPremiumResponse: Codable {
    
    struct Body: Codable {
        
        var isPremium: Bool
        
        enum CodingKeys: String, CodingKey {
            case isPremium
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


GetIAPStuffResponse.swift
//
//  GetIAPStuffResponse.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 3/30/23.
//

import Foundation

struct GetIAPStuffResponse: Codable {
    
    struct Body: Codable {
        
        var sharedSecret: String
        var productIDs: [String]
        
        enum CodingKeys: String, CodingKey {
            case sharedSecret
            case productIDs
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


GetRemainingResponse.swift
//
//  GetRemainingResponse.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 3/30/23.
//

import Foundation

struct GetRemainingResponse: Codable {
    
    struct Body: Codable {
        
        var remaining: Int
        
        enum CodingKeys: String, CodingKey {
            case remaining
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


CreateRecipeIdeaResponse.swift
//
//  CreateRecipeIdeaResponse.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 6/23/23.
//

import Foundation

struct CreateRecipeIdeaResponse: Codable {
    
    struct Body: Codable {
        
        var ingredients: [String]
//        var equipment: [String]
        var name: String
        var summary: String
        var cuisineType: String
        var recipeID: Int
        var remaining: Int?
        
        enum CodingKeys: String, CodingKey {
            case ingredients
//            case equipment
            case name
            case summary
            case cuisineType
            case recipeID
            case remaining
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


TagRecipeIdeaResponse.swift
//
//  TagRecipeIdeaResponse.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 7/6/23.
//

import Foundation

struct TagRecipeIdeaResponse: Codable {
    
    struct Body: Codable {
        
        var tags: [String]
        
        enum CodingKeys: String, CodingKey {
            case tags
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


StatusResponse.swift
//
//  StatusREsponse.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 8/9/23.
//

import Foundation

struct StatusResponse: Codable {
    
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case success = "Success"
    }
    
}


GetAllTagsResponse.swift
//
//  GetAllTagsResponse.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 7/7/23.
//

import Foundation

struct GetAllTagsResponse: Codable {
    
    struct Body: Codable {
        
        var tags: [String]
        
        enum CodingKeys: String, CodingKey {
            case tags
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


GetCreatePanelsResponse.swift
//
//  GetCreatePanelsResponse.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/17/24.
//

import Foundation

struct GetCreatePanelsResponse: Codable {
    
    struct Body: Codable {
        
        var createPanels: String
        
        enum CodingKeys: String, CodingKey {
            case createPanels
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}



GetAndDuplicateRecipeResponse.swift
//
//  GetAndDuplicateRecipeResponse.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/5/24.
//

import Foundation

struct GetAndDuplicateRecipeResponse: Codable {
    
    struct Body: Codable {
        
        struct Recipe: Codable {
            
            let recipeID: Int?
            let userID: Int?
            let input: String?
            let name: String?
            let summary: String?
            let cuisineType: String?
            let expandIngredientsMagnitude: Int?
            let estimatedTotalCalories: Int?
            let estimatedTotalMinutes: Int?
            let estimatedServings: Int?
            let feasibility: Int?
            let likesCount: Int?
            let dislikesCount: Int?
            let measuredIngredients: [String]?
            let instructions: [Int: String]?
            
            // CodingKeys to map Swift property names to JSON keys
            enum CodingKeys: String, CodingKey {
                case recipeID = "recipe_id"
                case userID = "user_id"
                case input
                case name
                case summary
                case cuisineType
                case expandIngredientsMagnitude
                case estimatedTotalCalories
                case estimatedTotalMinutes
                case estimatedServings
                case feasibility
                case likesCount
                case dislikesCount
                case measuredIngredients
                case instructions
            }
        }
        
        let recipe: Recipe
        
        enum CodingKeys: String, CodingKey {
            case recipe
        }
        
    }
    
    let body: Body
    let success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


ParsePantryItemsResponse.swift
//
//  ParsePantryItemsResponse.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/18/23.
//

import Foundation

struct ParsePantryItemsResponse: Codable {
    
    struct Body: Codable {
        
        struct PantryItem: Codable {
            
            var item: String?
            var category: String?
            
            enum CodingKeys: String, CodingKey {
                case item
                case category
            }
            
        }
        
        var pantryItems: [PantryItem]
        
        enum CodingKeys: String, CodingKey {
            case pantryItems
        }
        
    }
    
    var success: Int
    var body: Body
    
    enum CodingKeys: String, CodingKey {
        case success = "Success"
        case body = "Body"
    }
    
}


ErrorResponse.swift
//
//  ErrorResponse.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 6/24/23.
//

import Foundation

struct ErrorResponse: Codable {
    
    struct Body: Codable {
        
        var description: String?
        
        enum CodingKeys: String, CodingKey {
            case description
        }
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


REgenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse.swift
//
//  RegenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 7/19/23.
//

import Foundation

struct RegenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse: Codable {
    
    struct Body: Codable {
        
        var allIngredientsAndMeasurements: [String]
        var instructions: [Int: String]
        var estimatedServings: Int?
        var feasibility: Int?
        
        enum CodingKeys: String, CodingKey {
            case allIngredientsAndMeasurements
            case instructions
            case estimatedServings
            case feasibility
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


CategorizeIngredientsResponse.swift
//
//  CategorizeIngredientsResponse.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 7/8/23.
//

import Foundation

struct CategorizeIngredientsResponse: Codable {
    
    struct Body: Codable {
        
        struct IngredientCategory: Codable {
            
            var ingredient: String
            var category: String
            
            enum CodingKeys: String, CodingKey {
                case ingredient
                case category
            }
            
        }
        
        var ingredientCategories: [IngredientCategory]
        
        enum CodingKeys: String, CodingKey {
            case ingredientCategories
        }
        
    }
    
    var body: Body
    var success: Int
    
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case success = "Success"
    }
    
}


TikTokSearchResponse.swift
//
//  TikTokSearchResponse.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/2/24.
//

import Foundation

struct TikTokSearchResponse: Codable {
    
    // MARK: - Body
    struct Body: Codable {
        let apiResponse: APIResponse
        
        enum CodingKeys: String, CodingKey {
            case apiResponse
        }
    }
    
    // MARK: - APIResponse
    struct APIResponse: Codable {
        let other: Other
        let extra: Extra?
        let hasMore: Int?
        let itemList: [Item]
        
        enum CodingKeys: String, CodingKey {
            case other = "$other"
            case extra
            case hasMore = "has_more"
            case itemList = "item_list"
        }
    }
    
    // MARK: - Other
    struct Other: Codable {
        let videoLinkHeaders: VideoLinkHeaders
        
        enum CodingKeys: String, CodingKey {
            case videoLinkHeaders
        }
    }
    
    // MARK: - VideoLinkHeaders
    struct VideoLinkHeaders: Codable {
        let cookie: String?
        let origin: String?
        let referer: String?
        
        enum CodingKeys: String, CodingKey {
            case cookie = "Cookie"
            case origin = "Origin"
            case referer = "Referer"
        }
    }
    
    // MARK: - Extra
    struct Extra: Codable {
        let apiDebugInfo: String?
        let fatalItemIds: [String]?
        let logid: String?
        let now: Int?
        let searchRequestId: String?
        
        enum CodingKeys: String, CodingKey {
            case apiDebugInfo = "api_debug_info"
            case fatalItemIds = "fatal_item_ids"
            case logid
            case now
            case searchRequestId = "search_request_id"
        }
    }
    
    // MARK: - Item
    struct Item: Codable {
        let author: Author?
        let authorStats: AuthorStats?
        let challenges: [Challenge]?
        let collected: Bool?
        let createTime: Int?
        let desc: String?
        let digged: Bool?
        let duetEnabled: Bool?
        let duetInfo: DuetInfo?
        let forFriend: Bool?
        let id: String?
        let isAd: Bool?
        let itemCommentStatus: Int?
        let itemMute: Bool?
        let music: Music?
        let officalItem: Bool?
        let originalItem: Bool?
        let privateItem: Bool?
        let secret: Bool?
        let shareEnabled: Bool?
        let showNotPass: Bool?
        let stats: Stats?
        let stickersOnItem: [Sticker]?
        let stitchEnabled: Bool?
        let textExtra: [TextExtra]?
        let video: Video?
        let vl1: Bool?
        let anchors: [Anchor]?
        
        // If any keys don't match the property names, add CodingKeys here
    }
    
    // MARK: - Author
    struct Author: Codable {
        let avatarLarger: String?
        let avatarMedium: String?
        let avatarThumb: String?
        let commentSetting: Int?
        let downloadSetting: Int?
        let duetSetting: Int?
        let ftc: Bool?
        let id: String?
        let nickname: String?
        let openFavorite: Bool?
        let privateAccount: Bool?
        let relation: Int?
        let secUid: String?
        let secret: Bool?
        let signature: String?
        let stitchSetting: Int?
        let uniqueId: String?
        let verified: Bool?
        
        // Add CodingKeys if necessary
    }
    
    // MARK: - AuthorStats
    struct AuthorStats: Codable {
        let diggCount: Int?
        let followerCount: Int?
        let followingCount: Int?
        let heart: Int?
        let heartCount: Int?
        let videoCount: Int?
        
        // Add CodingKeys if necessary
    }
    
    // MARK: - Challenge
    struct Challenge: Codable {
        let coverLarger: String?
        let coverMedium: String?
        let coverThumb: String?
        let desc: String?
        let id: String?
        let isCommerce: Bool?
        let profileLarger: String?
        let profileMedium: String?
        let profileThumb: String?
        let title: String?
        
        // Add CodingKeys if necessary
    }
    
    // MARK: - DuetInfo
    struct DuetInfo: Codable {
        let duetFromId: String?
        
        enum CodingKeys: String, CodingKey {
            case duetFromId
        }
    }
    
    // MARK: - Music
    struct Music: Codable {
        let album: String?
        let authorName: String?
        let coverLarge: String?
        let coverMedium: String?
        let coverThumb: String?
        let duration: Int?
        let id: String?
        let original: Bool?
        let playUrl: String?
        let title: String?
        
        // Add CodingKeys if necessary
    }
    
    // MARK: - Stats
    struct Stats: Codable {
        let collectCount: Int?
        let commentCount: Int?
        let diggCount: Int?
        let playCount: Int?
        let shareCount: Int?
        
        // Add CodingKeys if necessary
    }
    
    // MARK: - Sticker
    struct Sticker: Codable {
        let stickerText: [String]?
        let stickerType: Int?
        
        // Add CodingKeys if necessary
    }
    
    // MARK: - TextExtra
    struct TextExtra: Codable {
        let awemeId: String?
        let end: Int?
        let hashtagId: String?
        let hashtagName: String?
        let isCommerce: Bool?
        let secUid: String?
        let start: Int?
        let subType: Int?
        let type: Int?
        let userId: String?
        let userUniqueId: String?
        
        // Add CodingKeys if necessary
    }
    
    // MARK: - Video
    struct Video: Codable {
        let bitrate: Int?
        let cover: String?
        let downloadAddr: String?
        let duration: Int?
        let dynamicCover: String?
        let encodeUserTag: String?
        let encodedType: String?
        let format: String?
        let height: Int?
        let id: String?
        let originCover: String?
        let playAddr: String?
        let ratio: String?
        let reflowCover: String?
        let shareCover: [String]?
        let videoQuality: String?
        let width: Int?
        
        // Add CodingKeys if necessary
    }
    
    // MARK: - Anchor
    struct Anchor: Codable {
        let description: String?
        let extraInfo: ExtraInfo?
        let icon: Icon?
        let id: String?
        let keyword: String?
        let logExtra: String?
        let schema: String?
        let thumbnail: Thumbnail?
        let type: Int?
    }
    
    // MARK: - ExtraInfo
    struct ExtraInfo: Codable {
        let subtype: String?
    }
    
    // MARK: - Icon
    struct Icon: Codable {
        let urlList: [String]?
    }
    
    // MARK: - Thumbnail
    struct Thumbnail: Codable {
        let height: Int?
        let urlList: [String]?
        let width: Int?
    }
    
    let body: Body
    let success: Int
    
    enum CodingKeys: String, CodingKey {
        case success = "Success"
        case body = "Body"
    }
    
}


BingSearchClient.swift
//
//  BingSearchClient.swift
//  BingSearchPopup
//
//  Created by Alex Coundouriotis on 6/30/23.
//

import Foundation
import UIKit

class BingSearchClient {
    
    static let BASE_URL = "https://api.bing.microsoft.com/v7.0/images/search"
    
    static let COMPONENT_QUERY = "q"
    static let COMPONENT_COUNT = "count"
    static let COMPONENT_OFFSET = "offset"
    static let COMPONENT_SAFE_SEARCH = "safeSearch"
    static let COMPONENT_MIN_HEIGHT = "minHeight"
    static let COMPONENT_MIN_WIDTH = "minWidth"
    
    static let DEFAULT_SAFE_SEARCH: String = "Strict"
    static let DEFAULT_MIN_HEIGHT: String = "32"
    static let DEFAULT_MIN_WIDTH: String = "32"
    
    static let HEADER_API_KEY: String = "Ocp-Apim-Subscription-Key"
    
    static var HEADER_API_VALUE: String {
        Keys.BING_API_KEY ?? ""
    }
    
    static func getImages(query: String, count: Int, offset: Int) async throws -> (imageURLs: [URL], totalEstimatedMatches: Int?) {
        // Build URL
        var urlComponents = URLComponents(string: "\(BASE_URL)")!
        urlComponents.queryItems = [
            URLQueryItem(name: COMPONENT_QUERY, value: query),
            URLQueryItem(name: COMPONENT_COUNT, value: String(count)),
            URLQueryItem(name: COMPONENT_OFFSET, value: String(offset)),
            URLQueryItem(name: COMPONENT_SAFE_SEARCH, value: DEFAULT_SAFE_SEARCH),
            URLQueryItem(name: COMPONENT_MIN_HEIGHT, value: DEFAULT_MIN_HEIGHT),
            URLQueryItem(name: COMPONENT_MIN_WIDTH, value: DEFAULT_MIN_WIDTH)
        ]
        
        // Build request with API key
        var request = URLRequest(url: urlComponents.url!)
        request.addValue(HEADER_API_VALUE, forHTTPHeaderField: HEADER_API_KEY)
        
        // Do request
        let (data, response) = try await URLSession.shared.data(for: request)
        
        // Parse JSON
        let bingSearchReponse = try JSONDecoder().decode(BingSearchResponse.self, from: data)
        
        // Return UIImage array from getImagesFromBingSearchResponse
        return (imageURLs: try await getImagesFromBingSearchResponse(bingSearchReponse), totalEstimatedMatches: bingSearchReponse.totalEstimatedMatches)
    }
    
    private static func getImagesFromBingSearchResponse(_ response: BingSearchResponse) async throws -> [URL] {
        response.value.compactMap({
            if let contentURLString = $0.contentUrl,
               let contentURL = URL(string: contentURLString) {
                return contentURL
            }
            return nil
        })
//        // Create UIImage array
//        var images: [UIImage] = []
//        
//        // Get image from contentURL in each value
//        for value in response.value {
//            if let contentUrl = value.contentUrl {
//                // Create url request with value contentUrl
//                let url = URL(string: contentUrl)
//                let urlRequest = URLRequest(url: url!)
//                
//                do {
//                    // Do request
//                    let (data, response) = try await URLSession.shared.data(for: urlRequest)
//                    
//                    // Try to parse data into image and if successful, add to image array
//                    if let image = UIImage(data: data) {
//                        images.append(image)
//                    }
//                } catch {
//                    print("Error getting response when getting images from Bing search response: \(error)")
//                }
//            }
//        }
//        
//        return images
    }
    
}


Constants.swift
//
//  Constants.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/17/23.
//

import Foundation
import SwiftUI

struct Constants {
    
    struct Additional {
        
        static let appGroupID: String = "group.com.acapplications.chefsuite"
        
        static let copyFooterText: String = "Made with ChefApp!"
        
        static let coreDataModelName = "PantryPal"
        
        static let defaultShareURL = "https://apps.apple.com/us/app/chefapp-ai-recipe-creator/id6450523267"
        
        static let defaultTitleText = "Tap to Claim 3 Days Free"
        static let defaultTopLabelText = "ChefApp Ultra hasn't been activated"
        
        static let fallbackWeeklyProductIdentifier = "pantryproultraweekly" // TODO: Get the right one
        static let fallbackMonthlyProductIdentifier = "pantryproultramonthly" // TODO: Get the right one
        
        static let ideaRecipeInterstitialModuloFactor = 2
        
        static let pinterestCheckoutEventName = "checkout"
        static let pinterestCheckoutEventID = "checkout001"
        
        static let reviewFrequency = 2
        
        static let shareIdeaRecipeSuffix = "Made on ChefApp"
        
        private static let supportEmail = "pantryproapp@gmail.com"
        static let supportEmailURL = "mailto:\(supportEmail)"
        
    }
    
    struct File {
        
        static let panelImageDirectory = "panelImages"
        
    }
    
    struct FontName {
        
        private static let oblique = "Oblique"
        
        static let light = "avenir-light"
        static let lightOblique = light + oblique
        static let body = "avenir-book"
        static let bodyOblique = body + oblique
        static let medium = "avenir-medium"
        static let mediumOblique = medium + oblique
        static let heavy = "avenir-heavy"
        static let heavyOblique = heavy + oblique
        static let black = "avenir-black"
        static let blackOblique = black + oblique
        static let appname = "copperplate"
        
        static let damion = "Damion"
        
    }
    
    struct ImageName {
        
        static let cameraButtonNotPressed = "cameraButtonNotPressed"
        static let cameraButtonPressed = "cameraButtonPressed"
        static let cameraButtonPressedCheckmark = "cameraButtonPressedCheckmark"
        static let blurryOverlay = "Blurry Overlay"
        static let navBarLogoImage = "NavBarLogoImage"
        static let sparkleWhiteGif = "sparkleWhiteGif"
        static let ultraButtonImage = "UltraButtonImage"
        static let ultraTitle = "UltraTitle"
        
        
    }
    
    struct Generation {
        
        static let freeAutomaticRecipeGenerationLimit = 2
        static let premiumAutomaticRecipeGenerationLimit = 4
        
    }
    
    struct HTTPSConstants {
        #if DEBUG
            static let chitChatServer = "https://chitchatserver.com:800/v1"
        #else
            static let chitChatServer = "https://chitchatserver.com:800/v1"
        #endif
        
        static let chitChatServerStaticFiles = "https://chitchatserver.com"
        
        static let addOrRemoveLikeOrDislike = "/addOrRemoveLikeOrDislike"
        static let categorizeIngredients = "/categorizeIngredients"
        static let createRecipeIdea = "/createRecipeIdea"
        static let getAllTags = "/getAllTags"
        static let getAndDuplicateRecipe = "/getAndDuplicateRecipe"
        static let getCreatePanels = "/getCreatePanels"
        static let getIAPStuff = "/getIAPStuff"
        static let getIsPremium = "/getIsPremium"
        static let getRecipe = "/getRecipe"
        static let getRemaining = "/getRemaining"
        static let logPinterestConversion = "/logPinterestConversion"
        static let makeRecipeFromIdea = "/makeRecipeFromIdea"
        static let parsePantryItems = "/parsePantryItems"
        static let regenerateRecipeDirectionsAndIdeaRecipeIngredients = "/regenerateRecipeDirectionsAndUpdateMeasuredIngredients"
        static let registerAPNS = "/registerAPNS"
        static let registerTransaction = "/registerTransaction"
        static let registerUser = "/registerUser"
        static let tagRecipeIdea = "/tagRecipeIdea"
        static let tikTokSearch = "/tikTokSearch"
        static let updateRecipeImageURL = "/updateRecipeImageURL"
        static let validateAuthToken = "/validateAuthToken"
    //    static let getGenerateImage = "/getImageUrlFromGenerateUrl"

        static let getImportantConstants = "/getImportantConstants"
        static let privacyPolicy = "/privacyPolicy.html"
        static let termsAndConditions = "/termsAndConditions.html"
    }
    
    struct Images {
        static let giftGifName = "giftGif"
        static let ideaRecipeNoImageName = "IdeaRecipeNoImage"
        static let intro1DarkPhoto = "Intro 1 Dark"
        static let intro1LightPhoto = "Intro 1 Light"
        static let navBarLogoImageName = "NavBarLogoImage"
        static let recipeNoImage = "RecipeNoImage"
        static let sheetArrowUpImageName = "SheetArrowUp"
        static let sparkleLightGif = "SparkleLightGif"
        static let sparkleDarkGif = "SparkleDarkGif"
        static let ultraTitle = "UltraTitle"
    }
    
    struct UI {
        static let borderWidth = CGFloat(0.0)
        static let cornerRadius = 14.0
    }
    
    struct UserDefaults {
        struct Tutorial {
            static let sheetShown = "tutorialSheetShown"
        }
        
        static let captureCropViewEnabled = "captureCropViewEnabled"
        static let createPanelsJSON = "createPanelsJSON"
        static let hasFinishedIntro = "hasFinishedIntro"
        static let pinterestConversionLoggedOnce = "pinterestConversionLoggedOnce"
        
        static let storedAuthTokenKey = "storedAuthTokenKey"
        static let storedEncodedBingAPIKey = "encodedBingAPIKey"
        static let storedCategorizeIngredientsCount = "categorizeIngredientsCount"
        static let storedFreeIdeaRecipeCap = "freeIdeaRecipeCap"
        static let storedHasFinishedIntro = "hasFinishedIntro"
        static let storedIsPremium = "storedIsPremium"
        static let storedMonthlyProductID = "monthlyProductID"
        static let storedNotFirstLaunchEver = "notFirstLaunchEver"
        static let storedPremiumLastCheckDate = "premiumLastCheckDate"
        static let storedRecipeDirectionsAndIdeaRecipeIngredientsRegenerationsCount = "recipeDirectionsAndIdeaRecipeIngredientsRegenerationsCount"
        static let storedRecipesRemaining = "recipesRemaining"
        static let storedShareURL = "shareURL"
        static let storedWeeklyProductID = "weeklyProductID"
    }
    
    struct Videos {
        static let intro2DarkVideo = ("Intro 2 Dark", "mp4")
        static let intro2LightVideo = ("Intro 2 Light", "mp4")
    }
    
}

struct Colors {
    static let background = Color("BackgroundColor")
    static let bottomBarBackground = Color("BottomBarBackgroundColor")
    static let elementBackground = Color("ElementBackgroundColor")
    static let elementText = Color("ElementTextColor")
    static let foreground = Color("ForegroundColor")
    static let foregroundText = Color("ForegroundTextColor")
    static let ingredientRow = Color("IngredientRowColor")
    static let ingredientToBeDeletedRow = Color("IngredientToBeDeletedRowColor")
    static let navigationItemColor = Color("NavigationItemColor")
    static let secondaryBackground = Color("SecondaryBackgroundColor")
    static let topForegroundPlaceholderText = Color("TopForegroundPlaceholderTextColor")
    static let videoMatchedColor = Color("VideoMatchedColor")
    
    static let alertTint = secondaryBackground
}


Keys.swift
//
//  Keys.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 7/1/23.
//

import CryptoSwift
import Foundation

struct Keys {
    
    struct AppsFlyer {
        static let appKey = "6450523267"
        static let devKey = "Vdj9XCjeq7Wpfd5Q2cXCUD"
    }
    
//    static let BING_API_KEY = "c21de9fac5414f699197f2106697959d"
    private static let BING_API_KEY_SALT = "zotjloljgibfkmeqohtwcrirfoxpdsds"
    static var BING_API_KEY: String? {
        get {
            guard let encodedBingAPIKey = ConstantsUpdater.encodedBingAPIKey, let data = Data(base64Encoded: encodedBingAPIKey) else {
                return nil
            }
            
            let cipheredBytes: Array<UInt8> = Array(data)
            
            do {
                let aes = try AES(key: Array(BING_API_KEY_SALT.utf8), blockMode: ECB())
                let decryptedBytes = try aes.decrypt(cipheredBytes)
                
                guard let decrypted = String(bytes: decryptedBytes, encoding: .utf8) else {
                    return nil
                }
                
                return decrypted
            } catch {
                print("Error decrypting bing API key... \(error)")
                
                return nil
            }
        }
    }
    
    struct GAD {
        
        struct Interstitial {
            
            static let mainContainerGenerate = "ca-app-pub-7814704845493911/5553401588"
            static let panelViewGenerate = "ca-app-pub-7814704845493911/7702521389"
            
        }
        
        static let ADMOB_APP_ID = "ca-app-pub-7814704845493911~8496952710" // This also needs to be changed in info.plist
        
        static let BANNER_AD_MAIN_UNIT_ID = "ca-app-pub-7814704845493911/2222354250"
        static let INTERSTITIAL_AD_MAIN_UNIT_ID = "ca-app-pub-7814704845493911/6267989595"
    }
    
}


SuggestionsModel.swift
//
//  SuggestionsModel.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/15/23.
//

import Foundation

struct SuggestionsModel {
    
    static let topSuggestions: [String] = [
        "Healthy",
        "Quick & Easy",
        "Vegetarian",
        "Kid-Friendly",
        "Comfort Food",
        "Budget-Friendly",
        "High Protein",
        "Low Carb",
        "Gluten-Free",
        "Meal Prep",
        "Family Size",
        "Vegan",
        "Low Calorie",
        "Paleo",
        "Keto",
        "Date-Night",
        "Holiday",
        "BBQ",
        "Seasonal",
        "Spring",
        "Summer",
        "Autumn",
        "Winter",
        "International",
        "Traditional"
    ]
    
    static let bottomSuggestions: [String] = [
        "Make a creative dip",
        "Turn this into a casserole",
        "Use minimal ingredients",
        "Make it interesting for guests",
        "Create a gourmet dish",
        "Bring festive flavors",
        "Celebrate with food",
        "Add seasonal spices and tastes",
        "Create a unique salad",
        "Try a new cuisine",
        "High-protein recipes",
        "Under 30 minutes",
        "Meal on a budget",
        "Healthy snacks"
    ]
    
}


SharedData.swift
//
//  SharedData.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 9/13/24.
//

import Foundation

struct SharedData: Codable {
    
    var url: String?
    var text: String?
    var imageAppGroupFilepath: String?
    var voiceAppGroupFilepath: String?
    var pdfAppGroupFilepath: String?
    // Add other properties as needed
    
}


PantryItemCDClient.swift
//
//  PantryItemCDClient.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/18/23.
//

import CoreData
import Foundation

class PantryItemCDClient {
    
    static let pantryItemEntityName = String(describing: PantryItem.self)
    
    static func appendPantryItem(name: String, category: String?, in managedContext: NSManagedObjectContext) async throws {
        let fetchRequest = PantryItem.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: "%K = %@", #keyPath(PantryItem.name), name)
        guard try await CDClient.count(fetchRequest: fetchRequest, in: managedContext) == 0 else {
            // TODO: Handle errors for duplication!
            print("Duplicate found and not saved in appendPantryItem!")
            throw PersistenceError.duplicateObject
        }
        
        // Build and save new pantry item
        try await managedContext.perform {
            let pantryItem = PantryItem(context: managedContext)
            
            pantryItem.name = name
            pantryItem.category = category
            pantryItem.updateDate = Date()
            
            try managedContext.save()
        }
    }
    
    static func deletePantryItem(_ pantryItem: PantryItem, in managedContext: NSManagedObjectContext) async throws {
        try await CDClient.delete(pantryItem, in: managedContext)
    }
    
    static func updateAll(newPantryItems: [(name: String, category: String)], in managedContext: NSManagedObjectContext) async throws {
//        // Delete all pantry items
//        let fetchRequest = PantryItem.fetchRequest()
//        try await CDClient.delete(fetchRequest: fetchRequest, in: managedContext)
        
        // Get all pantry items
        let fetchRequest = PantryItem.fetchRequest()
        let pantryItems = try await managedContext.perform {
            try managedContext.fetch(fetchRequest)
        }
        
        // Attemt to match pantry items by name case insensitive
        for pantryItem in pantryItems {
            if let matchedNewPantryItem = newPantryItems.first(where: {$0.name == pantryItem.name}) {
                // For the matched items, update their category
                do {
                    try await PantryItemCDClient.updatePantryItem(pantryItem, category: matchedNewPantryItem.category, in: managedContext)
                } catch {
                    // TODO: Handle Errors
                    print("Error updating pantry item in PantryItemCDClient, continuing... \(error)")
                    continue
                }
            } else {
                // For the unmatched pantry items in the store originally, do nothing
                print("\(pantryItem.name ?? "Pantry Item") - Pantry item in store not matched to new pantry item when re-sorting, continuing...")
            }
        }
        
        // For the unmatched newPantryItems, add them
        let unmatchedNewPantryItems = newPantryItems.filter { newPantryItem in
            !pantryItems.contains(where: {$0.name == newPantryItem.name})
        }
        for unmatchedNewPantryItem in unmatchedNewPantryItems {
            do {
                print("\(unmatchedNewPantryItem.name) - Adding unmatched pantry item from newPantryItems")
                try await PantryItemCDClient.appendPantryItem(
                    name: unmatchedNewPantryItem.name,
                    category: unmatchedNewPantryItem.category,
                    in: managedContext)
            } catch {
                // TODO: Handle Errors
                print("Error appending pantry item in PantryItemCDClient, continuing... \(error)")
            }
        }
        
        
//        // Save all new pantry items
//        // Build and save new pantry item
//        try await managedContext.perform {
//            for newPantryItem in newPantryItems {
//                let pantryItem = PantryItem(context: managedContext)
//                
//                pantryItem.name = newPantryItem.name
//                pantryItem.category = newPantryItem.category
////                pantryItem.updateDate = Date()
//            }
//            
//            try managedContext.save()
//        }
    }
    
    static func updatePantryItem(_ pantryItem: PantryItem, name: String, in managedContext: NSManagedObjectContext) async throws {
        try await update(pantryItem, updater: {$0.name = name}, in: managedContext)
    }
    
    static func updatePantryItem(_ pantryItem: PantryItem, category: String?, in managedContext: NSManagedObjectContext) async throws {
        try await update(pantryItem, updater: {$0.category = category}, in: managedContext)
    }
    
    static func updatePantryItem(_ pantryItem: PantryItem, updateDate: Date, in managedContext: NSManagedObjectContext) async throws {
        try await update(pantryItem, setUpdateDate: false, updater: {$0.updateDate = updateDate}, in: managedContext)
    }
    
    
    private static func update(_ pantryItem: PantryItem, setUpdateDate: Bool = true, updater: @escaping ((PantryItem)->Void), in managedContext: NSManagedObjectContext) async throws {
        try await managedContext.perform {
            if setUpdateDate {
                pantryItem.updateDate = Date()
            }
            
            updater(pantryItem)
            
            try managedContext.save()
        }
    }
    
}


RecipeMeasuredIngredientCDClient.swift
//
//  RecipeMeasuredIngredientCDClient.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/18/24.
//

import CoreData
import Foundation

class RecipeMeasuredIngredientCDClient {
    
    /***
     Append  Measured Ingredient
     
     Appends and saves a measured ingredient for a recipe
     */
    
    static func appendMeasuredIngredient(ingredientAndMeasurement: String, to recipe: Recipe, in managedContext: NSManagedObjectContext) async throws {
        try await managedContext.perform {
            let recipeMeasuredIngredient = RecipeMeasuredIngredient(context: managedContext)
            
            recipeMeasuredIngredient.nameAndAmount = ingredientAndMeasurement
//            recipeMeasuredIngredient.nameAndAmountModified = ingredientAndMeasurement // TODO: Should I be setting this here?
            recipeMeasuredIngredient.recipe = recipe
            
            try managedContext.save()
        }
    }
    
    static func appendMeasuredIngredients(ingredientsAndMeasurements: [String], to recipe: Recipe, in managedContext: NSManagedObjectContext) async throws {
        try await managedContext.perform {
            for ingredientAndMeasurement in ingredientsAndMeasurements {
                let recipeMeasuredIngredient = RecipeMeasuredIngredient(context: managedContext)
                
                recipeMeasuredIngredient.nameAndAmount = ingredientAndMeasurement
//                recipeMeasuredIngredient.nameAndAmountModified = ingredientAndMeasurement // TODO: Should I be setting this here?
                recipeMeasuredIngredient.recipe = recipe
            }
            
            try managedContext.save()
        }
    }
    
    /***
     Count Recipe Measured Ingredients
     
     Counts all measured ingredients for a recipe
     */
    
    static func count(for recipe: Recipe, in managedContext: NSManagedObjectContext) async throws -> Int? {
        await managedContext.perform {
            recipe.measuredIngredients?.count ?? 0
        }
    }
    
    /***
     Delete All Maesured Ingredients
     
     Deletes all measured ingredients for a recipe
     */
    
    static func deleteAllMeasuredIngredients(for recipe: Recipe, in managedContext: NSManagedObjectContext) async throws {
        let fetchRequest = RecipeMeasuredIngredient.fetchRequest()
        
        fetchRequest.predicate = NSPredicate(format: "%K = %@", #keyPath(RecipeMeasuredIngredient.recipe), recipe)
        
        try await CDClient.delete(fetchRequest: fetchRequest, in: managedContext)
    }
    
    /***
     Delete Measured Ingredients Marked For Deletion
     
     Deletes all measured ingredients marked for deletion
     */
    static func deleteMeasuredIngredientsMarkedForDeletion(for recipe: Recipe, in managedContext: NSManagedObjectContext) async throws {
        let fetchRequest = RecipeMeasuredIngredient.fetchRequest()
        
        fetchRequest.predicate = NSPredicate(format: "%K = %@ AND %K = %d", #keyPath(RecipeMeasuredIngredient.recipe), recipe, #keyPath(RecipeMeasuredIngredient.markedForDeletion), true)
        
        try await CDClient.delete(fetchRequest: fetchRequest, in: managedContext)
    }
    
    /***
     Resolve Measured Ingredients
     
     Sets all ingredients with nameAndAmountModified not nil or empty nameAndAmount to nameAndAmountModified and nameAndAmountModified to nil
     */
    
    static func resolveMeasuredIngredients(for recipe: Recipe, in managedContext: NSManagedObjectContext) async throws {
        try await managedContext.perform {
            let fetchRequest = RecipeMeasuredIngredient.fetchRequest()
            
            fetchRequest.predicate = NSPredicate(format: "%K = %@", #keyPath(RecipeMeasuredIngredient.recipe), recipe)
            
            for result in try managedContext.fetch(fetchRequest) {
                if result.nameAndAmountModified != nil && !result.nameAndAmountModified!.isEmpty {
                    result.nameAndAmount = result.nameAndAmountModified!
                    result.nameAndAmountModified = nil
                }
            }
            
            try managedContext.save()
        }
    }
    
}


BarbackNetworkPersistenceManager.swift
////
////  BarbackNetworkPersistanceManager.swift
////  Barback
////
////  Created by Alex Coundouriotis on 9/17/23.
////
//
//import CoreData
//import Foundation
//
//class BarbackNetworkPersistenceManager {
//    
//    public static func createSaveDrink(authToken: String, input: String, expandIngredientsMagnitude: Int, useAllGivenIngredients: Bool) async throws -> Int64 {
//        // Build cdRequest and get cdResponse from BarbackNetworkService
//        let cdRequest = CreateDrinkRequest(
//            authToken: authToken,
//            input: input,
//            expandIngredientsMagnitude: expandIngredientsMagnitude,
//            useAllGivenIngredients: useAllGivenIngredients)
//        
//        let cdResponse = try await BarbackNetworkService.createDrink(request: cdRequest)
//        
//        // Append drink
//        try await DrinkCDClient.appendDrink(
//            drinkID: cdResponse.body.drinkID,
//            input: cdResponse.body.input,
//            name: cdResponse.body.name,
//            summary: cdResponse.body.summary,
//            feasibility: cdResponse.body.feasibility,
//            tastiness: cdResponse.body.tastiness)
//        
//        // Get permanent object ID for drinkID
//        let drinkObjectID = try await DrinkCDClient.getDrinkPermanentID(drinkID: cdResponse.body.drinkID)
//        
//        // Append drink ingredients
//        for ingredient in cdResponse.body.ingredients {
//            try await DrinkCDClient.appendMeasuredIngredient(
//                to: drinkObjectID,
//                ingredient: ingredient,
//                measurement: nil)
//        }
//        
//        return cdResponse.body.drinkID
//    }
//    
//    public static func finalizeSaveDrink(authToken: String, drinkID: Int64) async throws {
//        // Build fdRequest and get fdResponse from BarbackNetworkService
//        let fdRequest = FinalizeDrinkRequest(
//            authToken: authToken,
//            drinkID: drinkID)
//
//        let fcResponse = try await BarbackNetworkService.finalizeDrink(request: fdRequest)
//        
//        // Get permanent drinkObjectID for drink with drinkID
//        let drinkObjectID = try await DrinkCDClient.getDrinkPermanentID(drinkID: drinkID)
//        
//        // Update estimatedServings, feasibility, and tastiness if each can be unwrapped
//        if let estimatedServings = fcResponse.body.estimatedServings, let estimatedServings = Int16(exactly: estimatedServings) {
//            try await DrinkCDClient.updateDrink(drinkObjectID, estimatedServings: estimatedServings)
//        }
//        if let feasibility = fcResponse.body.feasibility, let feasibility = Int16(exactly: feasibility) {
//            try await DrinkCDClient.updateDrink(drinkObjectID, feasibility: feasibility)
//        }
//        if let tastiness = fcResponse.body.tastiness, let tastiness = Int16(exactly: tastiness) {
//            try await DrinkCDClient.updateDrink(drinkObjectID, tastiness: tastiness)
//        }
//        
//        // Delete all measured ingredients and directions and append new ones
//        try await DrinkCDClient.deleteAllMeasuredIngredients(in: drinkObjectID)
//        try await DrinkCDClient.deleteAllDirections(in: drinkObjectID)
//        
//        for ingredientAndMeasurement in fcResponse.body.ingredientsAndMeasurements {
//            try await DrinkCDClient.appendMeasuredIngredient(to: drinkObjectID, ingredient: ingredientAndMeasurement.ingredient, measurement: ingredientAndMeasurement.measurement)
//        }
//        
//        for direction in fcResponse.body.directions {
//            if let index = Int16(exactly: direction.key) {
//                try await DrinkCDClient.appendDirection(to: drinkObjectID, index: index, text: direction.value)
//            } else {
//                // TODO: Handle error here
//                print("Could not convert direction index to Int16 in finalizeSaveDrink in BarbackNetworkPersistenceManager!")
//            }
//        }
//    }
//    
//    public static func getSaveCreatePanels() async throws {
//        let gcpResponse = try await BarbackNetworkService.getCreatePanels()
//        
//        CreatePanelsJSONPersistenceManager.set(gcpResponse.body.createPanels)
//    }
//    
//    public static func getSaveDrinkIngredientsPreview(authToken: String, drinkID: Int, to drinkObjectID: NSManagedObjectID) async throws {
//        // Ensure there are no ingredients stored already, otherwise return
//        guard try await DrinkCDClient.countBy(drinkObjectID: drinkObjectID) == 0 else {
//            // TODO: Handle errors
//            return
//        }
//        
//        // Build dRequest and get gdipResponse from BarbackNetworkService
//        let dRequest = DrinkIDRequest(
//            authToken: authToken,
//            drinkID: drinkID)
//        
//        let gdipRequest = try await BarbackNetworkService.getDrinkIngredientsPreview(request: dRequest)
//        
//        // Add all ingredients to drink ingredients
//        for ingredient in gdipRequest.body.ingredients {
//            try await DrinkCDClient.appendMeasuredIngredient(
//                to: drinkObjectID,
//                ingredient: ingredient,
//                measurement: nil)
//        }
//        
//    }
//    
//    public static func getSaveGlassColor(authToken: String, drinkID: Int, to drinkObjectID: NSManagedObjectID) async throws {
//        // Build dRequest and get ggcResponse from BarbackNetworkSerice
//        let dRequest = DrinkIDRequest(
//            authToken: authToken,
//            drinkID: drinkID)
//        
//        let ggcResponse = try await BarbackNetworkService.getGlassColor(request: dRequest)
//        
//        // Delete all glass gradient colors for drinkObjectID
//        try await DrinkCDClient.deleteAllGlassGradientColors(in: drinkObjectID)
//        
//        // Append each glass gradient color to drink with drinkObjectID
//        for i in 0..<ggcResponse.body.gradient.count {
//            if let iInt16 = Int16(exactly: i) {
//                try await DrinkCDClient.appendGlassGradientColor(to: drinkObjectID, index: iInt16, hexadecimal: ggcResponse.body.gradient[i])
//            } else {
//                // TODO: Handle errors
//                print("Could not cast index to Int16.. this should never happen!")
//            }
//        }
//    }
//    
//    public static func getSaveGlass(authToken: String, drinkID: Int, to drinkObjectID: NSManagedObjectID) async throws {
//        // Build ggRequest and get ggResponse from BarbackNetworkSerice
//        let dRequest = DrinkIDRequest(
//            authToken: authToken,
//            drinkID: drinkID)
//        
//        let ggResponse = try await BarbackNetworkService.getGlass(request: dRequest)
//        
//        // Save glass to drink with drinkObjectID
//        try await DrinkCDClient.updateDrink(drinkObjectID, glassImageData: ggResponse.body.imageData)
//    }
//    
//    public static func parseSaveBarItems(authToken: String, input: String) async throws {
//        // Build pbiRequest and get pbiResponse from BarbackNetworkService
//        let pbiRequest = ParsePantryItemsRequest(
//            authToken: authToken,
//            input: input)
//        
//        let pbiResponse = try await BarbackNetworkService.parseBarItems(request: pbiRequest)
//        
//        // Create duplicate bar item names array which will throw a duplicateBarItemNames BarItemPersistenceError with any duplicates so the user can be notified.. TODO: Is this a good implementation?
//        var duplicateBarItemNames: [String] = []
//        
//        // Save all bar items, capitalized, if item can be unwrapped, setting isAlcohol to false if nil
//        for barItem in pbiResponse.body.barItems {
//            if let item = barItem.item {
//                do {
//                    try await BarItemCDClient.appendBarItem(
//                        item: item.capitalized,
//                        brandName: barItem.brandName?.capitalized,
//                        alcoholType: barItem.alcoholType?.capitalized,
//                        isAlcohol: barItem.isAlcohol ?? false)
//                } catch PersistenceError.duplicateObject {
//                    // TODO: Handle errors if necessary, but this is so that the function doesn't fall through
//                    print("Removed duplicate object when parsing saving bar items in BarbackNetworkPersistenceManager!")
//                    duplicateBarItemNames.append(item)
//                }
//            }
//        }
//        
//        // Throw duplicate error if will throw dupilcate error is true
//        if !duplicateBarItemNames.isEmpty {
//            throw BarItemPersistenceError.duplicateBarItemNames(duplicateBarItemNames)
//        }
//    }
//    
//    public static func regenerateSaveDrinkDirections(authToken: String, drinkID: Int64, newInput: String? = nil, newName: String? = nil, newSummary: String? = nil, newIngredientsAndMeasurements: [(measurement: String?, ingredient: String)]? = nil) async throws {
//        // Build rddRequest and get rddResponse from BarbackNetworkService
//        let rddRequest = RegenerateDrinkDirectionsRequest(
//            authToken: authToken,
//            drinkID: drinkID,
//            newInput: newInput,
//            newName: newName,
//            newSummary: newSummary,
//            newIngredientsAndMeasurements: newIngredientsAndMeasurements?.map({RegenerateDrinkDirectionsRequest.IngredientAndMeasurement(ingredient: $0.ingredient, measurement: $0.measurement)}))
//        
//        let rddResponse = try await BarbackNetworkService.regenerateDrinkDirections(request: rddRequest)
//        
//        // Get permanent drinkObjectID for drink with drinkID
//        let drinkObjectID = try await DrinkCDClient.getDrinkPermanentID(drinkID: drinkID)
//        
//        // Delete all directions and append new ones
//        try await DrinkCDClient.deleteAllDirections(in: drinkObjectID)
//        
//        for direction in rddResponse.body.directions {
//            if let index = Int16(exactly: direction.key) {
//                try await DrinkCDClient.appendDirection(to: drinkObjectID, index: index, text: direction.value)
//            } else {
//                // TODO: Handle error here
//                print("Could not convert direction index to Int16 in regenerateSaveDrinkDirections in BarbackNetworkPersistenceManager!")
//            }
//        }
//    }
//    
//}


RecipeDirectionCDClient.swift
//
//  RecipeDirectionCDClient.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/18/24.
//

import CoreData
import Foundation

class RecipeDirectionCDClient {
    
    /***
     Append  Direction
     
     Appends and saves a direction for a recipe
     */
    
    static func appendDirection(index: Int16, string: String, to recipe: Recipe, in managedContext: NSManagedObjectContext) async throws {
        try await managedContext.perform {
            let recipeDirection = RecipeDirection(context: managedContext)
            
            recipeDirection.index = index
            recipeDirection.string = string
            recipeDirection.recipe = recipe
            
            try managedContext.save()
        }
    }
    
    static func appendDirections(content: [(index: Int16, string: String)], to recipe: Recipe, in managedContext: NSManagedObjectContext) async throws {
        try await managedContext.perform {
            for contentItem in content {
                let recipeDirection = RecipeDirection(context: managedContext)
                
                recipeDirection.index = contentItem.index
                recipeDirection.string = contentItem.string
                recipeDirection.recipe = recipe
            }
            
            try managedContext.save()
        }
    }
    
    /***
     Delete All Directions
     
     Deletes all directions for a recipe
     */
    
    static func deleteAllDirections(for recipe: Recipe, in managedContext: NSManagedObjectContext) async throws {
        let fetchRequest = RecipeDirection.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: "%K = %@", #keyPath(RecipeDirection.recipe), recipe)
//        fetchRequest.predicate = NSPredicate(format: "#k = #@", #keyPath(RecipeMeasuredIngredient.recipe), recipe)
        
        try await CDClient.delete(fetchRequest: fetchRequest, in: managedContext)
    }
    
}


RecipeCDClient.swift
//
//  RecipeCDClient.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/17/23.
//

import CoreData
import Foundation
import SwiftUI

class RecipeCDClient {
    
    static let recipeEntityName = String(describing: Recipe.self)
    static let recipeMeasuredIngredientEntityName = String(describing: RecipeMeasuredIngredient.self)
    static let recipeDirectionEntityName = String(describing: RecipeDirection.self)
    
    /***
     Append Recipe
     
     Appends and saves recipe
     */
    
    static func appendRecipe(recipeID: Int64, input: String?, saved: Bool = false, dailyRecipe_isDailyRecipe: Bool, dailyRecipe_timeFrameID: String?, name: String?, summary: String?, feasibility: Int16?, tastiness: Int16?, in managedContext: NSManagedObjectContext) async throws -> Recipe {
        // Build and save new recipe
        try await managedContext.perform {
            let recipe = Recipe(context: managedContext)
            
            recipe.recipeID = recipeID
            recipe.input = input
            recipe.saved = saved
            recipe.dailyRecipe_isDailyRecipe = dailyRecipe_isDailyRecipe
            recipe.dailyRecipe_timeFrameID = dailyRecipe_timeFrameID
            recipe.name = name
            recipe.summary = summary
            recipe.creationDate = Date()
            recipe.updateDate = Date()
            
            if let feasibility = feasibility {
                recipe.feasibility = feasibility
            }
            
            if let tastiness = tastiness {
                recipe.tastiness = tastiness
            }
            
            try managedContext.save()
            
            return recipe
        }
    }
    
    /***
     Count By
     
     Counts recipes by recipe ID and recipe object ID
     */
    static func countBy(recipeID: Int64, in managedContext: NSManagedObjectContext) async throws -> Int {
        let fetchRequest = NSFetchRequest<NSManagedObject>(entityName: recipeMeasuredIngredientEntityName)
        fetchRequest.predicate = NSPredicate(format: "%K = %@", #keyPath(Recipe.recipeID), recipeID)
        
        return try await CDClient.count(fetchRequest: fetchRequest, in: managedContext)
    }
    
    /***
     Delete Recipe
     
     Deletes a recipe
     */
    
    static func deleteRecipe(_ recipe: Recipe, in managedContext: NSManagedObjectContext) async throws {
        try await CDClient.delete(recipe, in: managedContext)
    }
    
    /***
     Update Recipe
     
     Updates a recipe
     */
    
    static func updateRecipe(_ recipe: Recipe, dailyRecipe_isDailyRecipe: Bool, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.dailyRecipe_isDailyRecipe = dailyRecipe_isDailyRecipe }, in: managedContext)
    }
    
    static func updateRecipe(_ recipe: Recipe, dailyRecipe_timeFrameID: String?, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.dailyRecipe_timeFrameID = dailyRecipe_timeFrameID }, in: managedContext)
    }
    
    static func updateRecipe(_ recipe: Recipe, saved: Bool, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.saved = saved }, in: managedContext)
    }

    static func updateRecipe(_ recipe: Recipe, recipeID: Int64, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.recipeID = recipeID }, in: managedContext)
    }

    static func updateRecipe(_ recipe: Recipe, input: String, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.input = input }, in: managedContext)
    }

    static func updateRecipe(_ recipe: Recipe, name: String, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.name = name }, in: managedContext)
    }

    static func updateRecipe(_ recipe: Recipe, summary: String, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.summary = summary }, in: managedContext)
    }

    static func updateRecipe(_ recipe: Recipe, estimatedServings: Int16, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.estimatedServings = estimatedServings }, in: managedContext)
    }
    
    static func updateRecipe(_ recipe: Recipe, estimatedTotalCalories: Int16, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.estimatedTotalCalories = estimatedTotalCalories }, in: managedContext)
    }
    
    static func updateRecipe(_ recipe: Recipe, estimatedTotalMinutes: Int16, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.estimatedTotalMinutes = estimatedTotalMinutes }, in: managedContext)
    }

    static func updateRecipe(_ recipe: Recipe, expandIngredientsMagnitude: Int16, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.expandIngredientsMagnitude = expandIngredientsMagnitude }, in: managedContext)
    }

    static func updateRecipe(_ recipe: Recipe, feasibility: Int16, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.feasibility = feasibility }, in: managedContext)
    }

    static func updateRecipe(_ recipe: Recipe, tastiness: Int16, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.tastiness = tastiness }, in: managedContext)
    }
    
    static func updateRecipe(_ recipe: Recipe, uiImage: UIImage, in managedContext: NSManagedObjectContext) async throws {
        guard let imageData = uiImage.jpegData(compressionQuality: 7) else {
            // TODO: Handle errors
            print("Could not unwrap imageData when updating recipe image in RecipeCDClient!")
            return
        }
        
        let dataLocation = UUID().uuidString
        AppGroupSaver(appGroupIdentifier: Constants.Additional.appGroupID).saveData(imageData, to: dataLocation)
        try await update(recipe, updater: { $0.imageAppGroupLocation = dataLocation }, in: managedContext)
    }

    static func updateRecipe(_ recipe: Recipe, updateDate: Date, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.updateDate = updateDate }, in: managedContext)
    }
    
    static func updateRecipe(_ recipe: Recipe, likeState: RecipeLikeState, in managedContext: NSManagedObjectContext) async throws {
        try await update(recipe, updater: { $0.likeState = Int16(likeState.rawValue) }, in: managedContext)
    }
    
    static func update(_ recipe: Recipe, updater: @escaping (Recipe) -> Void, in managedContext: NSManagedObjectContext) async throws {
        try await managedContext.perform {
            updater(recipe)
            try managedContext.save()
        }
    }
    
}


GlassCDClient.swift
////
////  GlassCDClient.swift
////  Barback
////
////  Created by Alex Coundouriotis on 9/19/23.
////
//
//import CoreData
//import Foundation
//
//class GlassCDClient {
//    
//    static let glassEntityName = String(describing: Glass.self)
//    
//    static func appendGlass(name: String, imageData: Data) async throws {
//        // Build and save new glass
//        try await CDClient.buildAndSave(named: glassEntityName) { managedObject in
//            guard let glass = managedObject as? Glass else {
//                // TODO: Handle errors
//                return
//            }
//            
//            glass.name = name
//            glass.imageData = imageData
//        }
//    }
//    
//    static func deleteGlasses(named name: String) async throws {
//        // Create fetch request to get Glass by name
//        let fetchRequest = NSFetchRequest<NSManagedObject>(entityName: glassEntityName)
//        fetchRequest.predicate = NSPredicate(format: "%k = %@", #keyPath(Glass.name), name)
//        
//        // Get permanentIDs for fetch request
//        let permanentIDs = try await CDClient.getPermanentIDs(fetchRequest)
//        
//        // Loop through and delete each object ID in permanentIDs
//        for permanentID in permanentIDs {
//            try await CDClient.delete(managedObjectID: permanentID)
//        }
//    }
//    
//    static func getImageDataBy(name: String) async throws -> Data? {
//        // Create fetch request to get Glass by name
//        let fetchRequest = NSFetchRequest<NSManagedObject>(entityName: glassEntityName)
//        fetchRequest.predicate = NSPredicate(format: "%k = %@", #keyPath(Glass.name), name)
//        
//        // Get permanent ID for fetch request
//        let permanentIDs = try await CDClient.getPermanentIDs(fetchRequest)
//        
//        // Ensure there are not 0 permanent IDs, otherwise return nil
//        guard permanentIDs.count > 0 else {
//            // TODO: Handle errors
//            print("No image data found for name in getImageDataBy in GlassCDClient!")
//            return nil
//        }
//        
//        // If there are more than 1 permanent ID, print to console and maybe handle error
//        if permanentIDs.count > 1 {
//            print("Multiple images' data found for name in getImageDataBy in GlassCDClient!")
//        }
//        
//        // Get the image by the first permanent ID in context and return its imageData
//        return try await CDClient.doInContext(managedObjectID: permanentIDs[0])  { managedObject in
//            guard let glass = managedObject as? Glass else {
//                // TODO: Handle errors
//                print("Could not unwrap managedObject as GLass in getImageDataBy in GlassCDClient!")
//                return nil
//            }
//            
//            return glass.imageData
//        }
//    }
//    
//}


CreatePanelsJSONPersistenceManager.swift
//
//  CreatePanelsJSONPersistenceManager.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/18/23.
//

import Foundation

class CreatePanelsJSONPersistenceManager {
    
    static func get() -> String? {
        UserDefaults.standard.string(forKey: Constants.UserDefaults.createPanelsJSON)
    }
    
    static func set(_ jsonString: String) {
        UserDefaults.standard.set(jsonString, forKey: Constants.UserDefaults.createPanelsJSON)
    }
    
}


ChefAppNetworkPersistenceManager.swift
//
//  ChefAppNetworkPersistenceManager.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/11/23.
//

import CoreData
import Foundation
import UIKit

class ChefAppNetworkPersistenceManager {
    
    public static func categorizeSaveUpdateAllPantryItems(authToken: String, in managedContext: NSManagedObjectContext) async throws {
        // Get all pantry items
        let pantryItemStrings = try await managedContext.perform {
            let fetchRequest = PantryItem.fetchRequest()
            
            let pantryItems = try managedContext.fetch(fetchRequest)
            
            return pantryItems.compactMap({$0.name})
        }
        
        // Build ciRequest and get ciReqsponse from ChefAppNetworkService
        let ciRequest = CategorizeIngredientsRequest(authToken: authToken, ingredients: pantryItemStrings)
        
        let ciResponse = try await ChefAppNetworkService.categorizeIngredients(request: ciRequest)
        
        // Update all pantry items in PantryItemCDClient
        try await PantryItemCDClient.updateAll(newPantryItems: ciResponse.body.ingredientCategories.map({(name: $0.ingredient.capitalized, category: $0.category.capitalized)}), in: managedContext)
    }
    
    public static func createSaveRecipe(authToken: String, ingredients: String, modifiers: String?, expandIngredientsMagnitude: Int, dailyRecipe_isDailyRecipe: Bool, dailyRecipe_timeFrameID: String?, in viewContext: NSManagedObjectContext) async throws -> Recipe {
        // Build criRequest and get criResponse from ChefAppNetworkService
        let criRequest = CreateRecipeIdeaRequest(
            authToken: authToken,
            ingredients: ingredients,
            modifiers: modifiers,
            expandIngredientsMagnitude: expandIngredientsMagnitude)
        
        let criResponse = try await ChefAppNetworkService.createRecipeIdea(request: criRequest)
        
        let recipe = try await RecipeCDClient.appendRecipe(
            recipeID: Int64(criResponse.body.recipeID),
            input: modifiers == nil || modifiers!.isEmpty ? ingredients : ingredients + " " + modifiers!, // TODO: Make this better, maybe just store original ingredients and modifiers instead of the input since that part is done on the server, or just stop doing it on the server and do it in the app and save it like this
            dailyRecipe_isDailyRecipe: dailyRecipe_isDailyRecipe,
            dailyRecipe_timeFrameID: dailyRecipe_timeFrameID,
            name: criResponse.body.name,
            summary: criResponse.body.summary,
            feasibility: nil,
            tastiness: nil,
            in: viewContext)
        
        return recipe
    }
    
    public static func finalizeUpdateRecipe(authToken: String, recipe: Recipe, additionalInput: String?, in managedContext: NSManagedObjectContext) async throws {
        // Build frRequest and get frResponse from ChefAppNetworkService TODO: Should be finalize recipe request
        let frReqeust = MakeRecipeFromIdeaRequest(
            authToken: authToken,
            ideaID: recipe.recipeID,
            additionalInput: additionalInput)
        
        let frResponse = try await ChefAppNetworkService.makeRecipeFromIdea(request: frReqeust)
        
        // Update estimatedTotalCalories
        if let estimatedTotalCalories = frResponse.body.estimatedTotalCalories {
            try await RecipeCDClient.updateRecipe(recipe, estimatedTotalCalories: Int16(estimatedTotalCalories), in: managedContext)
        }
        
        // Update estimatedTotalMinutes
        if let estimatedTotalMinutes = frResponse.body.estimatedTotalMinutes {
            try await RecipeCDClient.updateRecipe(recipe, estimatedTotalMinutes: Int16(estimatedTotalMinutes), in: managedContext)
        }
        
        // Update estimatedServings
        if let estimatedServings = frResponse.body.estimatedServings {
            try await RecipeCDClient.updateRecipe(recipe, estimatedServings: Int16(estimatedServings), in: managedContext)
        }
        
        // Update feasibility
        if let feasibility = frResponse.body.feasibility {
            try await RecipeCDClient.updateRecipe(recipe, feasibility: Int16(feasibility), in: managedContext)
        }
        
        // Delete all measuredIngredients currently in recipe
        try await RecipeMeasuredIngredientCDClient.deleteAllMeasuredIngredients(for: recipe, in: managedContext)
        
        // Add new ingredients to recipe
        try await RecipeMeasuredIngredientCDClient.appendMeasuredIngredients(ingredientsAndMeasurements: frResponse.body.allIngredientsAndMeasurements, to: recipe, in: managedContext)
        
        // Delete all directions currently in recipe
        try await RecipeDirectionCDClient.deleteAllDirections(for: recipe, in: managedContext)
        
        // Add new directions to recipe
        try await RecipeDirectionCDClient.appendDirections(content: frResponse.body.directions.map({(index: Int16($0.key), string: $0.value)}), to: recipe, in: managedContext)
    }
    
    public static func getSaveCreatePanels() async throws {
        let gcpResponse = try await ChefAppNetworkService.getCreatePanels()
        
        CreatePanelsJSONPersistenceManager.set(gcpResponse.body.createPanels)
    }
    
    public static func getAndDuplicateAndSaveRecipe(authToken: String, recipeID: Int, recipeGenerator: RecipeGenerator, in managedContext: NSManagedObjectContext) async throws -> Recipe? {
        let gadrRequest = GetAndDuplicateRecipeRequest(
            authToken: authToken,
            recipeID: recipeID)
        
        let gadrResponse = try await ChefAppNetworkService.getAndDuplicateRecipe(request: gadrRequest)
        
        guard let newRecipeID = gadrResponse.body.recipe.recipeID else {
            // TODO: Handle Errors
            print("Could not unwrap newRecipeID in ChefAppNetworkPersistenceManger!")
            return nil
        }
        
        let recipe = try await RecipeCDClient.appendRecipe(
            recipeID: Int64(newRecipeID),
            input: gadrResponse.body.recipe.input,
            saved: true,
            dailyRecipe_isDailyRecipe: false,
            dailyRecipe_timeFrameID: nil,
            name: gadrResponse.body.recipe.name,
            summary: gadrResponse.body.recipe.summary,
            feasibility: gadrResponse.body.recipe.feasibility == nil ? nil : Int16(gadrResponse.body.recipe.feasibility!),
            tastiness: nil,
            in: managedContext)
        
        if let measuredIngredients = gadrResponse.body.recipe.measuredIngredients {
            do {
                try await RecipeMeasuredIngredientCDClient.appendMeasuredIngredients(
                    ingredientsAndMeasurements: measuredIngredients,
                    to: recipe,
                    in: managedContext)
            } catch {
                // TODO: Handle Errors
                print("Error appending measured ingredients in ChefAppNetworkPersistenceManager, continuing... \(error)")
            }
        }
        
        if let instructions = gadrResponse.body.recipe.instructions {
            do {
                try await RecipeDirectionCDClient.appendDirections(
                    content: instructions.compactMap({(index: Int16($0.key), string: $0.value)}),
                    to: recipe,
                    in: managedContext)
            } catch {
                // TODO: Handle Errors
                print("Error appending instructions in ChefAppNetworkPersistenceManager, continuing... \(error)")
            }
        }
        
        do {
            // TODO: Make it share the image as well!
            try await recipeGenerator.generateBingImage(
                recipe: recipe,
                in: managedContext)
        } catch {
            // TODO: Handle Errors
            print("Error generating bing image for recipe in ChefAppNetworkPersistenceManager... \(error)")
        }
        
        return recipe
    }
    
    public static func generateSaveTags(authToken: String, recipe: Recipe, in viewContext: NSManagedObjectContext) async throws {
        // Build gtRequest and get gtResponse from ChefAppNetworkService
        let gtRequest = TagRecipeIdeaRequest(
            authToken: authToken,
            recipeID: recipe.recipeID)
        
        let gtResponse = try await ChefAppNetworkService.tagRecipeIdea(request: gtRequest)
        
        // Save tags
        try await viewContext.perform {
            for tagString in gtResponse.body.tags {
                let tag = RecipeTag(context: viewContext)
                
                tag.tag = tagString
                tag.recipe = recipe
            }
            
            try viewContext.save()
        }
    }
    
    public static func generateSaveFirstBingImage(recipe: Recipe, in viewContext: NSManagedObjectContext) async throws {
        if let query = recipe.name {
            // Get four images for the recipe name, and save the first image received if any
            let (imageURLs, queryCount) = try await BingSearchClient.getImages(
                query: query,
                count: 4,
                offset: 0)
            
            for imageURL in imageURLs {
                let urlRequest = URLRequest(url: imageURL)
                
                do {
                    // Do request
                    let (data, response) = try await URLSession.shared.data(for: urlRequest)
                    
                    // Parse data to image and save if successful
                    if let image = UIImage(data: data) {
                        try await RecipeCDClient.updateRecipe(recipe, uiImage: image, in: viewContext)
                        
                        // Break for loop
                        break
//                        try await viewContext.perform {
//                            // TODO: Make this save images to disk instead of CoreData
//                            recipe.imageData = image.pngData()
//                            recipe.imageURL = imageURL
//                            
//                            try viewContext.save()
//                        }
//                        
//                        // Break for loop
//                        break
                    }
                } catch {
                    print("Error getting response when getting images from Bing search response in ChefAppNetworkPersistenceManager: \(error)")
                }
            }
        }
    }
    
    public static func parseSavePantryItems(authToken: String, input: String?, imageDataInput: Data? = nil, in managedContext: NSManagedObjectContext) async throws {
        // Build pbiRequest and get pbiResponse from BarbackNetworkService
        let ppiRequest = ParsePantryItemsRequest(
            authToken: authToken,
            input: input,
            imageDataInput: imageDataInput)
        
        let ppiResponse = try await ChefAppNetworkService.parsePantryItems(request: ppiRequest)
        
        // Create duplicate bar item names array which will throw a duplicatePantryItemNames PantryItemPersistenceError with any duplicates so the user can be notified.. TODO: Is this a good implementation?
        var duplicatePantryItemNames: [String] = []
        
        // Save all bar items, capitalized, if item can be unwrapped, setting isAlcohol to false if nil
        for pantryItem in ppiResponse.body.pantryItems {
            if let item = pantryItem.item {
                do {
                    try await PantryItemCDClient.appendPantryItem(
                        name: item.capitalized,
                        category: pantryItem.category?.capitalized,
//                        amount: nil,
//                        expiration: nil,
                        in: managedContext)
                } catch PersistenceError.duplicateObject {
                    // TODO: Handle errors if necessary, but this is so that the function doesn't fall through
                    print("Removed duplicate object when parsing saving bar items in ChefAppNetworkPersistenceManager!")
                    duplicatePantryItemNames.append(item)
                }
            }
        }
        
        // Throw duplicate error if will throw dupilcate error is true
        if !duplicatePantryItemNames.isEmpty {
            throw PantryItemPersistenceError.duplicatePantryItemNames(duplicatePantryItemNames)
        }
    }
    
    public static func regenerateSaveMeasuredIngredientsAndDirectionsAndResolveUpdatedIngredients(authToken: String, recipe: Recipe, additionalInput: String, in managedContext: NSManagedObjectContext) async throws {
        // Ensure recipeMeasuredIngredients and ideaRecipe are not nil and recipe measuredIngredients count is greater than 0, otherwise throw GenerationError missingInput
        guard recipe.measuredIngredients != nil, recipe.measuredIngredients!.count > 0 else {
            throw GenerationError.missingInput
        }
        
        // Get and unwrap recipeMeasuredIngredientsArray, otherwise throw GenerationError request
        guard let recipeMeasuredIngredientsArray = recipe.measuredIngredients?.allObjects as? [RecipeMeasuredIngredient] else {
            throw GenerationError.request
        }
        
        // Delete any ingredients marked for deletion
        try await RecipeMeasuredIngredientCDClient.deleteMeasuredIngredientsMarkedForDeletion(for: recipe, in: managedContext)
        
        // Convert recipe measured ingredient array to string array using nameAndAmountModified if it can be unwrapped otherwise nameAndAmounts
        var recipeMeasuredIngredientStringArray: [String] = []
        for recipeMeasuredIngredient in recipeMeasuredIngredientsArray {
            // Ensure recipeManagedIngredient markedForDeletion is false, otherwise continue to ensure it is not appended to the string array TODO: I changed deleteOnRegenerate to markedForDeletion here, assuming they would have similar functionality or have the same functionality
            guard !recipeMeasuredIngredient.markedForDeletion else {
                continue
            }
            
            // Append nameAndAmountModified if it can be unwrapped, otherwise use nameAndAmount if it can be unwrapped
            if let nameAndAmountModified = recipeMeasuredIngredient.nameAndAmountModified {
                recipeMeasuredIngredientStringArray.append(nameAndAmountModified)
            } else if let nameAndAmount = recipeMeasuredIngredient.nameAndAmount {
                recipeMeasuredIngredientStringArray.append(nameAndAmount)
            }
        }
        
        // Create regenerateRecipeDirectionsAndIdeaRecipeIngredientsRequest
        let regenerateRecipeDirectionsAndIdeaRecipeIngredientsRequest = RegenerateRecipeMeasuredIngredientsAndDirectionsAndIdeaRecipeIngredientsRequest(
            authToken: authToken,
            recipeID: recipe.recipeID,
            newName: recipe.name,
            newSummary: recipe.summary,
            newServings: Int(recipe.estimatedServingsModified == 0 ? recipe.estimatedServings : recipe.estimatedServingsModified),
            measuredIngredients: recipeMeasuredIngredientStringArray,
            additionalInput: additionalInput)
        
        // Get regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse
        let regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse = try await ChefAppNetworkService.regenerateRecipeDirectionsAndIdeaRecipeIngredients(request: regenerateRecipeDirectionsAndIdeaRecipeIngredientsRequest)
        
        // Update estiamted servings
        if let estimatedServings = regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse.body.estimatedServings {
            try await RecipeCDClient.updateRecipe(recipe, estimatedServings: Int16(estimatedServings), in: managedContext)
        }
        
        // Update feasibility
        if let feasibility = regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse.body.feasibility {
            try await RecipeCDClient.updateRecipe(recipe, feasibility: Int16(feasibility), in: managedContext)
        }
        
        // Update measured ingredients
        let receivedMeasuredIngredients = regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse.body.allIngredientsAndMeasurements
        if !receivedMeasuredIngredients.isEmpty {
            try await RecipeMeasuredIngredientCDClient.deleteAllMeasuredIngredients(for: recipe, in: managedContext)
            try await RecipeMeasuredIngredientCDClient.appendMeasuredIngredients(ingredientsAndMeasurements: receivedMeasuredIngredients, to: recipe, in: managedContext)
        }
        
        // Update instructions
        let receivedDirections = regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse.body.instructions
        if !receivedDirections.isEmpty {
            // Map receivedDirections to index and string touple
            let receivedDirectionsWithIndices: [(index: Int16, string: String)] = receivedDirections.map({(index: Int16($0.key), string: $0.value)})//receivedDirections.enumerated().map { (index, string) in (index: Int16(index), string: string) }
            
            try await RecipeDirectionCDClient.deleteAllDirections(for: recipe, in: managedContext)
            try await RecipeDirectionCDClient.appendDirections(content: receivedDirectionsWithIndices, to: recipe, in: managedContext)
        }
    }
    
    public static func saveRecipeImageURL(authToken: String, recipe: Recipe, in managedContext: NSManagedObjectContext) async throws {
        // Get image URL
        guard let imageURL = await managedContext.perform({ recipe.imageURL }) else {
            // TODO: Handle Errors
            print("Could not unwrap imageURL in ChefAppNetworkPersistenceManager!")
            return
        }
        
        // Check if imageURL is valid
        let isValid: Bool
        do {
            let (data, response) = try await URLSession.shared.data(from: imageURL)
            if let httpResponse = response as? HTTPURLResponse,
               httpResponse.statusCode == 200 {
                isValid = true
            } else {
                isValid = false
            }
        } catch {
            // TODO: Handle Errors
            print("Error checking if image URL is valid in ChefAppNetworkPersistenceManager... \(error)")
            throw error
        }
        
        // Ensure isValid, otherwise return TODO: Research error handling in Swift and check if this should throw because it probably should
        guard isValid else {
            // TODO: Handle Errors
            print("Image URL is not valid in ChefAppNetworkPersistenceManager!")
            return
        }
        
        // Save imageURL to server
        try await ChefAppNetworkService.updateRecipeImageURL(
            request: UpdateRecipeImageURLRequest(
                authToken: authToken,
                recipeID: Int(recipe.recipeID),
                imageURL: imageURL.absoluteString))
    }
    
}


CoreDataToAppGroupMigrator.swift
////
////  CoreDataToAppGroupMigrator.swift
////  ChefApp-SwiftUI
////
////  Created by Alex Coundouriotis on 11/30/24.
////
//
//import CoreData
//import Foundation
//
//class CoreDataToAppGroupMigrator {
//    
//    func needsMigration() async -> Bool {
//        // Check if old model has and new model does not have different entities
//        if await checkIfOldModelHasEntityEntryAndNewModelDoesNot(entityType: Recipe.self) {
//            return true
//        }
//        if await checkIfOldModelHasEntityEntryAndNewModelDoesNot(entityType: PantryItem.self) {
//            return true
//        }
//        // TODO: Make sure more checks are not needed
//        return false
//    }
//    
//    private func checkIfOldModelHasEntityEntryAndNewModelDoesNot<T: NSManagedObject>(entityType: T.Type) async -> Bool {
//        do {
//            let oldModelHasEntity: Bool = try await CDClient.oldManagedObjectContext.perform { try CDClient.oldManagedObjectContext.fetch(NSFetchRequest(entityName: "Recipe")).count > 0 }
//            let newModelHasEntity: Bool = try await CDClient.mainManagedObjectContext.perform { try CDClient.mainManagedObjectContext.fetch(T.fetchRequest()).count > 0 }
//            
//            if oldModelHasEntity && !newModelHasEntity {
//                return true
//            }
//        } catch {
//            print("Error checking entity entries in CoreDataToAppGroupMigrator... \(error)")
//        }
//        return false
//    }
//    
//    func migrate() async {
//        guard await needsMigration() else {
//            return
//        }
//        
//        // Migrate each entity
//        await migrateEntity(entityType: Pantry.self)
//        await migrateEntity(entityType: PantryItem.self)
//        await migrateEntity(entityType: Recipe.self)
//        await migrateEntity(entityType: RecipeDirection.self)
//        await migrateEntity(entityType: RecipeMeasuredIngredient.self)
//        await migrateEntity(entityType: RecipeTag.self)
//        await migrateEntity(entityType: ShoppingList.self)
//        await migrateEntity(entityType: ShoppingListIngredient.self)
//    }
//    
//    func migrateEntity<T: NSManagedObject>(entityType: T.Type) async {
//        do {
//            // Fetch existing objects from the old context
//            let fetchRequest = T.fetchRequest()
//            let oldModelResults = try await CDClient.oldManagedObjectContext.perform {
//                try CDClient.oldManagedObjectContext.fetch(fetchRequest) as! [T]
//            }
//            
//            // Migrate objects to the new context
//            try await CDClient.mainManagedObjectContext.perform {
//                guard let entityDescription = T.entity() as NSEntityDescription? else {
//                    print("Entity description not found for \(T.self).")
//                    return
//                }
//                
//                let attributes = entityDescription.attributesByName
//                let relationships = entityDescription.relationshipsByName
//                
//                var oldToNewMapping: [NSManagedObjectID: NSManagedObject] = [:]
//                
//                // First, copy attribute values
//                for oldObject in oldModelResults {
//                    // Create a new object in the new context
//                    let newObject = T(context: CDClient.mainManagedObjectContext)
//                    
//                    // Map old object ID to new object for relationships
//                    oldToNewMapping[oldObject.objectID] = newObject
//                    
//                    // Copy attribute values
//                    for (attributeName, _) in attributes {
//                        let value = oldObject.value(forKey: attributeName)
//                        newObject.setValue(value, forKey: attributeName)
//                    }
//                }
//                
//                // Then, set up relationships
//                for oldObject in oldModelResults {
//                    if let newObject = oldToNewMapping[oldObject.objectID] {
//                        for (relationshipName, relationshipDescription) in relationships {
//                            if relationshipDescription.isToMany {
//                                let oldRelatedObjects = oldObject.mutableSetValue(forKey: relationshipName)
//                                let newRelatedObjects = NSMutableSet()
//                                for oldRelatedObject in oldRelatedObjects {
//                                    if let oldRelatedManagedObject = oldRelatedObject as? NSManagedObject,
//                                       let newRelatedObject = oldToNewMapping[oldRelatedManagedObject.objectID] {
//                                        newRelatedObjects.add(newRelatedObject)
//                                    }
//                                }
//                                newObject.setValue(newRelatedObjects, forKey: relationshipName)
//                            } else {
//                                if let oldRelatedObject = oldObject.value(forKey: relationshipName) as? NSManagedObject,
//                                   let newRelatedObject = oldToNewMapping[oldRelatedObject.objectID] {
//                                    newObject.setValue(newRelatedObject, forKey: relationshipName)
//                                }
//                            }
//                        }
//                    }
//                }
//                
//                // Save the new context after migration
//                if CDClient.mainManagedObjectContext.hasChanges {
//                    try CDClient.mainManagedObjectContext.save()
//                }
//            }
//        } catch {
//            print("Error migrating entity in CoreDataToAppGroupMigrator... \(error)")
//        }
//    }
//    
//}


CDClient.swift
//
//  CDClient.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 4/18/23.
//

import CoreData
import Foundation
import UIKit

class CDClient: Any {
    
    internal static let modelName: String = Constants.Additional.coreDataModelName
    
//    internal static var appDelegate: AppDelegate {
//        get {
//            if Thread.isMainThread {
//                return UIApplication.shared.delegate as! AppDelegate
//            } else {
//                var appDelegate: AppDelegate? = nil
//                DispatchQueue.main.sync {
//                    appDelegate = UIApplication.shared.delegate as? AppDelegate
//                }
//                return appDelegate!
//            }
//        }
//    }
//    private static let persistentContainer: NSPersistentContainer = {
//        // OLD CONTAINER IS COMMENTED
//        let container = NSPersistentContainer(name: modelName)
//        container.loadPersistentStores(completionHandler: {description, error in
//            if let error = error as? NSError {
//                fatalError("Couldn't load persistent stores!
\(error)
\(error.userInfo)")
//            }
//        })
//        return container
//        // END OLD CONTAINER
//        
////        let container = NSPersistentContainer(name: modelName)
////        // 1
////        guard let storeLocation = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: Constants.Additional.appGroupID)?.appendingPathComponent("\(modelName)") else {
////            fatalError("Could not find CoreData model!")
////        }
////        // 2
////        let description = NSPersistentStoreDescription(url: storeLocation)
////        // 3
////        container.persistentStoreDescriptions = [description]
////
////        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
////            if let error = error as NSError? {
////                print("Unresolved error \(error), \(error.userInfo)")
////            }
////        })
////        
////        return container
//    }()
    
    private static let persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: modelName)

        // New store location (app group URL)
        guard let appGroupStoreURL = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: Constants.Additional.appGroupID)?.appendingPathComponent("\(modelName)") else {
            fatalError("Could not find CoreData model!")
        }

        // Old store location (default URL)
        let defaultStoreURL = NSPersistentContainer.defaultDirectoryURL().appendingPathComponent("\(modelName).sqlite")

        // Determine which store URL to use
        let storeURL: URL
        let fileManager = FileManager.default

        if fileManager.fileExists(atPath: appGroupStoreURL.path) {
            // Use the new store URL if it exists
            storeURL = appGroupStoreURL
        } else if fileManager.fileExists(atPath: defaultStoreURL.path) {
            // Use the old store URL to perform migration
            storeURL = defaultStoreURL
        } else {
            // Neither store exists; set to new store URL
            storeURL = appGroupStoreURL
        }

        let description = NSPersistentStoreDescription(url: storeURL)
        container.persistentStoreDescriptions = [description]

        // Perform migration if needed
        do {
            try migrateStoreIfNeeded(for: container, storeURL: storeURL, appGroupStoreURL: appGroupStoreURL, defaultStoreURL: defaultStoreURL)
        } catch {
            // TODO: Handle Errors
            print("Error migrating store, using old store... \(error)")
        }

        // Load the persistent stores
        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
            if let error = error as NSError? {
                print("Unresolved error \(error), \(error.userInfo)")
            }
        })

        return container

    }()

    private static func migrateStoreIfNeeded(for container: NSPersistentContainer, storeURL: URL, appGroupStoreURL: URL, defaultStoreURL: URL) throws {
        let fileManager = FileManager.default

        // Check if migration is needed (old store exists and new store does not)
        if storeURL == defaultStoreURL && fileManager.fileExists(atPath: defaultStoreURL.path) {
            // Initialize a persistent store coordinator with your model
            let coordinator = NSPersistentStoreCoordinator(managedObjectModel: container.managedObjectModel)
            
            // Add the old store to the coordinator
            let oldStore = try coordinator.addPersistentStore(ofType: NSSQLiteStoreType, configurationName: nil, at: defaultStoreURL, options: nil)
            
            // Migrate the store to the new location
            let _ = try coordinator.migratePersistentStore(oldStore, to: appGroupStoreURL, options: nil, withType: NSSQLiteStoreType)
            
            // Remove old store files
            try coordinator.destroyPersistentStore(at: defaultStoreURL, ofType: NSSQLiteStoreType, options: nil)
            let shmFile = defaultStoreURL.deletingPathExtension().appendingPathExtension("sqlite-shm")
            let walFile = defaultStoreURL.deletingPathExtension().appendingPathExtension("sqlite-wal")
            if fileManager.fileExists(atPath: shmFile.path) {
                try fileManager.removeItem(at: shmFile)
            }
            if fileManager.fileExists(atPath: walFile.path) {
                try fileManager.removeItem(at: walFile)
            }
            
            // Update the store description to point to the new store URL
            container.persistentStoreDescriptions.first?.url = appGroupStoreURL
        }
    }
    
    public static let mainManagedObjectContext: NSManagedObjectContext = persistentContainer.viewContext
    
    private static let oldPersistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: modelName)
        container.loadPersistentStores(completionHandler: {description, error in
            if let error = error as? NSError {
                fatalError("Couldn't load persistent stores!
\(error)
\(error.userInfo)")
            }
        })
        return container
    }()
    
    public static let oldManagedObjectContext: NSManagedObjectContext = oldPersistentContainer.viewContext
    
    
    internal static func count<O: NSManagedObject>(fetchRequest: NSFetchRequest<O>, in managedContext: NSManagedObjectContext) async throws -> Int {
        return try await managedContext.perform {
            // Get count and return
            let count = try managedContext.count(for: fetchRequest)
            return count
        }
    }

    internal static func count(entityName: String, in managedContext: NSManagedObjectContext) async throws -> Int {
        return try await managedContext.perform {
            // Create fetch request
            let fetchRequest = NSFetchRequest<NSManagedObject>(entityName: entityName)
            // Get count and return
            let count = try managedContext.count(for: fetchRequest)
            return count
        }
    }

    internal static func doInContext<T>(managedObjectID: NSManagedObjectID, in managedContext: NSManagedObjectContext, block: @escaping (NSManagedObject) -> T?) async throws -> T? {
        return try await managedContext.perform {
            let managedObject = try managedContext.existingObject(with: managedObjectID)
            return block(managedObject)
        }
    }

    internal static func getPermanentIDs(_ fetchRequest: NSFetchRequest<NSManagedObject>, in managedContext: NSManagedObjectContext) async throws -> [NSManagedObjectID] {
        return try await managedContext.perform {
            // Perform fetchRequest
            let managedObjects = try managedContext.fetch(fetchRequest)
            // Obtain permanent IDs for all managedObjects
            try managedContext.obtainPermanentIDs(for: managedObjects)
            // Return managedObjects mapped to array of their objectIDs
            return managedObjects.map({ $0.objectID })
        }
    }

    internal static func delete<T: NSManagedObject>(_ managedObject: T, in managedContext: NSManagedObjectContext) async throws {
        return try await managedContext.perform {
            // Delete managedObject
            managedContext.delete(managedObject)
            
            // Save managedContext
            try managedContext.save()
        }
    }
    
    static func delete<T: NSManagedObject>(fetchRequest: NSFetchRequest<T>, in managedContext: NSManagedObjectContext) async throws {
        try await managedContext.perform {
            for result in try managedContext.fetch(fetchRequest) {
                managedContext.delete(result)
                
                try managedContext.save()
            }
        }
    }

    internal static func update(managedObjectID: NSManagedObjectID, in managedContext: NSManagedObjectContext, updater: @escaping (NSManagedObject) -> Void) async throws {
        return try await managedContext.perform {
            // Get managedObject as existing object with managedObjectID
            let managedObject = try managedContext.existingObject(with: managedObjectID)
            // Do updater
            updater(managedObject)
            // Save managedContext
            try managedContext.save()
        }
    }

    private static func parsePredicateFromWhereColValMap(whereColValMap: [String: CVarArg]) -> NSPredicate {
        // Create predicate array
        var predicates: [NSPredicate] = []
        // Append to predicates
        whereColValMap.forEach { key, value in
            predicates.append(NSPredicate(format: "%K = %@", key, value as! CVarArg))
        }
        // Return NSCompoundPredicate with the predicates in the array
        return NSCompoundPredicate(type: .and, subpredicates: predicates)
    }
    
    
}


RecipeGenerationAdditionalOptions.swift
//
//  RecipeGenerationAdditionalOptions.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/25/24.
//

import Foundation

enum RecipeGenerationAdditionalOptions: Int, Codable {
    // Currently maps to expandIngredientsMagnitude for server
    case normal = 1
    case useOnlyGivenIngredients = 0
    case boostCreativity = 2
}


Recipe+Extensions.swift
//
//  Recipe+Extensions.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/10/24.
//

import Foundation
import UIKit

extension Recipe {
    
    var imageFromAppData: UIImage? {
        guard let imageAppGroupLocation else {
            // TODO: Handle Errors
            print("Could not unwrap imageAppGroupLocation in Recipe+Extensions!")
            return nil
        }
        
        guard let imageData = AppGroupLoader(appGroupIdentifier: Constants.Additional.appGroupID).loadData(from: imageAppGroupLocation) else {
            // TODO: Handle Errors
            print("Could not unwrap imageData from AppGroupLoader in Recipe+Extensions!")
            return nil
        }
        
        return UIImage(data: imageData)
    }
    
}


FontWeight.swift
//
//  FontWeight.swift
//  MealPlanChef
//
//  Created by Alex Coundouriotis on 12/1/24.
//

import Foundation

enum FontWeight {
    
    case light, body, medium, heavy, black, damion
    
}

extension FontWeight {
    
    var appFontName: String {
        switch self {
        case .light: Constants.FontName.light
        case .body: Constants.FontName.body
        case .medium: Constants.FontName.medium
        case .heavy: Constants.FontName.heavy
        case .black: Constants.FontName.black
        case .damion: Constants.FontName.damion
        }
    }
}


PantryItem+Extensions.swift
//
//  PantryItem+Extensions.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/29/24.
//

import Foundation

extension PantryItem {
    
    @objc
    var daysAgoString: String? {
        if let updateDate {
            // Calculate the number of full days between the dates
            guard let days = daysAgoInt else {
                return nil
            }
            
            switch days {
            case 0:
                return "Today"
            case 1:
                return "Yesterday"
            default:
                return "\(days) Days Ago"
            }
        }
        
        return nil
    }
    
    var daysAgoInt: Int? {
        if let updateDate {
            let calendar = Calendar.current
            return calendar.dateComponents([.day], from: calendar.startOfDay(for: updateDate), to: calendar.startOfDay(for: Date())).day
        }
        
        return nil
    }
    
}


RecipeLikeState.swift
//
//  RecipeLikeState.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/27/24.
//

import Foundation

enum RecipeLikeState: Int, Codable {
    
    case dislike = -1
    case none = 0
    case like = 1
    
}


RecipeGenerationSpec.swift
//
//  RecipeGenerationSpec.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/27/24.
//

import Foundation

class RecipeGenerationSpec: ObservableObject, Identifiable {
    
    let id = UUID()
    
    @Published var pantryItems: [PantryItem]
    @Published var suggestions: [String]
    @Published var input: String
    @Published var generationAdditionalOptions: RecipeGenerationAdditionalOptions
    
    init(pantryItems: [PantryItem], suggestions: [String], input: String, generationAdditionalOptions: RecipeGenerationAdditionalOptions) {
        self.pantryItems = pantryItems
        self.suggestions = suggestions
        self.input = input
        self.generationAdditionalOptions = generationAdditionalOptions
    }
    
}


SettingsView.swift
//
//  SettingsView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/5/23.
//

import SwiftUI

struct SettingsView: View {
    
    @ObservedObject var premiumUpdater: PremiumUpdater // TODO: Should this instead just communicate showUltraView and shouldRestore?
    @Binding var isShowing: Bool
    
    
    @State var isShowingUltraView: Bool = false
    @State var isShowingPrivacyPolicyWebView: Bool = false
    @State var isShowingTermsWebView: Bool = false
    
    var body: some View {
        VStack(spacing: 0.0) {
//            header
            Spacer()
            
            List {
                if !premiumUpdater.isPremium {
                    Section {
                        premium
                    }
                }
                
                Section {
                    share
                    
                    privacyPolicy
                    
                    termsOfService
                    
                    restorePurchases
                }
            }
            .scrollContentBackground(.hidden)
            .background(Colors.background)
        }
        .foregroundStyle(Colors.foregroundText)
        .background(Colors.background)
        .toolbar {
            LogoToolbarItem(foregroundColor: Colors.elementBackground)
        }
        .toolbarBackground(Colors.background, for: .navigationBar)
        .navigationBarTitleDisplayMode(.inline)
        .ultraViewPopover(isPresented: $isShowingUltraView)
    }
    
//    var header: some View {
//        ZStack {
//            HStack {
//                VStack {
//                    Spacer()
//                    Button(action: {
//                        withAnimation {
//                            isShowing = false
//                        }
//                    }) {
//                        Text("Back")
//                            .font(.custom(Constants.FontName.black, size: 20.0))
//                            .foregroundStyle(Colors.elementText)
//                            .padding(.bottom, 8)
//                            .padding(.leading)
//                    }
//                }
//                Spacer()
//            }
//            
//            HStack {
//                Spacer()
//                VStack {
//                    Spacer()
//                    Text("Barback")
//                        .font(.custom(Constants.FontName.appname, size: 34.0))
//                        .foregroundStyle(Colors.elementText)
//                        .padding(4)
//                }
//                Spacer()
//            }
//        }
//        .frame(height: 100)
//        .background(foregroundColor)
//    }
    
    var premium: some View {
        Button(action: {
            HapticHelper.doLightHaptic()
            
            isShowingUltraView = true
        }) {
            HStack {
                Image(systemName: "gift")
                    .font(.custom(Constants.FontName.medium, size: 24.0))
                    .frame(width: 60.0)
                Text("Get 3 Days")
                    .font(.custom(Constants.FontName.body, size: 17.0))
                Text("Free")
                    .font(.custom(Constants.FontName.black, size: 17.0))
                Spacer()
                Text(Image(systemName: "chevron.right"))
                    .font(.custom(Constants.FontName.body, size: 17.0))
            }
            .padding([.top, .bottom], 8)
        }
    }
    
    var share: some View {
        Button(action: {
            HapticHelper.doLightHaptic()
            
            PasteboardHelper.copy(ConstantsUpdater.shareURL)
        }) {
            HStack {
                Image(systemName: "person.3")
                    .font(.custom(Constants.FontName.heavy, size: 20.0))
                    .frame(width: 60.0)
                Text("Share")
                    .font(.custom(Constants.FontName.black, size: 17.0))
                Text("with Friends")
                    .font(.custom(Constants.FontName.body, size: 17.0))
                Spacer()
                Text(Image(systemName: "chevron.right"))
                    .font(.custom(Constants.FontName.body, size: 17.0))
            }
        }
        .padding([.top, .bottom], 8)
    }
    
    var privacyPolicy: some View {
        Button(action: {
            HapticHelper.doLightHaptic()
            
            isShowingPrivacyPolicyWebView = true
        }) {
            HStack {
                Image(systemName: "paperclip")
                    .font(.custom(Constants.FontName.medium, size: 24.0))
                    .frame(width: 60.0)
                Text("Privacy Policy")
                    .font(.custom(Constants.FontName.body, size: 17.0))
                Spacer()
                Text(Image(systemName: "chevron.right"))
                    .font(.custom(Constants.FontName.body, size: 17.0))
            }
        }
        .padding([.top, .bottom], 8)
        .fullScreenCover(isPresented: $isShowingPrivacyPolicyWebView) {
            VStack {
                WebView(url: URL(string: "\(Constants.HTTPSConstants.chitChatServerStaticFiles)\(Constants.HTTPSConstants.privacyPolicy)")!)
                    .chefAppHeader(showsDivider: true, left: {
                        Button(action: {
                            HapticHelper.doLightHaptic()
                            
                            withAnimation {
                                isShowingPrivacyPolicyWebView = false
                            }
                        }) {
                            Text("Back")
                                .font(.custom(Constants.FontName.black, size: 20.0))
                                .foregroundStyle(Colors.elementText)
                                .padding(.bottom, 8)
                                .padding(.leading)
                        }
                    }, right: {
                        
                    })
                    .background(Colors.elementBackground)
                    .ignoresSafeArea()
            }
        }
    }
    
    var termsOfService: some View {
        Button(action: {
            HapticHelper.doLightHaptic()
            
            isShowingTermsWebView = true
        }) {
            HStack {
                Image(systemName: "newspaper")
                    .font(.custom(Constants.FontName.medium, size: 24.0))
                    .frame(width: 60.0)
                Text("Terms of Service")
                    .font(.custom(Constants.FontName.body, size: 17.0))
                Spacer()
                Text(Image(systemName: "chevron.right"))
                    .font(.custom(Constants.FontName.body, size: 17.0))
                
            }
        }
        .padding([.top, .bottom], 8)
        .fullScreenCover(isPresented: $isShowingTermsWebView) {
            VStack {
                WebView(url: URL(string: "\(Constants.HTTPSConstants.chitChatServerStaticFiles)\(Constants.HTTPSConstants.termsAndConditions)")!)
                    .chefAppHeader(showsDivider: true, left: {
                        Button(action: {
                            HapticHelper.doLightHaptic()
                            
                            withAnimation {
                                isShowingTermsWebView = false
                            }
                        }) {
                            Text("Back")
                                .font(.custom(Constants.FontName.black, size: 20.0))
                                .foregroundStyle(Colors.elementText)
                                .padding(.bottom, 8)
                                .padding(.leading)
                        }
                    }, right: {
                        
                    })
                    .background(Colors.elementBackground)
                    .ignoresSafeArea()
            }
        }
        
    }
    
    var restorePurchases: some View {
        Button(action: {
            HapticHelper.doLightHaptic()
            
            isShowingUltraView = true
        }) {
            HStack {
                Image(systemName: "arrow.2.circlepath")
                    .font(.custom(Constants.FontName.medium, size: 24.0))
                    .frame(width: 60.0)
                Text("Restore Purchases")
                    .font(.custom(Constants.FontName.body, size: 17.0))
                Spacer()
                Text(Image(systemName: "chevron.right"))
                    .font(.custom(Constants.FontName.body, size: 17.0))
            }
        }
        .padding([.top, .bottom], 8)
    }
    
}

#Preview {
    NavigationStack {
        SettingsView(
            premiumUpdater: PremiumUpdater(),
            isShowing: .constant(true))
    }
}


CaptureCameraViewController+CaptureCameraViewDelegate.swift
//
//  CaptureCameraViewController+CaptureCameraViewDelegate.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 4/15/23.
//

import AVKit
import Foundation
import Vision

extension CaptureCameraViewController: CaptureCameraViewDelegate {
    
    /***
     cameraButtonPressed
     
     If backgroundImage is cameraButtonNotPressed or cameraButtonPressed, the user took a picture
     If backgroundImage is anything else, user pressed the confirm button
     */
    func cameraButtonPressed() {
        // Do haptic
        HapticHelper.doLightHaptic()
        
        // Get flash mode TODO: Fix this, make it more dynamic so it doesn't have to get caputreDevice
        let flashMode: AVCaptureDevice.FlashMode = {
            if let captureDevice = AVCaptureDevice.default(for: AVMediaType.video) {
                return switch captureDevice.torchMode {
                case .auto: .auto
                case .off: .off
                case .on: .on
                @unknown default: .off
                }
            }
            
            return .off
        }()
        
        // Take photo or delete and redo, depending on button image
        if rootView.cameraButton.backgroundImage(for: .normal) == UIImage(named: Constants.ImageName.cameraButtonNotPressed) || rootView.cameraButton.backgroundImage(for: .normal) == UIImage(named: Constants.ImageName.cameraButtonPressed) {
            // Camera was enabled, so take the photo
            guard let capturePhotoOutput = self.capturePhotoOutput else { return }
            
            // Set photoSettings TODO: Make a flash button
            let photoSettings = AVCapturePhotoSettings()
            photoSettings.isAutoStillImageStabilizationEnabled = true
//            photoSettings.isHighResolutionPhotoEnabled = true
            
            photoSettings.flashMode = flashMode
            
            // Capture the photo
            capturePhotoOutput.capturePhoto(with: photoSettings, delegate: self)
        } else {
//            // Camera was not enabled, so delete the picture and redo
//            startUpCamera()
//            deInitializeCropView()
            
            // Ensure previewImage can be unwrapped, otherwise return
            guard let previewImage = previewImageView.image else {
                // TODO: Handle errors
                return
            }
            
            // Do haptic
            HapticHelper.doLightHaptic()
            
            // Get croppedImage and cropFrame, either cropped or not depending on crop switch
            if rootView.showCropViewSwitch.isOn {
                let (croppedImage, cropFrame): (CGImage?, CGRect?) = {
                    // Get the bounds of the image view and the previewImage
                    let imageViewSize = previewImageView.bounds.size
                    let imageSize = previewImage.size
                    
                    // Calculate the scale factor and the offset
                    let widthScale = imageSize.width / imageViewSize.width
                    let heightScale = imageSize.height / imageViewSize.height
                    let scaleFactor = max(widthScale, heightScale)
                    
                    let scaledImageWidth = imageSize.width / scaleFactor
                    let scaledImageHeight = imageSize.height / scaleFactor
                    
                    let imageOffsetX = (imageViewSize.width - scaledImageWidth) / 2
                    let imageOffsetY = (imageViewSize.height - scaledImageHeight) / 2
                    
                    let cropAreaWidth = rootView.container.frame.width - rootView.cropViewLeadingConstraint.constant - rootView.cropViewTrailingConstraint.constant
                    let cropAreaHeight = rootView.container.frame.height - rootView.cropViewTopConstraint.constant - rootView.cropViewBottomConstraint.constant
                    
                    // Calculate the cropping rectangle
                    let cropFrame = CGRect(
                        x: (rootView.cropViewLeadingConstraint.constant - imageOffsetX) * scaleFactor,
                        y: (rootView.cropViewTopConstraint.constant - imageOffsetY) * scaleFactor,
                        width: cropAreaWidth * scaleFactor,
                        height: cropAreaHeight * scaleFactor
                    )
                    
                    return (previewImageView.image?.cgImage?.cropping(to: cropFrame), cropFrame)
                    //            } else {
                    //                // Simply return the image as cgImage
                    //                return previewImageView.image?.cgImage
                    //            }
                }()
                
                // Unwrap croppedImage and cropFrame, otherwise start up camera again and return
                guard let croppedImage = croppedImage, let cropFrame = cropFrame else {
                    // TODO: Handle errors
                    print("Could not get the cropped image.")
                    startUpCamera()
                    return
                }
                
                // Call delegate didAttachImage with croppedImage as image,
                delegate.didAttachImage(image: UIImage(cgImage: croppedImage), cropFrame: cropFrame, unmodifiedImage: previewImage)
            } else {
                // Call delegate didAttachImage with just previewImage as image
                delegate.didAttachImage(image: previewImage, cropFrame: nil, unmodifiedImage: nil)
            }
        }
    }
    
    func flashButtonPressed() {
        // Cycle flash mode
        cycleFlashMode()
    }
    
    func imageButtonPressed() {
        // Do haptic
        HapticHelper.doLightHaptic()
        
        // Show image picker if source type is available
        if UIImagePickerController.isSourceTypeAvailable(.photoLibrary) {
            let imagePickerController = UIImagePickerController()
            imagePickerController.delegate = self
            imagePickerController.sourceType = .photoLibrary
            present(imagePickerController, animated: true)
        }
    }
    
//    func attachImageButtonPressed() {
////        // Ensure previewImageView can be unwrapped, otherwise return
////        guard let previewImageView = previewImageView else {
////            // TODO: Handle errors
////            return
////        }
//        
//        // Ensure previewImage can be unwrapped, otherwise return
//        guard let previewImage = previewImageView.image else {
//            // TODO: Handle errors
//            return
//        }
//        
//        // Do haptic
//        HapticHelper.doLightHaptic()
//        
//        // Get croppedImage and cropFrame, either cropped or not depending on crop switch
//        if rootView.showCropViewSwitch.isOn {
//            let (croppedImage, cropFrame): (CGImage?, CGRect?) = {
//                // Get the bounds of the image view and the previewImage
//                let imageViewSize = previewImageView.bounds.size
//                let imageSize = previewImage.size
//                
//                // Calculate the scale factor and the offset
//                let widthScale = imageSize.width / imageViewSize.width
//                let heightScale = imageSize.height / imageViewSize.height
//                let scaleFactor = max(widthScale, heightScale)
//                
//                let scaledImageWidth = imageSize.width / scaleFactor
//                let scaledImageHeight = imageSize.height / scaleFactor
//                
//                let imageOffsetX = (imageViewSize.width - scaledImageWidth) / 2
//                let imageOffsetY = (imageViewSize.height - scaledImageHeight) / 2
//                
//                let cropAreaWidth = rootView.container.frame.width - rootView.cropViewLeadingConstraint.constant - rootView.cropViewTrailingConstraint.constant
//                let cropAreaHeight = rootView.container.frame.height - rootView.cropViewTopConstraint.constant - rootView.cropViewBottomConstraint.constant
//                
//                // Calculate the cropping rectangle
//                let cropFrame = CGRect(
//                    x: (rootView.cropViewLeadingConstraint.constant - imageOffsetX) * scaleFactor,
//                    y: (rootView.cropViewTopConstraint.constant - imageOffsetY) * scaleFactor,
//                    width: cropAreaWidth * scaleFactor,
//                    height: cropAreaHeight * scaleFactor
//                )
//                
//                return (previewImageView.image?.cgImage?.cropping(to: cropFrame), cropFrame)
//                //            } else {
//                //                // Simply return the image as cgImage
//                //                return previewImageView.image?.cgImage
//                //            }
//            }()
//            
//            // Unwrap croppedImage and cropFrame, otherwise start up camera again and return
//            guard let croppedImage = croppedImage, let cropFrame = cropFrame else {
//                // TODO: Handle errors
//                print("Could not get the cropped image.")
//                startUpCamera()
//                return
//            }
//            
//            // Call delegate didAttachImage with croppedImage as image,
//            delegate.didAttachImage(image: UIImage(cgImage: croppedImage), cropFrame: cropFrame, unmodifiedImage: previewImage)
//        } else {
//            // Call delegate didAttachImage with just previewImage as image
//            delegate.didAttachImage(image: previewImage, cropFrame: nil, unmodifiedImage: nil)
//        }
//        
//        // Dismiss
//        delegate.dismiss()
////        self.dismiss(animated: true)
//    }
//    
//    func scanButtonPressed() {
////        // Ensure previewImageView can be unwrapped, otherwise return
////        guard let previewImageView = previewImageView else {
////            // TODO: Handle errors
////            return
////        }
//        
//        // Ensure previewImage can be unwrapped, otherwise return
//        guard let previewImage = previewImageView.image else {
//            // TODO: Handle errors
//            return
//        }
//        
//        // Do haptic
//        HapticHelper.doLightHaptic()
//        
//        let (croppedImage, cropFrame): (CGImage?, CGRect?) = {
//            // Get the bounds of the image view and the previewImage
//            let imageViewSize = previewImageView.bounds.size
//            let imageSize = previewImage.size
//            
//            // Calculate the scale factor and the offset
//            let widthScale = imageSize.width / imageViewSize.width
//            let heightScale = imageSize.height / imageViewSize.height
//            let scaleFactor = max(widthScale, heightScale)
//            
//            let scaledImageWidth = imageSize.width / scaleFactor
//            let scaledImageHeight = imageSize.height / scaleFactor
//            
//            let imageOffsetX = (imageViewSize.width - scaledImageWidth) / 2
//            let imageOffsetY = (imageViewSize.height - scaledImageHeight) / 2
//            
//            let cropAreaWidth = rootView.container.frame.width - rootView.cropViewLeadingConstraint.constant - rootView.cropViewTrailingConstraint.constant
//            let cropAreaHeight = rootView.container.frame.height - rootView.cropViewTopConstraint.constant - rootView.cropViewBottomConstraint.constant
//            
//            // Calculate the cropping rectangle
//            let cropFrame = CGRect(
//                x: (rootView.cropViewLeadingConstraint.constant - imageOffsetX) * scaleFactor,
//                y: (rootView.cropViewTopConstraint.constant - imageOffsetY) * scaleFactor,
//                width: cropAreaWidth * scaleFactor,
//                height: cropAreaHeight * scaleFactor
//            )
//            
//            return (previewImageView.image?.cgImage?.cropping(to: cropFrame), cropFrame)
//            //            } else {
//            //                // Simply return the image as cgImage
//            //                return previewImageView.image?.cgImage
//            //            }
//        }()
//        
//        // Unwrap croppedImage, otherwise start up camera again and return
//        guard let croppedImage = croppedImage else {
//            // TODO: Handle errors
//            print("Could not get the cropped image.")
//            startUpCamera()
//            return
//        }
//        
//        // For testing
////        previewImageView.contentMode = .scaleAspectFit
////        previewImageView.image = UIImage(cgImage: outputImage)
//        
//        // Do text recognition
//        let requestHandler = VNImageRequestHandler(cgImage: croppedImage)
//        let request = VNRecognizeTextRequest(completionHandler: { request, error in
//            guard let observations =
//                    request.results as? [VNRecognizedTextObservation] else {
//                return
//            }
//            let recognizedStrings = observations.compactMap { observation in
//                // Return the string of the top VNRecognizedText instance.
//                return observation.topCandidates(1).first?.string
//            }
//            
//            // Process the recognized strings.
//            //TODO: - Send prompt to server with prefix, "answer this question in detail" or something, or maybe just send it for now
//            var combinedStrings = ""
//            for recognizedString in recognizedStrings {
//                combinedStrings = "\(combinedStrings) \(recognizedString)"
//            }
//            
//            // If there was no text found, present an alertcontroller and allow the user to try cropping again
//            if combinedStrings == "" {
//                let ac = UIAlertController(title: "No Text Found", message: "Could not find text in the selection. Please try again.", preferredStyle: .alert)
//                ac.view.tintColor = UIColor(Colors.alertTintColor)
//                ac.addAction(UIAlertAction(title: "Done", style: .cancel))
//                self.present(ac, animated: true)
//                return
//            }
//            
//            let trimmedString = combinedStrings.trimmingCharacters(in: .whitespaces)
//            
//            if self.delegate != nil {
//                self.delegate.didGetScan(text: trimmedString)
//                self.delegate.dismiss()
////                self.dismiss(animated: true)
//            }
//        })
//        
//        request.recognitionLevel = .accurate
//        
//        do {
//            try requestHandler.perform([request])
//        } catch {
//            print("Unable to perform the requests: \(error).")
//        }
//    }
    
    func retakeButtonPressed() {
        // Camera was not enabled, so delete the picture and redo
        startUpCamera()
        deInitializeCropView()
    }
    
    func showCropViewSwitchChanged(to newValue: Bool) {
        if newValue {
            showCropView()
        } else {
            hideCropView()
        }
    }
    
}


CaptureCameraView.swift
//
//  CaptureCameraView.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 4/11/23.
//

import AVKit
import UIKit

protocol CaptureCameraViewDelegate {
    func cameraButtonPressed()
    func flashButtonPressed()
    func imageButtonPressed()
    func retakeButtonPressed()
    func showCropViewSwitchChanged(to newValue: Bool)
}

class CaptureCameraView: UIView {

    @IBOutlet weak var cameraButton: UIButton!
    @IBOutlet weak var flashButton: UIButton!
    @IBOutlet weak var pictureButton: UIButton!
    @IBOutlet weak var retakeButton: RoundedButton!
    @IBOutlet weak var container: UIView!
    @IBOutlet weak var initialImageCropZone: SillyCropView!
    
    @IBOutlet weak var tapToCaptureImageView: UIImageView!
    @IBOutlet weak var instructionsContainer: RoundedView!
    
    @IBOutlet weak var cameraButtonActivityIndicatorView: UIActivityIndicatorView!
    
    @IBOutlet weak var cropViewLeadingConstraint: NSLayoutConstraint!
    @IBOutlet weak var cropViewTrailingConstraint: NSLayoutConstraint!
    @IBOutlet weak var cropViewTopConstraint: NSLayoutConstraint!
    @IBOutlet weak var cropViewBottomConstraint: NSLayoutConstraint!
    
    @IBOutlet weak var topResizeView: RoundedView!
    @IBOutlet weak var leftResizeView: RoundedView!
    @IBOutlet weak var rightResizeView: RoundedView!
    @IBOutlet weak var bottomResizeView: RoundedView!
    
    @IBOutlet weak var topOverlay: UIView!
    @IBOutlet weak var leftOverlay: UIView!
    @IBOutlet weak var rightOverlay: UIView!
    @IBOutlet weak var bottomOverlay: UIView!
    
    @IBOutlet weak var showCropViewSwitchContainer: RoundedView!
    @IBOutlet weak var showCropViewSwitch: UISwitch!
    
    @IBOutlet weak var scanIntroText: RoundedView!
    
    let defaultOverlayOpacity = 0.4
    
    var delegate: CaptureCameraViewDelegate?
    
    @IBAction func cameraButtonPressed(_ sender: Any) {
        delegate?.cameraButtonPressed()
    }
    
    @IBAction func flashButtonPressed(_ sender: Any) {
        delegate?.flashButtonPressed()
    }
    
    @IBAction func imageButtonPressed(_ sender: Any) {
        delegate?.imageButtonPressed()
    }
    
    @IBAction func retakeButtonPressed(_ sender: Any) {
        delegate?.retakeButtonPressed()
    }
    
    
    @IBAction func showCropViewSwitchChanged(_ sender: UISwitch) {
        delegate?.showCropViewSwitchChanged(to: sender.isOn)
    }
    
}



CaptureCameraViewController.swift
//
//  CaptureCameraViewController.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 1/30/23.
//

import AVFoundation
import UIKit
import Vision

protocol CaptureCameraViewControllerDelegate: AnyObject {
    func didAttachImage(image: UIImage, cropFrame: CGRect?, unmodifiedImage: UIImage?)
//    func didGetScan(text: String)
    func dismiss()
}

class CaptureCameraViewController: UIViewController {
    
    private let CAMERA_BUTTON_PRESSED_IMAGE_NAME = Constants.ImageName.cameraButtonPressed
    private let CAMERA_BUTTON_NOT_PRESSED_IMAGE_NAME = Constants.ImageName.cameraButtonNotPressed
    private let CAMERA_BUTTON_CHECKMARK_IMAGE_NAME = Constants.ImageName.cameraButtonPressedCheckmark
    
    
    struct InitialCropViewConstraintConstants {
        let leading = 40.0
        let trailing = 40.0
        let top = 100.0
        let bottom = 274.0
    }
    
    struct ResizeRect {
        var topTouch = false
        var leftTouch = false
        var rightTouch = false
        var bottomTouch = false
        var middleTouch = false
    }
    
    let VIEW_NAME = "CaptureCameraView"
    
    let cropViewTouchMargin = 10.0
    let cropViewMinSquare = 120.0
    
//    let defaultScanButtonHeight = 52.0
//    let defaultScanButtonTopSpace = 24.0
    
    let defaultScanIntroTextAlpha = 0.4
    
    var isCropInteractive = false
    
    lazy var cameraView: UIView = UIView(frame: rootView.container.bounds)
    lazy var previewImageView: UIImageView = UIImageView(frame: rootView.container.bounds)
    var resizeRect = ResizeRect()
    
    var captureSession: AVCaptureSession?
    var videoPreviewLayer: AVCaptureVideoPreviewLayer?
    var capturePhotoOutput: AVCapturePhotoOutput?
    
    var prevZoomFactorWhenPinchEnded: CGFloat = 0.0
    
    var delegate: CaptureCameraViewControllerDelegate!
    
    var cropViewEnabledUserDefaults: Bool {
        get {
            UserDefaults.standard.bool(forKey: Constants.UserDefaults.captureCropViewEnabled)
        }
        set {
            UserDefaults.standard.set(newValue, forKey: Constants.UserDefaults.captureCropViewEnabled)
        }
    }
    
    lazy var rootView: CaptureCameraView = {
        let view = RegistryHelper.instantiateAsView(nibName: VIEW_NAME, owner: self) as! CaptureCameraView
        view.delegate = self
        return view
    }()!
    
    override func loadView() {
        view = rootView
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        deInitializeCropView()
        
        // Configure cameraView, previewImageView, and cameraButton
//        cameraView = UIView(frame: rootView.container.bounds)
        rootView.container.addSubview(cameraView)
        
        // Configure pinch to zoom on cameraView
        let pinchGestureRecognizer = UIPinchGestureRecognizer(target: self, action: #selector(didPinch))
        self.rootView.addGestureRecognizer(pinchGestureRecognizer)
        
        // Show show crop view switch
        self.rootView.showCropViewSwitchContainer.alpha = 0.8
        self.rootView.showCropViewSwitchContainer.setNeedsDisplay()
        
        // Set crop view switch initial value and run show or hide crop view methods
        self.rootView.showCropViewSwitch.setOn(cropViewEnabledUserDefaults, animated: false)
        if cropViewEnabledUserDefaults {
            showCropView()
        } else {
            hideCropView()
        }
        
//        previewImageView = UIImageView(frame: rootView.container.bounds)
        
        rootView.cameraButton.setBackgroundImage(UIImage(named: CAMERA_BUTTON_NOT_PRESSED_IMAGE_NAME), for: .normal)
        
        rootView.scanIntroText.alpha = defaultScanIntroTextAlpha
        
        startUpCamera()
    }
    
    override func viewDidLayoutSubviews() {
        cameraView.frame = rootView.container.bounds
        videoPreviewLayer?.frame = cameraView.bounds
        
        previewImageView.frame = rootView.container.bounds
    }
    
    override func viewDidAppear(_ animated: Bool) {
//        if !UserDefaults.standard.bool(forKey: Constants.UserDefaults.userDefaultNotFirstCamera) {
////            let ac = UIAlertController(title: "Important - Scan Text!", message: "Easily scan prompts, questions and more.

Works with multiple choice, true/false, and open ended question types.", preferredStyle: .alert)
//            let ac = UIAlertController(title: "*NEW* - Send Images", message: "WriteSmith Can See! Introducing GPT-4-Vision. Send an image, ask questions, and get smart human-like feedback from your personal AI tutor.", preferredStyle: .alert)
//            ac.view.tintColor = UIColor(Colors.alertTintColor)
//            ac.addAction(UIAlertAction(title: "Confirm", style: .cancel))
//            present(ac, animated: true)
//            
//            UserDefaults.standard.set(true, forKey: Constants.UserDefaults.userDefaultNotFirstCamera)
//        }
    }
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        guard isCropInteractive == true else { return }
        
        // Get touches to move that crop view!
        if let touch = touches.first {
            let touchStart = touch.location(in: view)
            
            resizeRect.topTouch = false
            resizeRect.leftTouch = false
            resizeRect.rightTouch = false
            resizeRect.bottomTouch = false
            resizeRect.middleTouch = false
            
            if touchStart.y > rootView.initialImageCropZone.frame.minY + cropViewTouchMargin * 2 && touchStart.y < rootView.initialImageCropZone.frame.maxY - cropViewTouchMargin * 2 && touchStart.x > rootView.initialImageCropZone.frame.minX + cropViewTouchMargin * 2 && touchStart.x < rootView.initialImageCropZone.frame.maxX - cropViewTouchMargin * 2 {
                resizeRect.middleTouch = true
            }
            
            if touchStart.y > rootView.initialImageCropZone.frame.maxY - cropViewTouchMargin && touchStart.y < rootView.initialImageCropZone.frame.maxY + cropViewTouchMargin {
                resizeRect.bottomTouch = true
            }
            
            if touchStart.x > rootView.initialImageCropZone.frame.maxX - cropViewTouchMargin && touchStart.x < rootView.initialImageCropZone.frame.maxX + cropViewTouchMargin {
                resizeRect.rightTouch = true
            }
            
            if touchStart.x > rootView.initialImageCropZone.frame.minX - cropViewTouchMargin && touchStart.x < rootView.initialImageCropZone.frame.minX + cropViewTouchMargin {
                resizeRect.leftTouch = true
            }
            
            if touchStart.y > rootView.initialImageCropZone.frame.minY - cropViewTouchMargin && touchStart.y < rootView.initialImageCropZone.frame.minY + cropViewTouchMargin {
                resizeRect.topTouch = true
            }
        }
    }
    
    override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
        guard isCropInteractive == true else { return }
        
        // Move that crop view!
        if let touch = touches.first {
            let currentTouchPoint = touch.location(in: view)
            let prevTouchPoint = touch.previousLocation(in: view)
            
            let deltaX = currentTouchPoint.x - prevTouchPoint.x
            let deltaY = currentTouchPoint.y - prevTouchPoint.y
            
            if resizeRect.middleTouch {
//                if rootView.cropViewTopConstraint.constant + deltaY >= 0 && rootView.cropViewLeadingConstraint.constant + deltaX >= 0 && rootView.cropViewTrailingConstraint.constant - deltaX >= 0 && rootView.cropViewBottomConstraint.constant - deltaY >= 0 {
                    rootView.cropViewTopConstraint.constant += deltaY
                    rootView.cropViewLeadingConstraint.constant += deltaX
                    rootView.cropViewTrailingConstraint.constant -= deltaX
                    rootView.cropViewBottomConstraint.constant -= deltaY
//                }
            }
            
            if resizeRect.topTouch && rootView.cropViewTopConstraint.constant + deltaY >= 0 && rootView.container.frame.height - (rootView.cropViewTopConstraint.constant + deltaY + rootView.cropViewBottomConstraint.constant) >= cropViewMinSquare {
                rootView.cropViewTopConstraint.constant += deltaY
            }
            
            if resizeRect.leftTouch && rootView.cropViewLeadingConstraint.constant + deltaX >= 0 && rootView.container.frame.width - (rootView.cropViewLeadingConstraint.constant + deltaX + rootView.cropViewTrailingConstraint.constant) >= cropViewMinSquare {
                rootView.cropViewLeadingConstraint.constant += deltaX
            }
            
            if resizeRect.rightTouch && rootView.cropViewTrailingConstraint.constant - deltaX >= 0 && rootView.container.frame.width - (rootView.cropViewLeadingConstraint.constant - deltaX + rootView.cropViewTrailingConstraint.constant) >= cropViewMinSquare {
                rootView.cropViewTrailingConstraint.constant -= deltaX
            }
            
            if resizeRect.bottomTouch && rootView.cropViewBottomConstraint.constant - deltaY >= 0 && rootView.container.frame.height - (rootView.cropViewTopConstraint.constant - deltaY + rootView.cropViewBottomConstraint.constant) >= cropViewMinSquare {
                rootView.cropViewBottomConstraint.constant -= deltaY
            }
            
            self.view.layoutIfNeeded()
        }
    }
    
    @objc func cameraButtonSelector() {
        // cameraButtonPressed already does a haptic, also this isn't even working rn lol
        
        cameraButtonPressed()
    }
    
    @objc func didPinch(_ sender: UIPinchGestureRecognizer) {
//        self.cameraView.frame.size = CGSize(width: self.cameraView.frame.size.width * sender.scale, height: self.cameraView.frame.size.height * sender.scale)
        
        if let captureDevice = AVCaptureDevice.default(for: AVMediaType.video) {
            do {
                try captureDevice.lockForConfiguration()
                
                defer {
                    captureDevice.unlockForConfiguration()
                }
                
                let zoomRange = 1...captureDevice.activeFormat.videoMaxZoomFactor
                
                let pinchScale: CGFloat = {
                    let pinchScaleWithPrevPinchScale = sender.scale * prevZoomFactorWhenPinchEnded
                    if pinchScaleWithPrevPinchScale < zoomRange.lowerBound {
                        return 1
                    } else if pinchScaleWithPrevPinchScale > zoomRange.upperBound {
                        return zoomRange.upperBound
                    } else {
                        return pinchScaleWithPrevPinchScale
                    }
                }()
                
//                let newScaleFactor = pinchScale + prevZoomFactorWhenPinchEnded
                
                switch sender.state {
                case .began: fallthrough
                case .changed: captureDevice.videoZoomFactor = pinchScale
                case .ended:
                    prevZoomFactorWhenPinchEnded = pinchScale
                    captureDevice.videoZoomFactor = prevZoomFactorWhenPinchEnded
                default: break
                }
            } catch {
                print("Error locking capture device for configuration in CaptureCameraViewController... \(error)")
            }
        }
    }
    
    public func reset() {
        // Start up camera, deinitialize crop view, and send didReset to delegate to reset the reset variable in the ViewControllerRepresentable :)
        startUpCamera()
        deInitializeCropView()
    }
    
    public func setCameraButtonActivityIndicatorViewStatus(isActive: Bool) {
        if isActive {
            self.rootView.cameraButtonActivityIndicatorView.startAnimating()
        } else {
            self.rootView.cameraButtonActivityIndicatorView.stopAnimating()
        }
    }
    
    func initializeCropView(with image: UIImage, cropFrame: CGRect?, fixOrientation: Bool, contentMode: UIView.ContentMode) {
        // Adjust the UI elements
        isCropInteractive = true
        
//        rootView.topResizeView.alpha = 1.0
//        rootView.leftResizeView.alpha = 1.0
//        rootView.rightResizeView.alpha = 1.0
//        rootView.bottomResizeView.alpha = 1.0
        
        rootView.scanIntroText.alpha = 0.0
        
        // Adjust overlay views if cropFrame is provided
        if let cropFrame = cropFrame {
            // First, set the contentMode and image for the previewImageView as usual.
            previewImageView.contentMode = contentMode
            previewImageView.image = image

            // Calculate the crop view constraints based on the cropFrame
            let imageViewSize = previewImageView.bounds.size
            let imageSize = image.size
            let widthScale = imageSize.width / imageViewSize.width
            let heightScale = imageSize.height / imageViewSize.height
            let scaleFactor = max(widthScale, heightScale)
            
            // Deriving the constraints values from the reverse operation of the cropping process.
            rootView.cropViewLeadingConstraint.constant = (cropFrame.minX / scaleFactor)
            rootView.cropViewTopConstraint.constant = (cropFrame.minY / scaleFactor)
            rootView.cropViewTrailingConstraint.constant = imageViewSize.width - (cropFrame.maxX / scaleFactor)
            rootView.cropViewBottomConstraint.constant = imageViewSize.height - (cropFrame.maxY / scaleFactor)
            
            // Ensure the constraints are updated.
            self.view.layoutIfNeeded()
        } else {
            // Use default if no specific cropping frame is provided
            rootView.cropViewTopConstraint.constant = InitialCropViewConstraintConstants().top
            rootView.cropViewLeadingConstraint.constant = InitialCropViewConstraintConstants().leading
            rootView.cropViewTrailingConstraint.constant = InitialCropViewConstraintConstants().trailing
            rootView.cropViewBottomConstraint.constant = InitialCropViewConstraintConstants().bottom
        }
        
        // Hide flash button, tap to capture image view, and instructions container and show "Retake" button
        self.rootView.flashButton.alpha = 0.0
        self.rootView.tapToCaptureImageView.alpha = 0.0
        self.rootView.instructionsContainer.alpha = 0.0
        self.rootView.retakeButton.alpha = 1.0
        
        // TODO: Should and can this be coombined into an update to the container instead?
        self.rootView.retakeButton.setNeedsDisplay()
        
//        // Show show crop view switch
//        self.rootView.showCropViewSwitchContainer.alpha = 0.8
//        self.rootView.showCropViewSwitchContainer.setNeedsDisplay()
//        })
        
        // Ensure the capture session has stopped
        captureSession?.stopRunning()
        cameraView.removeFromSuperview()
        
//        var orientation: UIImage.Orientation
        var imageToSave: UIImage
        if fixOrientation && image.imageOrientation != .up {
            // Fix the images orientation with regard to the crop
            let width = image.size.width
            let height = image.size.height
            let origin = CGPoint(x: ((height - width * 9/6))/2, y: (height - height)/2)
            let size = CGSize(width: width * 9/6, height: width)
            
            guard let imageRef = image.cgImage?.cropping(to: CGRect(origin: origin, size: size)) else {
                print("Fail to crop image")
                return
            }
            
            let imageToRotate = UIImage(cgImage: imageRef, scale: 1.0, orientation: .up)
            imageToSave = imageToRotate.rotated(radians: .pi / 2)!
        } else {
            imageToSave = image
//            orientation = .up
        }
        
        previewImageView.contentMode = contentMode
        previewImageView.image = imageToSave
        rootView.container.addSubview(previewImageView)
        
        rootView.cameraButton.setBackgroundImage(UIImage(named: CAMERA_BUTTON_CHECKMARK_IMAGE_NAME), for: .normal)
        
        // Run show or hide crop view depending on cropViewEnabledUserDefaults to show or hide the crop view's components to keep consistent with the switch's state
        if cropViewEnabledUserDefaults {
            showCropView()
        } else {
            hideCropView()
        }
    }
    
    func deInitializeCropView() {
        // Adjust the UI elements
        isCropInteractive = false
        
        rootView.topResizeView.alpha = 0.0
        rootView.leftResizeView.alpha = 0.0
        rootView.rightResizeView.alpha = 0.0
        rootView.bottomResizeView.alpha = 0.0
        
        rootView.scanIntroText.alpha = defaultScanIntroTextAlpha
        
        rootView.cropViewTopConstraint.constant = InitialCropViewConstraintConstants().top
        rootView.cropViewLeadingConstraint.constant = InitialCropViewConstraintConstants().leading
        rootView.cropViewTrailingConstraint.constant = InitialCropViewConstraintConstants().trailing
        rootView.cropViewBottomConstraint.constant = InitialCropViewConstraintConstants().bottom
        
        //TODO: - Smoother animation
        // Hide "Retake" button and show flash button, tap to capture image view, and instructions container
        self.rootView.retakeButton.alpha = 0.0
        self.rootView.tapToCaptureImageView.alpha = 1.0
        self.rootView.instructionsContainer.alpha = 1.0
        self.rootView.flashButton.alpha = 1.0
//        self.rootView.showCropViewSwitchContainer.alpha = 0.0
        self.rootView.retakeButton.setNeedsDisplay()
        self.rootView.flashButton.setNeedsDisplay()
//        self.rootView.showCropViewSwitchContainer.setNeedsDisplay()
    }
    
    func showCropView() {
        if isCropInteractive {
            // Set cropView element opacity to 1.0
            rootView.topResizeView.alpha = 1.0
            rootView.leftResizeView.alpha = 1.0
            rootView.rightResizeView.alpha = 1.0
            rootView.bottomResizeView.alpha = 1.0
            
            rootView.topOverlay.alpha = rootView.defaultOverlayOpacity
            rootView.leftOverlay.alpha = rootView.defaultOverlayOpacity
            rootView.rightOverlay.alpha = rootView.defaultOverlayOpacity
            rootView.bottomOverlay.alpha = rootView.defaultOverlayOpacity
            rootView.initialImageCropZone.alpha = 1.0
        }
        
        // Set crop view enabled in user defaults
        cropViewEnabledUserDefaults = true
        
        // Enable crop from initialImageCropZone
        rootView.initialImageCropZone.alpha = 1.0
    }
    
    func hideCropView() {
        // Set cropView element opacity to 0.0
        rootView.topResizeView.alpha = 0.0
        rootView.leftResizeView.alpha = 0.0
        rootView.rightResizeView.alpha = 0.0
        rootView.bottomResizeView.alpha = 0.0
        
        rootView.topOverlay.alpha = 0.0
        rootView.leftOverlay.alpha = 0.0
        rootView.rightOverlay.alpha = 0.0
        rootView.bottomOverlay.alpha = 0.0
        rootView.initialImageCropZone.alpha = 0.0
        
        // Set crop view not enabled in user defaults
        cropViewEnabledUserDefaults = false
        
        // Disable crop from initialImageCropZone
        rootView.initialImageCropZone.alpha = 0.0
    }
    
    func startUpCamera() {
        // Setup capture device if it can be unwrapped
        if let captureDevice = AVCaptureDevice.default(for: AVMediaType.video) {
//            captureDevice.videoZoomFactor = 2
            
            // Switch Torch Mode to Auto and Update Button Image TODO: Make this more universal lol
            do {
                try captureDevice.lockForConfiguration()
                if captureDevice.hasTorch && captureDevice.isTorchAvailable && captureDevice.isTorchModeSupported(.auto) {
                    captureDevice.torchMode = .auto
                    self.rootView.flashButton.setBackgroundImage(UIImage(systemName: "bolt.badge.automatic")!, for: .normal)
                } else {
                    self.rootView.flashButton.setBackgroundImage(UIImage(systemName: "bolt.slash")!, for: .normal)
                }
                captureDevice.unlockForConfiguration()
            } catch {
                print("Error locking capture device for configuration to change torch mode in CaptureCameraViewController... \(error)")
            }
            
            do {
                let input = try AVCaptureDeviceInput(device: captureDevice)
                captureSession = AVCaptureSession()
                captureSession?.addInput(input)
                capturePhotoOutput = AVCapturePhotoOutput()
//                capturePhotoOutput?.isHighResolutionCaptureEnabled = true
                captureSession?.addOutput(capturePhotoOutput!)
                
                videoPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession!)
                videoPreviewLayer?.videoGravity = AVLayerVideoGravity.resizeAspectFill
                videoPreviewLayer?.frame = rootView.container.layer.bounds // View or Container?
                
                cameraView.layer.addSublayer(videoPreviewLayer!)
                
            } catch {
                print(error)
                
//                dismiss(animated: true)
                // Show alert with link to settings
                let alert = UIAlertController(
                    title: "Allow Camera Access",
                    message: "Please go into Settings > StudyAI and enable Camera Access to record voice.",
                    preferredStyle: .alert)
                alert.addAction(
                    UIAlertAction(
                        title: "Close",
                        style: .cancel)
                )
                alert.addAction(
                    UIAlertAction(
                        title: "Open Settings",
                        style: .default,
                        handler: { action in
                            UIApplication.shared.open(URL(string: UIApplication.openSettingsURLString)!)
                        })
                )
                DispatchQueue.main.async {
                    self.present(alert, animated: true)
                }
                
                return
            }
        }
        
        // Start capture session
        DispatchQueue.global().async {
            self.captureSession?.startRunning()
        }
        
        // Set previewImageView
        if previewImageView != nil && previewImageView.isDescendant(of: rootView.container) {
            previewImageView.removeFromSuperview()
        }
        
        // Add cameraView to container
        rootView.container.addSubview(cameraView)
        
        // Start captureSession on background thread
        DispatchQueue.global().async {
            self.captureSession?.startRunning()
        }
        
        // Set cameraButton background image to not pressed
        rootView.cameraButton.setBackgroundImage(UIImage(named: CAMERA_BUTTON_NOT_PRESSED_IMAGE_NAME), for: .normal)
    }
    
    func cycleFlashMode() {
        if let captureDevice = AVCaptureDevice.default(for: AVMediaType.video) {
            do {
                switch captureDevice.torchMode {
                case .auto:
                    // Switch to On and Update Button Image
                    if try setFlashMode(torchMode: .on) {
                        self.rootView.flashButton.setBackgroundImage(UIImage(systemName: "bolt.fill")!, for: .normal)
                    } else {
                        self.rootView.flashButton.setBackgroundImage(UIImage(systemName: "bolt.slash")!, for: .normal)
                    }
                case .on:
                    // Switch to Off and Update Button Image
                    if try setFlashMode(torchMode: .off) {
                        self.rootView.flashButton.setBackgroundImage(UIImage(systemName: "bolt.slash")!, for: .normal)
                    } else {
                        self.rootView.flashButton.setBackgroundImage(UIImage(systemName: "bolt.slash")!, for: .normal)
                    }
                case .off:
                    // Switch to Auto and Update Button Image
                    if try setFlashMode(torchMode: .auto) {
                        self.rootView.flashButton.setBackgroundImage(UIImage(systemName: "bolt.badge.automatic")!, for: .normal)
                    } else {
                        self.rootView.flashButton.setBackgroundImage(UIImage(systemName: "bolt.slash")!, for: .normal)
                    }
                @unknown default:
                    // TODO: Handle errors if necessary
                    print("Unhandled torch mode in CaptureCameraViewController! Setting to off...")
                    if try setFlashMode(torchMode: .off) {
                        self.rootView.flashButton.setBackgroundImage(UIImage(systemName: "bolt.slash")!, for: .normal)
                    } else {
                        self.rootView.flashButton.setBackgroundImage(UIImage(systemName: "bolt.slash")!, for: .normal)
                    }
                }
            } catch {
                // TOOD: Handle errors
                print("Error locking capture device for configuration in CaptureCameraViewController... \(error)")
                self.rootView.flashButton.setBackgroundImage(UIImage(systemName: "bolt.slash")!, for: .normal)
                return
            }
        }
    }
    
    func setFlashMode(torchMode: AVCaptureDevice.TorchMode) throws -> Bool {
        if let captureDevice = AVCaptureDevice.default(for: AVMediaType.video) {
            try captureDevice.lockForConfiguration()
            
            defer {
                captureDevice.unlockForConfiguration()
            }
            
            if captureDevice.hasTorch && captureDevice.isTorchAvailable && captureDevice.isTorchModeSupported(torchMode)  {
                captureDevice.torchMode = torchMode
                
                return true
            }
        }
        
        return false
    }
    
}

extension CaptureCameraViewController: AVCapturePhotoCaptureDelegate {
    func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
        guard error == nil else {
            print("Couldn't capture phtoto: \(String(describing: error))")
            return
        }
        
        guard let imageData = photo.fileDataRepresentation() else {
            print("Failed to convert pixel buffer")
            return
        }
        
        guard let capturedImage = UIImage.init(data: imageData, scale: 1.0) else {
            print("Failed to convert image data to UIImage")
            return
        }
        
        captureSession?.stopRunning()
        cameraView.removeFromSuperview()
        
//        let width = capturedImage.size.width
//        let height = capturedImage.size.height
//        let origin = CGPoint(x: ((height - width * 9/6))/2, y: (height - height)/2)
//        let size = CGSize(width: width * 9/6, height: width)
//
//        guard let imageRef = capturedImage.cgImage?.cropping(to: CGRect(origin: origin, size: size)) else {
//            print("Fail to crop image")
//            return
//        }
//
//        let imageToSave = UIImage(cgImage: imageRef, scale: 1.0, orientation: .right)
        
        rootView.cameraButton.setBackgroundImage(UIImage(named: CAMERA_BUTTON_CHECKMARK_IMAGE_NAME), for: .normal)
        
//        // If show crop view switch is off, run attachImage
//        
//        // If show crop view switch is on run initializeCropView, otherwise run attachImage
//        if !self.rootView.showCropViewSwitch.isOn {
//            // Attach image
//            self.delegate.didAttachImage(
//                image: capturedImage,
//                cropFrame: nil,
//                unmodifiedImage: nil)
//        }
        
        // Setup Crop View
        initializeCropView(with: capturedImage, cropFrame: nil, fixOrientation: true, contentMode: .scaleAspectFill)
    }
}

extension CaptureCameraViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate {
    func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
        picker.dismiss(animated: true)
    }
    
    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
        picker.dismiss(animated: true)
        
        if let image = info[UIImagePickerController.InfoKey.originalImage] as? UIImage {
            captureSession?.stopRunning()
            cameraView.removeFromSuperview()
            
//            let width = image.size.width
//            let height = image.size.height
//            let origin = CGPoint(x: (height - height)/2, y: ((height - width * 9/6))/2)
//            let size = CGSize(width: width, height: width * 9/6)
//
//            guard let imageRef = image.cgImage?.cropping(to: CGRect(origin: origin, size: size)) else {
//                print("Fail to crop image")
//                return
//            }
//
//            let imageToSave = UIImage(cgImage: imageRef, scale: 1.0, orientation: .up)
            
            initializeCropView(with: image, cropFrame: nil, fixOrientation: true, contentMode: .scaleAspectFit)
            
            rootView.cameraButton.setBackgroundImage(UIImage(named: CAMERA_BUTTON_CHECKMARK_IMAGE_NAME), for: .normal)
        } else {
            let ac = UIAlertController(title: "Could Not Get Image", message: "There was an issue getting your image. Please try again.", preferredStyle: .alert)
            ac.view.tintColor = UIColor(Colors.alertTint)
            ac.addAction(UIAlertAction(title: "Done", style: .cancel))
            present(ac, animated: true)
        }
    }
}



CaptureChatGenerator.swift
////
////  CaptureChatGenerator.swift
////  SeeGPT
////
////  Created by Alex Coundouriotis on 3/6/24.
////
//
//import CoreData
//import Foundation
//import UIKit
//
//class CaptureChatGenerator: ObservableObject {
//    
//    @Published var isLoading: Bool = false
//    @Published var isGenerating: Bool = false
//    
//    @Published var alertShowingUserChatNotSaved = false
//    
//    var generatingChats: [Int64: String] = [:]
//    
//    
//    private let imageURLChatIndex: Int = 0
//    private let imageChatIndex: Int = 0
//    private let textChatIndex: Int = 0
//    
//    private let DEFAULT_CORE_DATA_NEW_CHAT_ID = 0 // Another approach would be setting the chatID.. but it seems to be pretty consistenlty 0 and though that's up to Apple to keep like that I feel like if it's not gonna be optional a new one will be zero ya know.. TODO: Reapproach this and maybe set initial chatIDs to a number manually, just that that adds a tiny bit of complexity so idk if I may just keep it like this
//    
////    private let ITERATIONS_PER_UPDATE = 5
//    private let UPDATES_PER_SECOND = 2
//    
//    /***
//     Generate Chat
//     
//     Takes multiple inputs and splits them into new Chats with one input per chat, then gets a Chat with the current Conversation with behavior, persistentImage, and all the new Chats
//     Okay, but instead, should I just do it all in one chat and parse it out to make it look like multiple chats in ChatView's list? I think they should be multiple chats because then the user would be able to delete an image or image url but maintain the other parts they specified in the input
//     
//     TODO: Also generate a title
//     */
//    func generateChat(input: String?, image: UIImage?, imageURL: String?, conversation: Conversation, authToken: String, isPremium: Bool, remainingUpdater: RemainingUpdater, in managedContext: NSManagedObjectContext) async throws {
//        // Ensure can generate, which is a variable
//        guard canGenerateChat(isPremium: isPremium) else {
//            return
//        }
//        
//        // Create User Image URL Chat if imageURL is not nil and User Image Chat if image is not null and User Text Chat if input is not nil and save on main queue
//        let userImageURLChat: Chat? = {
//            // Unwrap imageURL, otherwise return nil
//            guard let imageURL = imageURL else {
//                return nil
//            }
//            
//            let userImageURLChat = Chat(context: managedContext)
//            
//            // Set and save User Image URL Chat
//            userImageURLChat.imageURL = imageURL
//            userImageURLChat.sender = Sender.user.rawValue
//            userImageURLChat.date = Date()
//            userImageURLChat.conversation = conversation
//            
//            return userImageURLChat
//        }()
//        
//        let userImageChat: Chat? = {
//            // Unwrap image, otherwise return nil
//            guard let image = image else {
//                return nil
//            }
//            
//            let userImageChat = Chat(context: managedContext)
//            
//            // Set and save User Image Chat
//            userImageChat.imageData = image.pngData()
//            userImageChat.sender = Sender.user.rawValue
//            userImageChat.date = Date().advanced(by: 0.1)
//            userImageChat.conversation = conversation
//            
//            return userImageChat
//        }()
//        
//        let userTextChat: Chat? = {
//            // Unwrap input and ensure it's not empty, otherwise return nil
//            guard let input = input, !input.isEmpty else {
//                return nil
//            }
//            
//            let userTextChat = Chat(context: managedContext)
//            
//            // Set and save User Text Chat
//            userTextChat.text = input
//            userTextChat.sender = Sender.user.rawValue
//            userTextChat.date = Date().advanced(by: 0.2)
//            userTextChat.conversation = conversation
//            
//            return userTextChat
//        }()
//        
//        await MainActor.run {
//            do {
//                try managedContext.save()
//            } catch {
//                // TODO: Handle errors
//                print("Error saving userChat to CoreData in CaptureChatGenerator... \(error)")
////                throw ChatGeneratorError.addUserChat
//                self.alertShowingUserChatNotSaved = true
//            }
//        }
//        
//        // Defer setting canGenerate to true and isLoading and isGenerating to false to ensure they are set to false when this method completes
//        defer {
//            DispatchQueue.main.async {
//                self.isLoading = false
//                self.isGenerating = false
//            }
//        }
//        
//        await MainActor.run {
//            // Set isLoading to true
//            self.isLoading = true
//        }
//        
//        // Create AI chat in CoreData
//        let aiChat = Chat(context: managedContext)
//        
//        aiChat.sender = Sender.ai.rawValue
//        aiChat.conversation = conversation
//        aiChat.date = Date().advanced(by: 0.3)
//        
//        // Get selected model
//        let selectedModel = GPTModelHelper.currentChatModel
//        
//        // Get persistentImageData TODO: This just gets the first object right now if it exists, but in the future potentially expand this to have multiple persistent images, this also requires the server to do it too
//        let persistentImageData: Data? = {
//            guard let persistentImages = conversation.persistentImages else {
//                return nil
//            }
//            
//            guard let persistentImagesArray = persistentImages.allObjects as? [PersistentImage] else {
//                return nil
//            }
//            
//            if persistentImagesArray.count == 0 {
//                return nil
//            }
//            
//            return persistentImagesArray[0].image
//        }()
//        
//        // Create GetChatRequest Body Chats from the userImageURLChat, userImageChat, and userTextChat that can be unwrapped with indices in that order
//        let requestBuilder = GetChatWithPersistentImageRequest.Builder(
//            authToken: authToken,
//            behavior: nil, // TODO: Implement behavior functionality with topics
//            conversationID: conversation.conversationID,
//            usePaidModel: GPTModelTierSpecification.paidModels.contains(where: {$0 == selectedModel}),
//            persistentImageData: persistentImageData)
//        
//        if let userImageURLChat = userImageURLChat {
//            requestBuilder.addChat(
//                index: imageURLChatIndex,
//                input: userImageURLChat.text,
//                imageData: userImageURLChat.imageData,
//                imageURL: userImageURLChat.imageURL,
//                sender: Sender(rawValue: userImageURLChat.sender ?? "") ?? .user) // TODO: Is the user being the default sender here good? Should I even send to the server as Sender instead of the string?
//        }
//        
//        if let userImageChat = userImageChat {
//            requestBuilder.addChat(
//                index: imageChatIndex,
//                input: userImageChat.text,
//                imageData: userImageChat.imageData,
//                imageURL: userImageChat.imageURL,
//                sender: Sender(rawValue: userImageChat.sender ?? "") ?? .user) // TODO: Is the user being the default sender here good? Should I even send to the server as Sender instead of the string?
//        }
//        
//        if let userTextChat = userTextChat {
//            requestBuilder.addChat(
//                index: textChatIndex,
//                input: userTextChat.text,
//                imageData: userTextChat.imageData,
//                imageURL: userTextChat.imageURL,
//                sender: Sender(rawValue: userTextChat.sender ?? "") ?? .user) // TODO: Is the user being the default sender here good? Should I even hsend to the server as Sender instead of the string?
//        }
//        
//        let request = requestBuilder.build()
//        
//        // Create and unwrap requestString from JSONEncoded request, otherwise return
//        guard let requestString = String(data: try JSONEncoder().encode(request), encoding: .utf8) else {
//            // TODO: Handle errors
//            print("Could not unwrap requestString in CaptureChatGenerator!")
//            return
//        }
//        
//        // Get stream
//        let stream = ChatWithPersistentImageWebSocketConnector.getChatWithPersistentImageStream()
//        
//        // Send request TODO: Handle errors here if necessary
//        try await stream.send(.string(requestString))
////        PasteboardHelper.copy(String(data: try JSONEncoder().encode(request), encoding: .utf8)!)
//        
//        // Create firstMessage to get when the first message is processed
//        var firstMessage = true
//        
//        // Define nullEquivalentString
//        let nullEquivalentString = "null"
//        
//        // Define important variables to get during stream
//        var fullOutput: String = ""
//        var finishReason: ChatFinishReasons?
//        
//        var mostRecentUpdateTime: Date = Date()
//        
//        var tempUserImageURLChatID: Int64?
//        var tempUserImageChatID: Int64?
//        var tempUserTextChatID: Int64?
//        var tempAIChatID: Int64?
//        
//        // Stream generation, updating AI chat in managed context
//        do {
//            for try await message in stream {
//                if firstMessage {
//                    // Do light haptic
//                    HapticHelper.doSuccessHaptic()
//                    
//                    // Set isLoading to false and isGenerating to true
//                    await MainActor.run {
//                        self.isLoading = false
//                        self.isGenerating = true
//                    }
//                    
//                    firstMessage = false
//                }
//                
//                // Parse message, and if it cannot be unwrapped continue
//                guard let messageData = {
//                    switch message {
//                    case .data(let data):
//                        return data
//                    case .string(let string):
//                        return string.data(using: .utf8)
//                    @unknown default:
//                        print("Message wasn't stirng or data when parsing message stream! :O")
//                        return nil
//                    }
//                }() else {
//                    print("Could not unwrap messageData in message stream! Skipping...")
//                    continue
//                }
//                
//                // Parse message to GetChatResponse
//                let getChatResponse: GetChatResponse
//                do {
//                    getChatResponse = try JSONDecoder().decode(GetChatResponse.self, from: messageData)
//                } catch {
//                    // TODO: Handle errors
//                    print("Error decoding messageData to GetChatResponse so skipping... \(error)")
//                    
//                    // Try decoding as StatusResponse to get ResponseStatus
//                    do {
//                        let statusResponse = try JSONDecoder().decode(StatusResponse.self, from: messageData)
//                        
//                        // If success is 5, that means the AuthToken is invalid, so delete it TODO: Handle this better
//                        if statusResponse.success == 5 {
//                            try await AuthHelper.regenerate()
//                        }
//                    } catch {
//                        print("Error decoding messageData to StatusResponse... \(error)")
//                    }
//                    
//                    continue
//                }
//                
//                // Unwrap and add outputText to fullOutput
//                if let outputText = getChatResponse.body.outputText {
//                    fullOutput += outputText
//                }
//                
//                // Set finishReason
//                if let responseFinishReasonString = getChatResponse.body.finishReason {
//                    if let responseFinishReason = ChatFinishReasons(rawValue: responseFinishReasonString) {
//                        finishReason = responseFinishReason
//                    }
//                }
//                
//                // Set remaining
//                if let responseRemaining = getChatResponse.body.remaining {
//                    remainingUpdater.set(drinksRemaining: responseRemaining)
//                }
//                
//                // Set and save userImageURLChat's chatID as response userImageURLChatID if the response chatID is different than the temp one
//                if let responseInputImageURLChat = getChatResponse.body.inputChats?.first(where: {$0.index == self.imageURLChatIndex}) {
//                    if let responseInputChatIDCastInt64 = Int64(exactly: responseInputImageURLChat.chatID) {
//                        if tempUserImageURLChatID != responseInputChatIDCastInt64 {
//                            // Set userImageURLChat's chatID to response chatID
//                            userImageURLChat?.chatID = responseInputChatIDCastInt64
//                            
//                            // Save to CoreData
//                            do {
//                                try await managedContext.perform {
//                                    try managedContext.save()
//                                }
//                            } catch {
//                                // TODO: Handle errors
//                                print("Error saving to CoreData in ConversationChatGenerator... \(error)")
//                            }
//                            
//                            // Set tempUserImageURLChatID to response chatID
//                            tempUserImageURLChatID = responseInputChatIDCastInt64
//                        }
//                    }
//                }
//                
//                // Set and save userImageChat's chatID as response userImageChatID if the response's chatID is different than the temp one
//                if let responseInputImageChat = getChatResponse.body.inputChats?.first(where: {$0.index == self.imageChatIndex}) {
//                    if let responseInputChatIDCastInt64 = Int64(exactly: responseInputImageChat.chatID) {
//                        if tempUserImageChatID != responseInputChatIDCastInt64 {
//                            // Set userImageChat's chatID to response's chatID
//                            userImageChat?.chatID = responseInputChatIDCastInt64
//                            
//                            // Save to CoreData
//                            do {
//                                try await managedContext.perform {
//                                    try managedContext.save()
//                                }
//                            } catch {
//                                // TODO: Handle errors
//                                print("Error saving to CoreData in ConversationChatGenerator... \(error)")
//                            }
//                            
//                            // Set tempUserImageChatID to response chatID
//                            tempUserImageChatID = responseInputChatIDCastInt64
//                        }
//                    }
//                }
//                
//                // Set and save userTextChat's chatID as response userTextChatID if the response's chatID is different than the tmep one
//                if let responseInputTextChat = getChatResponse.body.inputChats?.first(where: {$0.index == self.textChatIndex}) {
//                    if let responseInputChatIDCastInt64 = Int64(exactly: responseInputTextChat.chatID) {
//                        if tempUserTextChatID != responseInputChatIDCastInt64 {
//                            // Set userTextChat's chatID to response's chatID
//                            userTextChat?.chatID = responseInputChatIDCastInt64
//                            
//                            // Save to CoreData
//                            do {
//                                try await managedContext.perform {
//                                    try managedContext.save()
//                                }
//                            } catch {
//                                // TODO: Handle errors
//                                print("Error saving to CoreData in ConversationChatGenerator... \(error)")
//                            }
//                            
//                            // Set tempUserTextChatID to response chatID
//                            tempUserTextChatID = responseInputChatIDCastInt64
//                        }
//                    }
//                }
//                
//                // Set and save aiChat's chatID as response outputChatID if the response's chatID is different than the temp one
//                if let outputChatID = getChatResponse.body.outputChatID, outputChatID > 0 {
//                    if let outputChatIDCastInt64 = Int64(exactly: outputChatID) {
//                        if tempAIChatID != outputChatIDCastInt64 {
//                            // Set aiChat's text to empty and chatID to response's chatID
//                            aiChat.text = ""
//                            aiChat.chatID = outputChatIDCastInt64
//                            
//                            // Save to CoreData
//                            do {
//                                try await managedContext.perform {
//                                    try managedContext.save()
//                                }
//                            } catch {
//                                // TODO: Handle errors
//                                print("Error saving to CoreData in ConversationChatGenerator... \(error)")
//                            }
//                            
//                            // Set tempAIChatID to response chatID
//                            tempAIChatID = aiChat.chatID
//                        }
//                    }
//                }
//                
//                // Set and save conversationID as response conversationID if the response's conversationID is different than the stored one
//                if let conversationID = getChatResponse.body.conversationID, conversationID > 0 {
//                    if let conversationIDCastInt64 = Int64(exactly: conversationID) {
//                        if conversation.conversationID != conversationIDCastInt64 {
//                            // Set conversationID to response's conversationID
//                            conversation.conversationID = conversationIDCastInt64
//                            
//                            // Save to CoreData
//                            do {
//                                try await managedContext.perform {
//                                    try managedContext.save()
//                                }
//                            } catch {
//                                // TODO: Handle errors
//                                print("Error saving to CoreData in ConversationChatGenerator... \(error)")
//                            }
//                        }
//                    }
//                }
//                
//                // If the aiChat has a chatID not equal to DEFAULT_CORE_DATA_NEW_CHAT_ID, set it as the key with fullOutput as the value in generatingChats
//                if Date().timeIntervalSince(mostRecentUpdateTime) >= TimeInterval(1 / UPDATES_PER_SECOND), let tempAIChatID = tempAIChatID, tempAIChatID != DEFAULT_CORE_DATA_NEW_CHAT_ID {
////                    DispatchQueue.main.async { [fullOutput] in
//                    await MainActor.run { [fullOutput] in
//                        self.generatingChats[tempAIChatID] = fullOutput
//                    }
//                    
//                    mostRecentUpdateTime = Date()
////                    }
//                }
//            }
//        } catch {
//            // TODO: Handle errors
////            print("Error getting the next message in stream in ConversationChatGenerator... \(error)")
//        }
//        
//        // Set aiChat text and remove its chatID from generatingChats on main thread
//        await MainActor.run { [fullOutput] in
//            // Set generatingChats value for aiChat's chatID key to nil
//            generatingChats[aiChat.chatID] = nil
//            
//            // Set aiChat's text as fullOutput
//            aiChat.text = fullOutput
//            
//            // Save to CoreData
//            do {
//                try managedContext.save()
//            } catch {
//                // TODO: Handle errors
//                print("Error saving to CoreData in ConversationChatGenerator... \(error)")
//            }
//        }
//        
//        // Ensure first message has been generated, otherwise return before saving context
//        guard !firstMessage else {
//            // TODO: Handle errors
//            throw ChatGeneratorError.nothingFromServer
//        }
//        
//        await MainActor.run { [finishReason] in
//            // Add additional text if finishReason is length and isPremium is false
//            if finishReason == .length && !isPremium {
//                aiChat.text? += Constants.lengthFinishReasonAdditionalText
//            }
//            
//            // Update conversation latestChatText to aiChat text if it can be unwrapped and latestChatDate to Date
//            if let aiChatText = aiChat.text {
//                conversation.latestChatText = aiChatText
//                conversation.latestChatDate = Date()
//            }
//        
//            // Save to CoreData
//            do {
//                try managedContext.save()
//            } catch {
//                // TODO: Handle errors
//                print("Error saving to CoreData in ConversationChatGenerator... \(error)")
//            }
//        }
//    }
//    
//    func canGenerateChat(isPremium: Bool) -> Bool {
//        return true
//        
//        // Can never generate if isLoading
//        if isLoading {
//            return false
//        }
//        
//        // Can not generate if isGenerating and is not isPremium
//        if isGenerating && !isPremium {
//            return false
//        }
//        
//        // All other cases can generate
//        return true
//    }
//    
//}


CaptureCameraViewControllerRepresentable.swift
//
//  CaptureCameraViewControllerRepresentable.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 10/28/23.
//

import SwiftUI

struct CaptureCameraViewControllerRepresentable: UIViewControllerRepresentable {
    

    @Binding var reset: Bool
    var withCropFrame: CGRect?
    var withImage: UIImage?
    var onAttach: (_ image: UIImage, _ cropFrame: CGRect?, _ unmodifiedImage: UIImage?)->Void
//    var onScan: (String)->Void
    
    class CaptureCameraViewControllerCoordinator: CaptureCameraViewControllerDelegate {
        
//        @Binding var isShowing: Bool
        var onAttach: (_ image: UIImage, _ cropFrame: CGRect?, _ unmodifiedImage: UIImage?)->Void
//        var onScan: (String)->Void
        
        init(onAttach: @escaping (_ image: UIImage, _ cropFrame: CGRect?, _ unmodifiedImage: UIImage?)->Void) {
//            self._isShowing = isShowing
            self.onAttach = onAttach
//            self.onScan = onScan
        }
        
        func didAttachImage(image: UIImage, cropFrame: CGRect?, unmodifiedImage: UIImage?) {
            onAttach(image, cropFrame, unmodifiedImage)
        }
        
        func dismiss() {
//            isShowing = false
        }
        
    }
    
    
    func makeUIViewController(context: Context) -> CaptureCameraViewController {
        let captureCameraViewController = CaptureCameraViewController()
        
        captureCameraViewController.delegate = context.coordinator
        
        if let withImage = withImage {
            captureCameraViewController.initializeCropView(with: withImage, cropFrame: withCropFrame, fixOrientation: false, contentMode: .scaleAspectFit)
            
            // I'm doing this here to avoid the logic in the cameraViewController itself lol
            captureCameraViewController.rootView.showCropViewSwitch.isOn = withCropFrame != nil
            captureCameraViewController.rootView.showCropViewSwitchChanged(captureCameraViewController.rootView.showCropViewSwitch)
        }
        
        return captureCameraViewController
    }
    
    func updateUIViewController(_ uiViewController: CaptureCameraViewController, context: Context) {
//        uiViewController.setCameraButtonActivityIndicatorViewStatus(isActive: isLoading)
        
        if reset {
            DispatchQueue.main.async {
                uiViewController.reset()
                
                self.reset = false
            }
        }
    }
    
    func makeCoordinator() -> CaptureCameraViewControllerCoordinator {
        CaptureCameraViewControllerCoordinator(onAttach: onAttach)
    }
    
}

#Preview {
    CaptureCameraViewControllerRepresentable(
//        isShowing: .constant(true),
//        isLoading: .constant(false),
        reset: .constant(false),
        onAttach: { image, cropRect, unmodifiedImage in
            
        })
    .ignoresSafeArea()
}



CaptureModel.swift
//
//  CaptureModel.swift
//  SeeGPT
//
//  Created by Alex Coundouriotis on 3/6/24.
//

import CoreData
import Foundation
import SwiftUI
import UIKit

class CaptureModel: ObservableObject {
    
    
    
}


CaptureView.swift
//
//  CaptureView.swift
//  SeeGPT
//
//  Created by Alex Coundouriotis on 3/5/24.
//

import AVFoundation
import Foundation
import SwiftUI

struct CaptureView: View {
    
    @StateObject var model: CaptureModel = CaptureModel()
    
    private static let initialChatText: String = "Tell me about this image."
    
    
    @EnvironmentObject private var premiumUpdater: PremiumUpdater
    @EnvironmentObject private var remainingUpdater: RemainingUpdater
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @State private var isShowingDetailView: Bool = false
    
    @State private var resetCaptureView: Bool = false
    
    var body: some View {
        ZStack {
            CaptureCameraViewControllerRepresentable(
//                isShowing: .constant(true),
//                isLoading: $captureChatGenerator.isLoading,
                reset: $resetCaptureView,
                onAttach: { image, cropFrame, unmodifiedImage in
                    
                })
//            .onReceive(captureChatGenerator.$isLoading, perform: { isLoading in
//                if isLoading {
//                    // Show detailView on receive true from isGenerating
//                    isShowingDetailView = true
//                }
//            })
        }
        .ignoresSafeArea()
        .navigationTitle("")
    }
    
}

#Preview {
    
//    TabBar()
    CaptureView()
    
}


OnlyCameraInsertPantryItemView.swift
//
//  OnlyCameraInsertPantryItemView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/23/24.
//

import SwiftUI

struct OnlyCameraInsertPantryItemView: View {
    // Shows the camera and on attach immediately parses and saves pantry items from the image
    
    @Binding var isPresented: Bool
    
    
    @Environment(\.managedObjectContext) private var viewContext
    
    
    @StateObject private var pantryItemsParser: PantryItemsParser = PantryItemsParser()
    
    
    var body: some View {
        CaptureCameraViewControllerRepresentable(
            reset: .constant(false),
            onAttach: { image, cropFrame, unmodifiedImage in
                Task {
                    do {
                        // Parse and save pantry items immediately
                        try await pantryItemsParser.parseSavePantryItems(image: image, input: nil, in: viewContext)
                        
                        // Do success haptic
                        HapticHelper.doSuccessHaptic()
                    } catch PantryItemPersistenceError.duplicatePantryItemNames(let pantryItemNames) {
                        // TODO: Show alert with duplicate pantry item names and stuff
                        
                        // Do success haptic
                        HapticHelper.doSuccessHaptic()
                    } catch {
                        // TODO: Handle Errors
                        print("Error getting pantry item text from image in InsertPantryItemView... \(error)")
                        
                        
                        HapticHelper.doWarningHaptic()
                    }
                }
                
                withAnimation {
                    isPresented = false
                }
            })
    }
    
}

#Preview {
    
    OnlyCameraInsertPantryItemView(isPresented: .constant(false))
        .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
    
}


PantryItemsContainer.swift
//
//  PantryItemsContainer.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/29/24.
//

import SwiftUI

struct PantryItemsContainer: View {
    
    @Binding var selectedItems: [PantryItem]
    @Binding var editMode: EditMode
    let showsContextMenu: Bool
    let selectionColor: PantryItemButton.SelectionColors
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @SectionedFetchRequest<String?, PantryItem>(
        sectionIdentifier: \.category,
        sortDescriptors: [
            NSSortDescriptor(keyPath: \PantryItem.category, ascending: true),
            NSSortDescriptor(keyPath: \PantryItem.name, ascending: true)
        ],
        animation: .default)
    private var sectionedPantryItems: SectionedFetchResults<String?, PantryItem>
    
    var body: some View {
        PantryItemsView(
            selectedItems: $selectedItems,
            editMode: $editMode,
            sectionedPantryItems: _sectionedPantryItems,
            showsContextMenu: showsContextMenu,
            selectionColor: selectionColor)
    }
    
}

//#Preview {
//    PantryItemsContainer()
//}


View+addToPantryPopup.swift
//
//  addToPantryPopup.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/22/24.
//

import Foundation
import SwiftUI

extension View {
    
    func addToPantryPopup(isPresented: Binding<Bool>, showCameraOnAppear: Bool) -> some View {
        self
            .clearFullScreenCover(isPresented: isPresented) {
                ScrollView {
                    InsertPantryItemViewContainer(
                        isActive: isPresented,
                        showCameraOnAppear: showCameraOnAppear)
                        .padding(24.0)
                        .background(Colors.background)
                        .cornerRadius(28.0)
                        .padding()
                }
//                VStack {
//                    Spacer()
//                    HStack {
//                        Spacer()
//                        ScrollView {
//                            InsertPantryItemView(isShowing: isPresented)
//                                .padding(24.0)
//                                .background(Colors.background)
//                                .cornerRadius(28.0)
//                        }
//                        Spacer()
//                    }
//                    Spacer()
//                }
            }
    }
    
}


PantryItemButton.swift
//
//  PantryItemButton.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/29/24.
//

import SwiftUI

struct PantryItemButton: View {
    
    let pantryItem: PantryItem
    let selectionColor: SelectionColors
    let showsContextMenu: Bool
    @Binding var selectedItems: [PantryItem]
    @Binding var editMode: EditMode
    @Binding var editingPantryItem: PantryItem?
    
    enum SelectionColors {
        case green
        case red
        
        var color: Color {
            switch self {
            case .green: Color(UIColor.systemGreen).opacity(0.4)
            case .red: Color(UIColor.systemRed).opacity(0.4)
            }
        }
    }
    
    @Environment(\.managedObjectContext) private var viewContext
    
    var body: some View {
        KeyboardDismissingButton(action: {
            HapticHelper.doLightHaptic()
            
            if editMode == .active {
                // Delete if editing
                Task {
                    do {
                        try await PantryItemCDClient.deletePantryItem(pantryItem, in: viewContext)
                    } catch {
                        // TODO: Handle Errors
                        print("Error deleting pantry item in PantryView... \(error)")
                    }
                }
            } else {
                // Add to selectedItems if not editing
                if selectedItems.contains(pantryItem) {
                    withAnimation(.bouncy(duration: 0.5)) {
                        selectedItems.removeAll(where: {$0 == pantryItem})
                    }
                } else {
                    withAnimation(.bouncy(duration: 0.5)) {
                        selectedItems.append(pantryItem)
                    }
                }
            }
        }) {
            HStack {
                PantryItemView(pantryItem: pantryItem)
                .frame(maxHeight: .infinity)
                
                if editMode == .active {
                    Image(systemName: "xmark")
                        .imageScale(.small)
                        .foregroundStyle(Color(UIColor.systemRed))
                }
            }
        }
        .padding([.top, .bottom], 8)
        .padding([.leading, .trailing], 16)
        .background(selectedItems.contains(pantryItem) && editMode != .active ? selectionColor.color : .clear)
        .background(Colors.foreground)
        .clipShape(RoundedRectangle(cornerRadius: 14.0))
        .contextMenu {
            if showsContextMenu {
                // TODO: Impelment context menu
                Button("Edit", systemImage: "pencil") {
                    editingPantryItem = pantryItem
                }
                
                Divider()
                
                Button("Delete", systemImage: "trash", role: .destructive) {
                    Task {
                        do {
                            try await PantryItemCDClient.deletePantryItem(pantryItem, in: viewContext)
                        } catch {
                            // TODO: Handle Errors
                            print("Error deleting pantry item in PantryView... \(error)")
                        }
                    }
                }
            }
        }
    }
    
}

//#Preview {
//    PantryItemButton()
//}


PantrySelectionMiniView.swift
//
//  PantrySelectionMiniView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/22/23.
//

import SwiftUI

struct PantrySelectionMiniView: View {
    
    @Binding var selectedPantryItems: [PantryItem]
    @State var showsAdvancedOptions: Bool = true
    @Binding var generationAdditionalOptions: RecipeGenerationAdditionalOptions
    @State var axis: Axis = .vertical
    
    
    @Namespace private var namespace
    
    @Environment(\.managedObjectContext) var viewContext
    
    @FetchRequest(sortDescriptors: [NSSortDescriptor(keyPath: \PantryItem.name, ascending: false)], animation: .default) private var pantryItems: FetchedResults<PantryItem>
    
    @State private var isDisplayingAdvancedOptions: Bool = false
    
    @State private var isShowingPantrySelectionView: Bool = false
    
    @State private var deselectedPantryItems: [PantryItem] = []
    
    
    var body: some View {
        VStack {
            KeyboardDismissingButton(action: {
                HapticHelper.doLightHaptic()
                
                //                    withAnimation(.easeInOut(duration: 0.1)) {
                //                        isPantryShowing = true
                //                    }
                withAnimation {
                    isShowingPantrySelectionView = true
                }
            }) {
                Text("+ Add from Pantry")
                    .font(.custom(Constants.FontName.heavy, size: 14.0))
                    .padding([.leading, .trailing], 16)
                    .padding([.top, .bottom], 8)
                    .foregroundStyle(Colors.elementBackground)
                    .background(Colors.foreground)
                    .clipShape(RoundedRectangle(cornerRadius: 14.0))
                Spacer()
            }
            .padding([.leading, .trailing])
            
            if !selectedPantryItems.isEmpty || !deselectedPantryItems.isEmpty {
                VStack {
                    if axis == .vertical {
                        GeometryReader { geo in
                            VStack(alignment: .leading) {
                                FlexibleView(availableWidth: geo.size.width, data: selectedPantryItems + deselectedPantryItems, spacing: 8.0, alignment: .leading) { selectedPantryItem in
                                    pantryItemButton(for: selectedPantryItem)
                                }
                                .padding([.leading, .trailing])
                                
                                selectionButtons
                            }
                        }
                    } else {
                        VStack {
                            ScrollView(.horizontal) {
                                HStack {
                                    ForEach(selectedPantryItems + deselectedPantryItems) { selectedPantryItem in
                                        pantryItemButton(for: selectedPantryItem)
                                    }
                                }
                                .padding([.leading, .trailing])
                            }
                            .scrollIndicators(.never)
                            
                            selectionButtons
                        }
                    }
                    
                }
            }
        }
        .sheet(isPresented: $isShowingPantrySelectionView) {
            // TODO: Is the next button logic here fine?
            PantryItemsContainer(
                selectedItems: $selectedPantryItems,
                editMode: .constant(.inactive),
                showsContextMenu: true,
                selectionColor: .green)
            .chefAppHeader(
                showsDivider: true,
                left: {
                    
                },
                right: {
                    Button(action: {
                        isShowingPantrySelectionView = false
                    }) {
                        Text("Done")
                            .font(.custom(Constants.FontName.heavy, size: 17.0))
                            .padding(8)
                    }
                })
//            PantryView(
//                selectedItems: $selectedPantryItems,
//                multipleSelection: true,
//                isActive: $isShowingPantrySelectionView,
//                shouldShowEntryView: .constant(false))
            .background(Colors.background)
            .ignoresSafeArea()
        }
    }
    
    
    var selectionButtons: some View {
        PantryRecipeGenerationAdvancedOptionsView(
            isDisplayingAdvancedOptions: $isDisplayingAdvancedOptions,
            generationAdditionalOptions: $generationAdditionalOptions)
    }
    
    
    func pantryItemButton(for selectedPantryItem: PantryItem) -> some View {
        KeyboardDismissingButton(action: {
            HapticHelper.doLightHaptic()
            
            // TODO: Turn green and add to generate list or something when tapped
            if !selectedPantryItems.contains(where: {$0 == selectedPantryItem}) {
                withAnimation(.bouncy) {
                    selectedPantryItems.append(selectedPantryItem)
                    deselectedPantryItems.removeAll(where: {$0 == selectedPantryItem})
                }
            } else {
                withAnimation(.bouncy) {
                    selectedPantryItems.removeAll(where: {$0 == selectedPantryItem})
                    
                    if !deselectedPantryItems.contains(selectedPantryItem) {
                        deselectedPantryItems.append(selectedPantryItem)
                    }
                }
            }
        }) {
            PantryItemView(pantryItem: selectedPantryItem)
                .frame(maxHeight: .infinity)
        }
        .padding([.top, .bottom], 8)
        .padding([.leading, .trailing], 16)
        .background(
            selectedPantryItems.contains(where: {$0 == selectedPantryItem})
            ?
            Color(uiColor: .systemGreen).opacity(0.4)
            :
                Colors.foreground
        )
        .cornerRadius(14.0)
    }
    
    
}

#Preview {
    PantrySelectionMiniView(
        selectedPantryItems: .constant([]),
        generationAdditionalOptions: .constant(.normal))
        .background(Colors.background)
        .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
}


EditPantryItemView.swift
//
//  EditPantryItemView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/29/23.
//

import SwiftUI

struct EditPantryItemView: View {
    
    @State var pantryItem: PantryItem
    @Binding var isActive: Bool
//    @Binding var alertShowingHasChanges: Bool
    
    
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.colorScheme) private var colorScheme
    
    @State private var isSaving: Bool = false
    
    @State private var updatedNameText: String = ""
    @State private var updatedCategoryText: String = ""
//    @State private var updatedAmountText: String = ""
//    @State private var updatedExpirationDate: Date = Date()
    
    @State private var alertShowingEmptyNameField: Bool = false
    @State private var alertShowingErrorSaving: Bool = false
    @State private var alertShowingShouldSave: Bool = false
    @State private var alertShowingDeleteItem: Bool = false
    @State private var alertShowingDuplicateItem: Bool = false
    
//    init(pantryItem: PantryItem, isActive: Binding<Bool>) {
//        self._item = StateObject(wrappedValue: pantryItem)
//        self._isActive = isActive
//        
//        self.originalNameText = pantryItem.name ?? ""
//        self.originalCategoryText = pantryItem.category ?? ""
//    }
    
    var body: some View {
        ZStack {
            VStack {
                header
                    .padding(.bottom, 8)
                
                nameView
                    .padding(.bottom, 8)
                
                categoryView
                    .padding(.bottom, 8)
                
//                amountView
//                    .padding(.bottom, 8)
//                
//                expirationDateView
//                    .padding(.bottom, 8)
                
                HStack {
                    Button(action: {
                        HapticHelper.doWarningHaptic()
                        
                        alertShowingDeleteItem = true
                    }) {
                        Image(systemName: "trash")
                            .aspectRatio(contentMode: .fit)
                            .foregroundStyle(Color(uiColor: .systemRed))
                            .padding()
                            .background(RoundedRectangle(cornerRadius: 20.0)
                                .stroke(lineWidth: 2.0)
                                .tint(Color(uiColor: .systemRed)))
                    }
                    .opacity(isSaving ? 0.4 : 1.0)
                    .disabled(isSaving)
                    
                    Button(action: {
                        HapticHelper.doSuccessHaptic()
                        
                        saveAndDismissEditing()
                    }) {
                        HStack {
                            Spacer()
                            Text("Save")
                                .foregroundStyle(Colors.elementText)
                            Spacer()
                        }
                        .padding()
                        .background(Colors.elementBackground)
                        .clipShape(RoundedRectangle(cornerRadius: 20.0))
                    }
                    .opacity(isSaving ? 0.4 : 1.0)
                    .disabled(isSaving)
                }
            }
        }
        .onAppear {
            // Update name, category, amount, and expiration date initial values from pantryItem
            if let name = pantryItem.name {
                updatedNameText = name
            }
            
            if let category = pantryItem.category {
                updatedCategoryText = category
            }
            
//            if let amount = pantryItem.amount {
//                updatedAmountText = amount
//            }
//            
//            if let expirationDate = pantryItem.expiration {
//                updatedExpirationDate = expirationDate
//            }
        }
        .alert("Missing Name", isPresented: $alertShowingEmptyNameField) {
            Button("Close", action: {
                
            })
        } message: {
            Text("Please make sure there the pantry item has at least a name.")
        }
        .alert("Delete Item", isPresented: $alertShowingDeleteItem, actions: {
            Button("Cancel", role: .cancel, action: {
                
            })
            
            Button("Delete", role: .destructive, action: {
                deleteAndDismissEditing()
            })
        }, message: {
            Text("Are you sure you want to delete this item?")
        })
        .alert("Duplicate Item", isPresented: $alertShowingDuplicateItem, actions: {
            Button("Close", role: .cancel, action: {
                
            })
        }, message: {
            Text("You have an item with this title already. Please choose a new title.")
        })
    }
    
    var header: some View {
        HStack {
            Text("Edit Item")
                .font(.custom(Constants.FontName.black, size: 28.0))
                .foregroundStyle(Colors.foregroundText)
            Spacer()
            Button(action: {
                HapticHelper.doLightHaptic()
                
                withAnimation {
                    isActive = false
                }
            }) {
                Text(Image(systemName: "xmark"))
                    .font(.custom(Constants.FontName.black, size: 24.0))
                    .foregroundStyle(Colors.foregroundText)
            }
        }
    }
    
    var nameView: some View {
        VStack {
            HStack {
                Text("Title*:")
                    .font(.custom(Constants.FontName.body, size: 17.0))
                Spacer()
            }
            .frame(minHeight: 0)
            
            TextField(
                text: $updatedNameText,
                prompt: Text(pantryItem.name ?? "Title")) {}
                .textFieldTickerTint(colorScheme == .light ? Colors.elementBackground : Colors.foregroundText)
                .keyboardDismissingTextFieldToolbar("Done", color: Colors.elementBackground)
                .padding([.leading, .trailing])
                .padding([.top, .bottom], 8)
                .background(Colors.foreground)
                .clipShape(RoundedRectangle(cornerRadius: 14.0))
        }
    }
    
    var categoryView: some View {
        VStack {
            // TODO: Should categories be able to be updated with the keyboard? Probably not, so pull in the categories and put it in a selector or something for the user to pick
            HStack {
                Text("Category:")
                    .font(.custom(Constants.FontName.body, size: 17.0))
                Text("(Optional)")
                    .font(.custom(Constants.FontName.lightOblique, size: 14.0))
                Spacer()
            }
            .frame(minHeight: 0)
            
            TextField(
                text: $updatedCategoryText,
                prompt: Text(pantryItem.category ?? "Category Name")) {}
                .textFieldTickerTint(colorScheme == .light ? Colors.elementBackground : Colors.foregroundText)
                .keyboardDismissingTextFieldToolbar("Done", color: Colors.elementBackground)
                .padding([.leading, .trailing])
                .padding([.top, .bottom], 8)
                .background(Colors.foreground)
                .clipShape(RoundedRectangle(cornerRadius: 14.0))
        }
    }
    
//    var amountView: some View {
//        // TODO: This should be a picker with all the categories listed so that the user can pick from the categories
//        VStack {
//            HStack {
//                Text("Amount:")
//                    .font(.custom(Constants.FontName.body, size: 17.0))
//                Text("(Optional)")
//                    .font(.custom(Constants.FontName.lightOblique, size: 14.0))
//                Spacer()
//            }
//            .frame(minHeight: 0)
//            
//            TextField(
//                text: $updatedAmountText,
//                prompt: Text("Amount of Item")) {}
//                .textFieldTickerTint(colorScheme == .light ? Colors.elementBackground : Colors.foregroundText)
//                .keyboardDismissingTextFieldToolbar("Done", color: Colors.elementBackground)
//                .font(.custom(Constants.FontName.body, size: 14.0))
//                .padding([.leading, .trailing])
//                .padding([.top, .bottom], 8)
//                .background(Colors.foreground)
//                .clipShape(RoundedRectangle(cornerRadius: 14.0))
//            
//            HStack {
//                Text("The amount you have of this item. ex. 2, 3 ml, 5 oz, etc.") // TODO: This should be a picker! Also this text should be changed for the picker potentially
//                    .multilineTextAlignment(.leading)
//                    .font(.custom(Constants.FontName.body, size: 12.0))
//                    .foregroundStyle(Colors.foregroundText)
//                    .opacity(0.6)
//                Spacer()
//            }
//        }
//    }
//    
//    var expirationDateView: some View {
//        VStack {
//            HStack {
//                Text("Expiration Date:")
//                    .font(.custom(Constants.FontName.body, size: 17.0))
//                Text("(Optional)")
//                    .font(.custom(Constants.FontName.lightOblique, size: 14.0))
//                Spacer()
//            }
//            .frame(minHeight: 0)
//            
//            DatePicker("Select Expiration Date", selection: $updatedExpirationDate, displayedComponents: [.date] )
//                .datePickerStyle(WheelDatePickerStyle())
//                .frame(height: 80.0)
//                .padding()
//            
//            HStack {
//                Text("The amount you have of this pantryItem. ex. 2, 3 ml, 5 oz, etc.") // TODO: This should be a picker! Also this text should be changed for the picker potentially
//                    .multilineTextAlignment(.leading)
//                    .font(.custom(Constants.FontName.body, size: 12.0))
//                    .foregroundStyle(Colors.foregroundText)
//                    .opacity(0.6)
//                Spacer()
//            }
//        }
//    }
    
    func deleteAndDismissEditing() {
        viewContext.delete(pantryItem)
        
        saveAndDismissEditing()
    }
    
    func discardAndDismissEditing() {
        viewContext.rollback()
        
        withAnimation {
            isActive = false
        }
    }
    
    func saveAndDismissEditing() {
        guard !updatedNameText.isEmpty else {
            alertShowingEmptyNameField = true
            return
        }
        
        Task {
            // Check for duplicates
            let fetchRequest = PantryItem.fetchRequest()
            fetchRequest.predicate = NSPredicate(format: "%K = %@", #keyPath(PantryItem.name), updatedNameText)
            guard try await CDClient.count(fetchRequest: fetchRequest, in: viewContext) <= 1 else {
                // TODO: Handle errors for duplication!
                print("Duplicate found and not saved in appendPantryItem!")
                await MainActor.run {
                    alertShowingDuplicateItem = true
                }
                return
            }
            
            // Update pantryItem values and save and set isActive to false
            do {
                try await viewContext.perform {
                    pantryItem.name = updatedNameText
                    pantryItem.category = updatedCategoryText
//                    pantryItem.amount = updatedAmountText
//                    pantryItem.expiration = updatedExpirationDate
                    
                    pantryItem.updateDate = Date()
                    
                    try viewContext.save()
                }
                
                withAnimation {
                    isActive = false
                }
            } catch {
                // TODO: Handle errors
                print("Error saving and setting values in PantryItemsListRowView... \(error)")
                await MainActor.run {
                    alertShowingErrorSaving = true
                }
            }
        }
    }
    
    func setAndSaveValues() throws {
        
        try viewContext.save()
    }
    
    
}

extension View {
    
    func editPantryItemPopup(isPresented: Binding<Bool>, pantryItem: PantryItem) -> some View {
        self
            .clearFullScreenCover(isPresented: isPresented) {
                EditPantryItemView(pantryItem: pantryItem, isActive: isPresented)
                    .padding()
                    .background(Colors.foreground)
                    .clipShape(RoundedRectangle(cornerRadius: 14.0))
                    .padding()
            }
    }
    
    func editPantryItemPopup(pantryItem: Binding<PantryItem?>) -> some View {
        var isPresented: Binding<Bool> {
            Binding(
                get: {
                    pantryItem.wrappedValue != nil
                },
                set: { value in
                    if !value {
                        pantryItem.wrappedValue = nil
                    }
                })
        }
        
        return self
            .clearFullScreenCover(isPresented: isPresented) {
                if let pantryItemWrappedValue = pantryItem.wrappedValue {
                    EditPantryItemView(pantryItem: pantryItemWrappedValue, isActive: isPresented)
                        .padding()
                        .background(Colors.foreground)
                        .clipShape(RoundedRectangle(cornerRadius: 14.0))
                        .padding()
                }
            }
    }
    
}

@available(iOS 17, *)
#Preview(traits: .sizeThatFitsLayout) {
    let pantryItem = PantryItem(context: CDClient.mainManagedObjectContext)
    
    pantryItem.name = "adsfasdf"
    pantryItem.category = "there should be better categories maybe an enum lol"
    
    try! CDClient.mainManagedObjectContext.save()
    
    return EditPantryItemView(
        pantryItem: pantryItem,
        isActive: .constant(true))
        .padding()
        .background(Colors.foreground)
        .clipShape(RoundedRectangle(cornerRadius: 28.0))
        .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
        .environmentObject(PremiumUpdater())
        .environmentObject(ProductUpdater())
        .environmentObject(RemainingUpdater())
}


EasyPantryUpdateContainer.swift
//
//  EasyPantryUpdateContainer.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/29/24.
//

import SwiftUI

struct EasyPantryUpdateContainer: View {
    
    let onClose: () -> Void
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @EnvironmentObject private var constantsUpdater: ConstantsUpdater
    
    @State private var selectedItems: [PantryItem] = []
    
//    private var selectedOlderThanDay: Binding<Int> {
//        Binding(
//            get: {
//                constantsHelper.easyPantryUpdateContainerOlderThanDays
//            },
//            set: { value in
//                ConstantsHelper.easyPantryUpdateContainerOlderThanDays = value
//            })
//    }
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading) {
                Text("Remove Old Items...")
                    .font(.custom(Constants.FontName.heavy, size: 24.0))
                    .padding(.horizontal)
                HStack {
                    Text("Showing items older than")
                        .font(.custom(Constants.FontName.body, size: 14.0))
                    Menu(content: {
                        ForEach(0...11, id: \.self) { index in
                            Button(action: {
                                // Reset selectedItems
                                selectedItems = []
                                
                                // Set older than days
                                constantsUpdater.easyPantryUpdateContainerOlderThanDays = index
                            }) {
                                Text("\(index) days")
//                                    .tag(index)
//                                    .font(.largeTitle)
                            }
                        }
                    }) {
                        HStack {
                            Text("\(constantsUpdater.easyPantryUpdateContainerOlderThanDays) days")
                                .font(.custom(Constants.FontName.heavy, size: 14.0))
                                .underline()
                            
                            Image(systemName: "chevron.up.chevron.down")
                        }
                        .foregroundStyle(Colors.elementBackground)
                    }
                }
                .padding(.horizontal)
                
                EasyPantryUpdateView(
                    olderThanDays: constantsUpdater.easyPantryUpdateContainerOlderThanDays,
                    onClose: onClose,
                    selectedItems: $selectedItems,
                    beforeDaysAgoDateSectionedPantryItems: SectionedFetchRequest<String?, PantryItem>(
                        sectionIdentifier: \.daysAgoString,
                        sortDescriptors: [
                            NSSortDescriptor(keyPath: \PantryItem.updateDate, ascending: true),
                            NSSortDescriptor(keyPath: \PantryItem.name, ascending: true)
                        ],
                        predicate: NSPredicate(format: "%K <= %@", #keyPath(PantryItem.updateDate), Calendar.current.date(byAdding: .day, value: -constantsUpdater.easyPantryUpdateContainerOlderThanDays, to: Date())! as NSDate),
                        animation: .default))
                
                Spacer()
            }
            .padding()
        }
        .background(Colors.background)
    }
}

extension View {
    
    func easyPantryUpdateContainerPopup(isPresented: Binding<Bool>) -> some View {
        self
            .fullScreenCover(isPresented: isPresented) {
                NavigationStack {
                    EasyPantryUpdateContainer(onClose: {
                        isPresented.wrappedValue = false
                    })
                }
            }
    }
    
}

#Preview {
    
    NavigationStack {
        EasyPantryUpdateContainer(onClose: {
            
        })
    }
    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
    .environmentObject(ConstantsUpdater())
    
}


PantryItemsCategorizer.swift
//
//  PantryItemsCategorizer.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/22/24.
//

import CoreData
import Foundation

class PantryItemsCategorizer: ObservableObject {
    
    @Published var isLoading: Bool = false
    
    
    func categorizePantryItems(in managedContext: NSManagedObjectContext) async throws {
        // Defer setting isLoading to false
        defer {
            DispatchQueue.main.async {
                self.isLoading = false
            }
        }
        
        // Set isLoading to true
        await MainActor.run {
            isLoading = true
        }
        
        // Get authToken with AuthHelper ensure
        let authToken: String
        do {
            authToken = try await AuthHelper.ensure()
        } catch {
            // TODO: Handle errors
            print("Error ensuring authToken when creating Recipe in RecipeGenerator... \(error)")
            throw GenerationError.auth
        }
        
        // Categorize save update all pantry items
        try await ChefAppNetworkPersistenceManager.categorizeSaveUpdateAllPantryItems(authToken: authToken, in: managedContext)
    }
    
}


PantryView.swift
//
//  PantryView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/30/23.
//

import SwiftUI

struct PantryView: View {
    
//    @Binding var selectedItems: [PantryItem]
//    let multipleSelection: Bool = true
//    @Binding var isActive: Bool
//    let showsEditButton: Bool = false
//    @Binding var shouldShowEntryView: Bool
    
    @Binding var selectedItems: [PantryItem]
//    var multipleSelection: Bool = true
    var showsEditButton: Bool = false
    let onDismiss: () -> Void
    var onCreateRecipe: (() -> Void)? = nil
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @StateObject private var pantryItemsCategorizer: PantryItemsCategorizer = PantryItemsCategorizer()
    
    @State private var isShowingAddPantryItemView: Bool = false
    
    @State private var editMode = EditMode.inactive
    
    
    var body: some View {
        ZStack {
            ZStack {
                VStack {
                    filterSelection
                    
                    ScrollView {
                        Spacer(minLength: 28.0)
                        
                        HStack {
                            refreshPantryCategoriesButton
                            
                            addPantryItemsButton
                        }
                        .padding([.leading, .trailing])
                        
                        if !selectedItems.isEmpty {
                            if onCreateRecipe != nil {
                                Button(action: {
                                    HapticHelper.doLightHaptic()
                                    
                                    withAnimation {
                                        onCreateRecipe?()
                                    }
                                }) {
                                    ZStack {
                                        Text("Create Recipe")
                                            .font(.custom(Constants.FontName.heavy, size: 20.0))
                                        
                                        HStack {
                                            Spacer()
                                            Image(systemName: "chevron.right")
                                                .imageScale(.medium)
                                        }
                                    }
                                    .foregroundStyle(Colors.elementText)
                                    .padding()
                                    .background(Colors.elementBackground)
                                    .clipShape(RoundedRectangle(cornerRadius: 14.0))
                                }
                                .buttonStyle(.plain)
                                .padding([.leading, .trailing])
                            }
                        }
                        
                        HStack {
                            PantryItemsContainer(
                                selectedItems: $selectedItems,
                                editMode: $editMode,
                                showsContextMenu: true,
                                selectionColor: .green)
                            //                                .fixedSize(horizontal: true, vertical: false) // TODO: Fix this so that it expands properly and stuff
                            
                            Spacer()
                        }
                        
                        Spacer(minLength: 80.0)
                    }
                }
            }
        }
        .navigationBarTitleDisplayMode(.inline)
        .toolbarBackground(Colors.background, for: .navigationBar)
        .toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button(action: {
                    HapticHelper.doLightHaptic()
                    
                    withAnimation {
                        onDismiss()
                    }
                }) {
                    Text("Close")
                        .font(.custom(Constants.FontName.black, size: 20.0))
                        .foregroundStyle(Colors.elementBackground)
                }
            }
            
            ToolbarItem(placement: .topBarTrailing) {
                Button(action: {
                    HapticHelper.doLightHaptic()
                    
                    withAnimation {
                        if editMode == .active {
                            editMode = .inactive
                        } else {
                            editMode = .active
                        }
                    }
                }) {
                    Text(editMode == .active ? "\(Image(systemName: "checkmark")) Done" : "\(Image(systemName: "pencil.line")) Edit")
                        .font(.custom(Constants.FontName.black, size: 20.0))
                        .foregroundStyle(Colors.elementBackground)
                }
            }
        }
        .navigationTitle("Pantry")
//        .chefAppHeader(
//            showsDivider: true,
//            left: {
//                Button(action: {
//                    HapticHelper.doLightHaptic()
//                    
//                    withAnimation {
//                        onDismiss()
//                    }
//                }) {
//                    Text("Close")
//                        .font(.custom(Constants.FontName.black, size: 20.0))
//                        .foregroundStyle(Colors.elementText)
//                        .padding([.leading, .trailing])
//                        .padding(.bottom, 10)
//                }
//            },
//            right: {
//                Button(action: {
//                    HapticHelper.doLightHaptic()
//                    
//                    withAnimation {
//                        if editMode == .active {
//                            editMode = .inactive
//                        } else {
//                            editMode = .active
//                        }
//                    }
//                }) {
//                    Text(editMode == .active ? "\(Image(systemName: "checkmark")) Done" : "\(Image(systemName: "pencil.line")) Edit")
//                        .font(.custom(Constants.FontName.black, size: 20.0))
//                        .foregroundStyle(Colors.elementText)
//                        .padding([.leading, .trailing])
//                        .padding(.bottom, 10)
//                }
//            })
        .environment(\.editMode, $editMode)
//        .ignoresSafeArea()
        // InsertPantryItemView popup
        .addToPantryPopup(isPresented: $isShowingAddPantryItemView, showCameraOnAppear: false)
    }
    
    var filterSelection: some View {
        HStack {
            
        }
    }
    
    var addPantryItemsButton: some View {
        Button(action: {
            HapticHelper.doLightHaptic()
            
            withAnimation {
                isShowingAddPantryItemView = true
            }
        }) {
            HStack {
                Spacer()
                Text("\(Image(systemName: "plus")) Add")
                    .font(.custom(Constants.FontName.heavy, size: 17.0))
                    .foregroundStyle(Colors.elementBackground)
                Spacer()
            }
            .padding()
            .background(Colors.foreground)
            .clipShape(RoundedRectangle(cornerRadius: 14.0))
        }
        .buttonStyle(.plain)
    }
    
    var refreshPantryCategoriesButton: some View {
        Button(action: {
            HapticHelper.doLightHaptic()
            
            Task {
                do {
                    try await pantryItemsCategorizer.categorizePantryItems(in: viewContext)
                } catch {
                    // TODO: Handle Errors
                    print("Error categorizing pantry items with PantryItemsCategorizer in PantryView... \(error)")
                }
            }
        }) {
            HStack {
                Spacer()
                
                Text("\(Image(systemName: "arrow.triangle.2.circlepath")) Re-Sort")
                    .font(.custom(Constants.FontName.body, size: 17.0))
                    .foregroundStyle(Colors.elementBackground)
                
                Spacer()
                
                if pantryItemsCategorizer.isLoading {
                    ProgressView()
                        .tint(.black)
                }
            }
            .padding()
            .background(Colors.foreground)
            .clipShape(RoundedRectangle(cornerRadius: 14.0))
            .opacity(pantryItemsCategorizer.isLoading ? 0.4 : 1.0)
            .disabled(pantryItemsCategorizer.isLoading)
        }
        .buttonStyle(.plain)
    }
    
}

#Preview {
    struct TestContentView: View {
        
        @State var selectedItems: [PantryItem] = []
        @State var pantrySelectionViewIsActive: Bool = true
        
        var body: some View {
            ZStack {
//                CircleBackgroundView.standard()
                Colors.background
                if pantrySelectionViewIsActive {
                    NavigationStack {
                        PantryView(
                            selectedItems: $selectedItems,
                            //                        multipleSelection: true,
                            showsEditButton: true,
                            onDismiss: {
                                
                            },
                            onCreateRecipe: {
                                
                            })
                    }
                    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
                    .background(Material.thin)
                } else {
                    Button("activate", action: {
                        pantrySelectionViewIsActive = true
                    })
                }
            }
        }
        
    }
    
    return VStack {
        
    }
    .fullScreenCover(isPresented: .constant(true), content: {
        NavigationStack {
            TestContentView()
        }
    })
}


PantryItemsView.swift
//
//  PantryItemsView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/29/24.
//

import SwiftUI

struct PantryItemsView: View {
    
    @Binding var selectedItems: [PantryItem]
    @Binding var editMode: EditMode
    @SectionedFetchRequest var sectionedPantryItems: SectionedFetchResults<String?, PantryItem>
    let showsContextMenu: Bool
    let selectionColor: PantryItemButton.SelectionColors
    
    
    enum TypeSections: String {
        case alcoholTypeSectioned = "Type"
    }
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @State private var editingPantryItem: PantryItem?
    
    @State private var typeSectionFilter: TypeSections = .alcoholTypeSectioned
    
    private var selectButtonShouldSelectAll: Bool {
        switch typeSectionFilter {
        case .alcoholTypeSectioned:
            selectedItems.count < sectionedPantryItems.count
        }
    }
    
    private var allPantryItemsBasedOnTypeSectionFilter: SectionedFetchResults<String?, PantryItem> {
        switch typeSectionFilter {
        case .alcoholTypeSectioned:
            sectionedPantryItems
        }
    }
    
    var body: some View {
        list
            .editPantryItemPopup(pantryItem: $editingPantryItem)
    }
    
    var list: some View {
        SingleAxisGeometryReader(axis: .horizontal) { geo in
//        GeometryReader { geo in
            VStack(alignment: .leading) {
                ForEach(sectionedPantryItems) { pantryItems in
                    HStack {
                        Group {
                            if let id = pantryItems.id {
                                Text(id)
                            } else {
                                VStack(alignment: .leading) {
                                    Text("Not Sorted")
                                    Text("Re-Sort to group in categories.")
                                        .font(.custom(Constants.FontName.body, size: 12.0))
                                }
                            }
                        }
                        .font(.custom(Constants.FontName.black, size: 20.0))
                        .foregroundStyle(Colors.foregroundText)
                        .padding([.leading, .trailing])
                        
                        Spacer()
                    }
                    
                    // TODO: It looks like this is not extending to the width of the view or something
                    FlexibleView(availableWidth: geo.magnitude - 50, data: pantryItems, spacing: 8.0, alignment: .leading) { pantryItem in
                        PantryItemButton(
                            pantryItem: pantryItem,
                            selectionColor: selectionColor,
                            showsContextMenu: showsContextMenu,
                            selectedItems: $selectedItems,
                            editMode: $editMode,
                            editingPantryItem: $editingPantryItem)
                    }
                    .padding(.bottom, 8)
                    .padding([.leading, .trailing])
//                    .frame(maxWidth: 400.0) // TODO: This is a quick fix! For when transitioning from pantry view to sheet view
                }
            }
        }
    }
}

//#Preview {
//    PantryItemsView()
//}


EasyPantryUpdateView.swift
//
//  EasyPantryUpdateView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/29/24.
//

import SwiftUI

struct EasyPantryUpdateView: View {
    
    // TODO: When submitted, update updateDate
    
    let olderThanDays: Int
    let onClose: () -> Void
    @Binding var selectedItems: [PantryItem]
    @SectionedFetchRequest var beforeDaysAgoDateSectionedPantryItems: SectionedFetchResults<String?, PantryItem>
    
    @Environment(\.managedObjectContext) private var viewContext
    
    var allSelected: Bool {
        selectedItems.count == beforeDaysAgoDateSectionedPantryItems.reduce(0) { $0 + $1.count } // This sums up the items in each section
    }
    
    var body: some View {
        VStack {
            Button(action: { // TODO: Move this to PantryItemsView so that it will show in all its uses
                if allSelected {
                    // If all selected remove all from selected items
                    selectedItems = []
                } else {
                    // If not selected select all
                    selectedItems = beforeDaysAgoDateSectionedPantryItems.flatMap { section in
                        section.compactMap { pantryItem in
                            pantryItem as PantryItem
                        }
                    }
                }
            }) {
                HStack {
                    Text(allSelected ? "Deselect All" : "Select All")
                        .font(.heavy, 17)
                    Spacer()
                    Image(systemName: allSelected ? "checkmark.circle.fill" : "checkmark.circle")
                }
                .foregroundStyle(Colors.elementBackground)
                .padding(.vertical, 8)
                .padding(.horizontal)
                .background(Colors.elementText)
                .clipShape(RoundedRectangle(cornerRadius: 14.0))
            }
            
            if beforeDaysAgoDateSectionedPantryItems.isEmpty {
                Text("No Items")
                    .font(.custom(Constants.FontName.body, size: 17.0))
                    .foregroundStyle(Colors.foregroundText)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Colors.foreground.opacity(0.6))
                    .clipShape(RoundedRectangle(cornerRadius: 14.0))
            } else {
                PantryItemsView(
                    selectedItems: $selectedItems,
                    editMode: .constant(.inactive),
                    sectionedPantryItems: _beforeDaysAgoDateSectionedPantryItems,
                    showsContextMenu: false,
                    selectionColor: .red)
            }
        }
        .toolbarBackground(Colors.elementBackground, for: .navigationBar)
        .toolbarBackground(.visible, for: .navigationBar)
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .principal) {
                Image(Constants.ImageName.navBarLogoImage)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .foregroundStyle(Colors.elementText)
                    .frame(maxHeight: 38.0)
            }
            ToolbarItem(placement: .topBarLeading) {
                Button(action: {
                    onClose()
                }) {
                    Text("Close")
                        .font(.custom(Constants.FontName.body, size: 17.0))
                        .foregroundStyle(Colors.elementText)
                }
            }
            ToolbarItem(placement: .topBarTrailing) {
                Button(action: {
                    Task {
                        for selectedItem in selectedItems {
                            do {
                                try await PantryItemCDClient.deletePantryItem(selectedItem, in: viewContext)
                            } catch {
                                // TODO: Handle Errors
                                print("Error deleting pantry item in EasyPantryUpdateContainer, continuing... \(error)")
                            }
                        }
                        
                        for pantryItemElement in beforeDaysAgoDateSectionedPantryItems {
                            for pantryItem in pantryItemElement {
                                // Set each item's updateDate to one day before the olderThanDays in reference to the current date TODO: Should this be in reference to the ingredient's date? No, because if the item is like 5 days old and olderThanDays is 3, it will set it to 2 days old so that the next day it will show up in the easy pantry update view
                                let newUpdateDate = Calendar.current.date(
                                    byAdding: .day,
                                    value: olderThanDays <= 0 ? 0 : -olderThanDays + 1, // Make sure the olderThanDays result is not less than zero
                                    to: Date()) ?? Date()
                                
                                try await PantryItemCDClient.updatePantryItem(pantryItem, updateDate: newUpdateDate, in: viewContext)
                            }
                        }
                    }
                    
                    onClose()
                }) {
                    Text("Save")
                        .font(.custom(Constants.FontName.heavy, size: 17.0))
                        .foregroundStyle(Colors.elementText)
                }
            }
        }
    }
    
}

#Preview {
    
    NavigationStack {
        EasyPantryUpdateView(
            olderThanDays: 3,
            onClose: {
                
            },
            selectedItems: .constant([]),
            beforeDaysAgoDateSectionedPantryItems: SectionedFetchRequest<String?, PantryItem>(
                sectionIdentifier: \.daysAgoString,
                sortDescriptors: [
                    NSSortDescriptor(keyPath: \PantryItem.updateDate, ascending: true),
                    NSSortDescriptor(keyPath: \PantryItem.name, ascending: true)
                ],
                predicate: NSPredicate(format: "%K <= %@", #keyPath(PantryItem.updateDate), Calendar.current.date(byAdding: .day, value: -3, to: Date())! as NSDate),
                animation: .default))
    }
    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
    
}


BarItemSelector.swift
//
//  PantryItemSelector.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/10/23.
//

import Foundation
import SwiftUI

protocol PantryItemSelector {
    
    var selectedItems: Binding<[PantryItem]> { get set }
    var deselectedItems: Binding<[PantryItem]> { get set }
    
}


PantryRecipeGenerationAdvancedOptionsView.swift
//
//  PantryRecipeGenerationAdvancedOptionsView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/25/24.
//

import Foundation
import SwiftUI

struct PantryRecipeGenerationAdvancedOptionsView: View {
    
    @Binding var isDisplayingAdvancedOptions: Bool
    @Binding var generationAdditionalOptions: RecipeGenerationAdditionalOptions
    
    
    var body: some View {
        HStack {
            Button(action: {
                HapticHelper.doLightHaptic()
                
                withAnimation {
                    isDisplayingAdvancedOptions.toggle()
                }
            }) {
                Text("\(isDisplayingAdvancedOptions ? "Hide" : "Show") Advanced Options \(isDisplayingAdvancedOptions ? Image(systemName: "chevron.up") : Image(systemName: "chevron.down"))")
                    .font(.custom(Constants.FontName.heavy, size: 14.0))
                    .foregroundStyle(Colors.elementBackground)
            }
            .padding([.leading, .trailing])
            Spacer()
        }
        
        if isDisplayingAdvancedOptions {
            HStack {
                VStack(alignment: .leading) {
                    // Use All Ingredients Button
                    KeyboardDismissingButton(action: {
                        HapticHelper.doLightHaptic()
                        
                        // Set recipeGenerationAdditionalOptions to useAllGivenIngredients if not useAllGivenIngredients, otherwise set to normal
                        if generationAdditionalOptions != .useOnlyGivenIngredients {
                            withAnimation {
                                generationAdditionalOptions = .useOnlyGivenIngredients
                            }
                        } else {
                            withAnimation {
                                generationAdditionalOptions = .normal
                            }
                        }
                    }) {
                        HStack {
                            Text(Image(systemName: generationAdditionalOptions == .useOnlyGivenIngredients ? "checkmark.circle.fill" : "circle"))
                                .font(.custom(Constants.FontName.body, size: 20.0))
                            Text("Use All Ingredients")
                                .font(.custom(Constants.FontName.heavy, size: 14.0))
                        }
                        .padding([.leading, .trailing], 16)
                        .padding([.top, .bottom], 8)
                        .tint(Colors.elementBackground)
                        .background(Colors.foreground)
                        .clipShape(RoundedRectangle(cornerRadius: 14.0))
                    }
                    .bounceable()
                    
                    // TODO: Add second button for "Increase Creativity" that toggles the use all ingredients one, and update the description to explain it in this way, "toggle AI to use only what's in your prompt or deliciously add ingredients for a better tasting recipe".
                    
                    Text("Ensure AI does not omit any selected ingredients.")
                        .font(.custom(Constants.FontName.bodyOblique, size: 12.0))
                        .opacity(0.6)
                    
                    // Increase Creativity Button
                    KeyboardDismissingButton(action: {
                        HapticHelper.doLightHaptic()
                        
                        // Set recipeGenerationAdditionalOptions to boostCreativity if not boostCreativity, otherwise set to normal
                        if generationAdditionalOptions != .boostCreativity {
                            withAnimation {
                                generationAdditionalOptions = .boostCreativity
                            }
                        } else {
                            withAnimation {
                                generationAdditionalOptions = .normal
                            }
                        }
                    }) {
                        HStack {
                            Text(Image(systemName: generationAdditionalOptions == .boostCreativity ? "checkmark.circle.fill" : "circle"))
                                .font(.custom(Constants.FontName.body, size: 20.0))
                            Text("Boost Creativity")
                                .font(.custom(Constants.FontName.heavy, size: 14.0))
                        }
                        .padding([.leading, .trailing], 16)
                        .padding([.top, .bottom], 8)
                        .tint(Colors.elementBackground)
                        .background(Colors.foreground)
                        .clipShape(RoundedRectangle(cornerRadius: 14.0))
                    }
                    .bounceable()
                    
                    // TODO: Add second button for "Increase Creativity" that toggles the use all ingredients one, and update the description to explain it in this way, "toggle AI to use only what's in your prompt or deliciously add ingredients for a better tasting recipe".
                    
                    Text("Let AI add ingredients to boost tastiness.")
                        .font(.custom(Constants.FontName.bodyOblique, size: 12.0))
                        .opacity(0.6)
                }
                Spacer()
            }
            .padding([.leading, .trailing])
        }
    }
    
}


#Preview {
    
    PantryRecipeGenerationAdvancedOptionsView(
        isDisplayingAdvancedOptions: .constant(true),
        generationAdditionalOptions: .constant(.normal)
    )
    
}


InsertPantryItemViewContainer.swift
//
//  InsertPantryItemViewContainer.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/22/24.
//

import SwiftUI

struct InsertPantryItemViewContainer: View {
    
    @Binding var isActive: Bool
    let showCameraOnAppear: Bool
    
    @Environment(\.managedObjectContext) private var viewContext
    
    
    @State private var manualPantryItem: PantryItem?
    
    private var isShowingEditPantryItemViewForManualPantryItemEntry: Binding<Bool> {
        Binding(
            get: {
                manualPantryItem != nil
            },
            set: { value in
                if !value {
                    manualPantryItem = nil
                }
            })
    }
    
    var body: some View {
        ZStack {
            if let manualPantryItem = manualPantryItem {
                EditPantryItemView(pantryItem: manualPantryItem, isActive: isShowingEditPantryItemViewForManualPantryItemEntry)
            } else {
                InsertPantryItemView(
                    isShowing: $isActive,
                    isShowingCaptureCameraView: showCameraOnAppear,
                    onUseManualEntry: {
                        Task {
                            do {
                                manualPantryItem = try await viewContext.perform {
                                    let pantryItem = PantryItem(context: viewContext)
                                    
                                    try viewContext.save()
                                    
                                    return pantryItem
                                }
                            } catch {
                                // TODO: Handle Errors
                                print("Error inserting manual pantry item in InsertPantryItemViewContainer... \(error)")
                            }
                        }
                    })
            }
        }
        .onChange(of: isShowingEditPantryItemViewForManualPantryItemEntry.wrappedValue) { newValue in
            if !newValue {
                isActive = false
            }
        }
    }
    
}

#Preview {
    
    InsertPantryItemViewContainer(
        isActive: .constant(true),
        showCameraOnAppear: false)
        .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
        .environmentObject(PremiumUpdater())
        .environmentObject(ProductUpdater())
        .environmentObject(RemainingUpdater())
    
}


PantryItemView.swift
//
//  PantryItemView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/18/23.
//

import Foundation
import SwiftUI

struct PantryItemView: View {
    
    @State var pantryItem: PantryItem
    var titleNoSubtitleFont: Font = .custom(Constants.FontName.body, size: 17.0)
//    var titleFont: Font = .custom(Constants.FontName.heavy, size: 17.0) TODO: This is not implemented anymore due to subtitle not being implemented
//    var subtitleFont: Font = .custom(Constants.FontName.light, size: 12.0) TODO: This is not implemented anymore check if this should be or improves functionality
    
//    var image: UIImage
    
//    static func from(pantryItem: PantryItem, titleFont: Font = .custom(Constants.FontName.heavy, size: 17.0), subtitleFont: Font = .custom(Constants.FontName.light, size: 12.0)) -> PantryItemView? {
//        guard let title = pantryItem.name else {
//            // TODO: Handle errors
//            return nil
//        }
//        let subtitle: String? = {
//            if pantryItem.amount >
//            
//            return nil
//        }()
//        
//        return PantryItemView(title: LocalizedStringKey(title), subtitle: subtitle, titleFont: titleFont, subtitleFont: subtitleFont)
//    }
    
    var customDateFormatter: DateFormatter {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MMM d, h:mm a"
        return dateFormatter
    }
    
    var body: some View {
        VStack {
//            Image(uiImage: data.image)
//                .resizable()
//                .aspectRatio(contentMode: .fit)
            if let name = pantryItem.name {
                Text(name)
                    .font(titleNoSubtitleFont)
                    .foregroundStyle(Colors.foregroundText)
            }
        }
    }
    
}

#Preview {
    
    let pantryItem = try! CDClient.mainManagedObjectContext.performAndWait {
        let fetchRequest = PantryItem.fetchRequest()
        
        fetchRequest.fetchLimit = 1
        
        return try CDClient.mainManagedObjectContext.fetch(fetchRequest)[0]
    }
    
    return PantryItemView(
        pantryItem: pantryItem
    )
}


InsertPantryItemView.swift
//
//  InsertPantryItemView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/19/23.
//

import Foundation
import SwiftUI

struct InsertPantryItemView: View {
    
    @Binding var isShowing: Bool
//    let showCameraOnAppear: Bool
    @State var isShowingCaptureCameraView: Bool
    
    let onUseManualEntry: () -> Void
    
    let instructionText: String = "Enter items to add to your pantry. Include produce, meats, branded items, and more."
    let instructionExampleText: String = "ex. \"Lemon, Chicken, Pasta, Tomato Paste, etc."
    
    let placeholderText: String = "Tap to start typing..."
    
    @Environment(\.colorScheme) private var colorScheme
    @Environment(\.managedObjectContext) private var viewContext
    
    @FocusState private var automaticEntryTextFieldFocusState
    
    @StateObject private var pantryItemsParser: PantryItemsParser = PantryItemsParser()
    
    @State private var automaticEntryText: String = ""
    @State private var automaticEntryItems: [String] = []
    
//    @State private var isUsingAutomaticEntry: Bool = true
    
    @State private var duplicatePantryItemNames: [String] = []
    
    @State private var alertShowingDuplicateAutomaticEntryItem: Bool = false
    @State private var alertShowingDuplicateObjectWhenInserting: Bool = false
    
    private var isAutoSubmitButtonEnabled: Bool {
        !automaticEntryText.isEmpty || !automaticEntryItems.isEmpty
    }
    

    var body: some View {
        VStack {
            HStack {
                Text("Add to Pantry...")
                    .font(.custom(Constants.FontName.black, size: 28.0))
                Spacer()
                Button(action: {
                    HapticHelper.doLightHaptic()
                    
                    // Close by setting isShowing to false
                    withAnimation {
                        isShowing = false
                    }
                }) {
                    Image(systemName: "xmark")
                        .font(.custom(Constants.FontName.black, size: 24.0))
                        .foregroundColor(Colors.elementBackground)
                }
            }
            .padding(.bottom, 8)
            
            automaticEntryView
            
            Button(action: {
                HapticHelper.doLightHaptic()
                
                onUseManualEntry()
            }) {
                Text("Switch to Manual Entry")
                    .font(.custom(Constants.FontName.heavy, size: 14.0))
                    .foregroundStyle(Colors.elementBackground)
                    .underline()
            }
            .padding(.top, 8)
            .padding(.bottom)
            
            submitButtonView
        }
        .alert("Duplicate Entry", isPresented: $alertShowingDuplicateAutomaticEntryItem, actions: {
            Button("Done", role: .cancel, action: {
                
            })
        }) {
            Text("This item is already in your list to add to pantry.")
        }
        .alert("Duplicate Item", isPresented: $alertShowingDuplicateObjectWhenInserting, actions: {
            Button("Done", role: .cancel, action: {
                withAnimation {
                    isShowing = false
                }
            })
        }) {
            Text("Duplicate pantry items found and won't be added:
" + duplicatePantryItemNames.joined(separator: ", "))
        }
        .fullScreenCover(isPresented: $isShowingCaptureCameraView) {
            ZStack {
                CaptureCameraViewControllerRepresentable(
                    reset: .constant(false),
                    onAttach: { image, cropFrame, unmodifiedImage in
                        Task {
                            do {
                                // Get pantryItemStrings from image and add them to automaticEntryItems
                                let pantryItemStrings = try await pantryItemsParser.parseGetPantryItemsFromImage(image: image, input: nil).map({$0.name})
                                
                                automaticEntryItems.append(contentsOf: pantryItemStrings)
                            } catch {
                                // TODO: Handle Errors
                                print("Error getting pantry item text from image in InsertPantryItemView... \(error)")
                            }
                        }
                        
                        withAnimation {
                            isShowingCaptureCameraView = false
                        }
                    })
                
                VStack {
                    HStack {
                        Spacer()
                        Button(action: {
                            withAnimation {
                                HapticHelper.doLightHaptic()
                                
                                isShowingCaptureCameraView = false
                            }
                        }) {
                            ZStack {
                                Image(systemName: "xmark")
                                    .resizable()
                                    .frame(width: 30.0, height: 30.0)
                                    .foregroundStyle(Colors.elementText)
                                
                                Image(systemName: "xmark")
                                    .resizable()
                                    .frame(width: 28.0, height: 28.0)
                                    .foregroundStyle(Colors.elementBackground)
                            }
                            .padding(.top)
                            .padding()
                            .padding()
                        }
                    }
                    Spacer()
                }
            }
            .ignoresSafeArea()
        }
    }
    
    var automaticEntryView: some View {
        VStack {
            // Automatic Entry Field and Entered Items
            SingleAxisGeometryReader(axis: .horizontal) { geo in
                VStack(alignment: .leading) {
                    FlexibleView(availableWidth: geo.magnitude, data: automaticEntryItems, spacing: 8.0, alignment: .leading) { selectedItem in
                        Button(action: {
                            HapticHelper.doLightHaptic()
                            
                            withAnimation {
                                automaticEntryItems.removeAll(where: {$0 == selectedItem})
                            }
                        }) {
                            Text("\(selectedItem) \(Image(systemName: "xmark"))")
                                .font(.custom(Constants.FontName.body, size: 14.0))
                                .foregroundStyle(Colors.foregroundText)
                                .padding([.top, .bottom], 8)
                                .padding([.leading, .trailing])
                                .background(Colors.foreground)
                                .clipShape(RoundedRectangle(cornerRadius: 14.0))
                        }
                    }
                    
                    TextField(placeholderText, text: $automaticEntryText)
                        .textFieldTickerTint(colorScheme == .light ? Colors.elementBackground : Colors.foregroundText)
                        .keyboardDismissingTextFieldToolbar("Done", color: Colors.elementBackground)
                        .focused($automaticEntryTextFieldFocusState)
                        .font(.custom(Constants.FontName.body, size: 17.0))
                        .foregroundColor(Colors.foregroundText)
                        .padding()
                        .background(Colors.foreground)
                        .clipShape(RoundedRectangle(cornerRadius: 20.0))
                        .onSubmit {
                            // Set textField to focused to bring up keyboard
                            UIView.performWithoutAnimation {
                                automaticEntryTextFieldFocusState = true
                            }
                            
                            // Loop through automaticEntryText split by comma separator
                            for item in automaticEntryText.split(separator: ", ") {
                                // Ensure automaticEntryText is not in automaticEntryItems, otherwise return
                                guard !automaticEntryItems.contains(String(item)) else {
                                    alertShowingDuplicateAutomaticEntryItem = true
                                    return
                                }
                                
                                // Take automaticEntryText and add it to automaticEnteredItems
                                automaticEntryItems.append(String(item))
                            }
                            
                            // Set automaticEntryText to blank
                            automaticEntryText = ""
                        }
                }
            }
            
            // Instructions
            Text(instructionText)
                .font(.custom(Constants.FontName.light, size: 14.0))
                .multilineTextAlignment(.center)
                .opacity(0.4)
            Text(instructionExampleText)
                .font(.custom(Constants.FontName.lightOblique, size: 14.0))
                .multilineTextAlignment(.center)
                .opacity(0.4)
            
            // Add with Camera Button
            Button(action: {
                HapticHelper.doLightHaptic()
                
                isShowingCaptureCameraView = true
            }) {
                ZStack {
                    HStack {
                        Spacer()
                        Image(systemName: "chevron.right")
                            .imageScale(.medium)
                    }
                    HStack {
                        Spacer()
                        Text("\(Image(systemName: "camera")) Scan to Add")
                            .font(.custom(Constants.FontName.heavy, size: 20.0))
                        Spacer()
                    }
                }
            }
            .padding()
            .background(
                ZStack {
                    RoundedRectangle(cornerRadius: 14.0)
                        .stroke(Colors.elementBackground)
                    RoundedRectangle(cornerRadius: 14.0)
                        .fill(Colors.elementText)
                }
            )
            .foregroundStyle(Colors.elementBackground)
            .clipShape(RoundedRectangle(cornerRadius: 14.0))
            .padding(.top)
            
            // Add with Camera Description
            HStack {
                Text("Take a picture of your pantry, fridge, receipt items, and more. AI will automatically find and add items.")
                    .font(.custom(Constants.FontName.light, size: 14.0))
                    .multilineTextAlignment(.center)
                    .opacity(0.4)
                Spacer()
            }
        }
    }
    
    var submitButtonView: some View {
        Button(action: {
            HapticHelper.doMediumHaptic()
            
            Task {
                let authToken: String
                do {
                    authToken = try await AuthHelper.ensure()
                } catch {
                    // TODO: Handle errors
                    print("Error ensuring authToken in InsertPantryItemView... \(error)")
                    return
                }
                
                // Parse save bar items
                do {
                    try await pantryItemsParser.parseSavePantryItems(
                        input: automaticEntryItems.joined(separator: ", ") + "
" + automaticEntryText,
                        in: viewContext)
                    
                    // Do success haptic
                    HapticHelper.doSuccessHaptic()
                    
                    // Close by setting isShowing to false with animation
                    withAnimation {
                        isShowing = false
                    }
                } catch PantryItemPersistenceError.duplicatePantryItemNames(let duplicatePantryItemNames) {
                    // Do warning haptic
                    HapticHelper.doWarningHaptic()
                    
                    // Set instance dupliactePantryItemsNames to dupliactePantryItemNames from error
                    self.duplicatePantryItemNames = duplicatePantryItemNames
                    alertShowingDuplicateObjectWhenInserting = true
                } catch {
                    // TODO: Handle errors
                    print("Error parsing and saving bar items in body in InsertPantryItemView... \(error)")
                }
            }
        }) {
            ZStack {
                if pantryItemsParser.isLoading {
                    // Progress view
                    HStack {
                        Spacer()
                        ProgressView()
                            .tint(Colors.elementText)
                    }
                } else {
                    // Chevron
                    HStack {
                        Spacer()
                        Image(systemName: "chevron.right")
                    }
                }
                
                // Add to pantry text
                HStack {
                    Spacer()
                    Text("Submit")
                        .font(.custom(Constants.FontName.heavy, size: 20.0))
                    Spacer()
                }
            }
        }
        .foregroundColor(Colors.elementText)
        .padding()
        .background(Colors.elementBackground)
        .cornerRadius(20.0)
        .opacity(isAutoSubmitButtonEnabled ? 1.0 : 0.4)
        .disabled(!isAutoSubmitButtonEnabled)
        .disabled(pantryItemsParser.isLoading)
        .opacity(pantryItemsParser.isLoading ? 0.4 : 1.0)
    }

}

struct InsertPantryItemView_PreviewProvider: PreviewProvider {
    static var previews: some View {
        InsertPantryItemView(
            isShowing: .constant(false),
            isShowingCaptureCameraView: false,
            onUseManualEntry: {
                print("Use Manual Entry Tapped")
            })
            .background(Color(uiColor: .secondarySystemBackground))
            .environmentObject(PremiumUpdater())
            .environmentObject(ProductUpdater())
            .environmentObject(RemainingUpdater())
    }
}


PantryContainer.swift
//
//  PantryContainer.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/13/24.
//

import SwiftUI

struct PantryContainer: View {
    
    var showsEditButton: Bool = false
    let onDismiss: () -> Void
    var onCreateRecipe: ((_ pantryItems: [PantryItem]) -> Void)? = nil
    
    @State private var selectedItems: [PantryItem] = []
    
    var body: some View {
        PantryView(
            selectedItems: $selectedItems,
            onDismiss: onDismiss,
            onCreateRecipe: onCreateRecipe == nil ? nil : {
                onCreateRecipe?(selectedItems)
            })
    }
}

#Preview {
    
    PantryContainer(
        showsEditButton: true,
        onDismiss: {
            
        },
        onCreateRecipe: { recipe in
            
        }
    )
    
}


PantrySelectionView.swift
//
//  PantrySelectionView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/21/24.
//

import SwiftUI

struct PantrySelectionView: View {
    
    @Binding var selectedPantryItems: [PantryItem]
    @State var showsAdvancedOptions: Bool = true
    @Binding var generationAdditionalOptions: RecipeGenerationAdditionalOptions
    
    
    @Namespace private var namespace
    
    @Environment(\.managedObjectContext) var viewContext
    
    
    @SectionedFetchRequest(
        sectionIdentifier: \PantryItem.category,
        sortDescriptors: [
            NSSortDescriptor(keyPath: \PantryItem.category, ascending: true),
            NSSortDescriptor(keyPath: \PantryItem.name, ascending: true)
        ],
        animation: .default)
    private var sectionedPantryItems: SectionedFetchResults<String?, PantryItem>
    
    
    @State private var isDisplayingAddPantryItemPopup: Bool = false
    @State private var isDisplayingAdvancedOptions: Bool = false
    
    
    
    var body: some View {
        VStack(alignment: .leading) {
            PantryItemsContainer(
                selectedItems: $selectedPantryItems,
                editMode: .constant(.inactive),
                showsContextMenu: true,
                selectionColor: .green)
            
            HStack {
                Button(action: {
                    HapticHelper.doLightHaptic()
                    
                    withAnimation {
                        isDisplayingAddPantryItemPopup = true
                    }
                }) {
                    Text("+ Add to Pantry")
                        .font(.custom(Constants.FontName.heavy, size: 17.0))
                        .padding([.top, .bottom], 8)
                        .padding([.leading, .trailing])
                        .foregroundColor(Colors.elementBackground)
                        .background(Colors.foreground)
                        .clipShape(RoundedRectangle(cornerRadius: 20.0))
                }
                .padding(.top)
                .padding([.leading, .trailing])
                
//                Spacer()
            }
            
            if showsAdvancedOptions {
                selectionButtons
            }
        }
        // InsertPantryItemView popup
        .addToPantryPopup(isPresented: $isDisplayingAddPantryItemPopup, showCameraOnAppear: false)
    }
    
    
    var selectionButtons: some View {
        PantryRecipeGenerationAdvancedOptionsView(
            isDisplayingAdvancedOptions: $isDisplayingAdvancedOptions,
            generationAdditionalOptions: $generationAdditionalOptions)
    }
    
    
    func pantryItemButton(for selectedPantryItem: PantryItem) -> some View {
        KeyboardDismissingButton(action: {
            HapticHelper.doLightHaptic()
            
            // TODO: Turn green and add to generate list or something when tapped
            if !selectedPantryItems.contains(where: {$0 == selectedPantryItem}) {
                withAnimation(.bouncy) {
                    selectedPantryItems.append(selectedPantryItem)
                }
            } else {
                withAnimation(.bouncy) {
                    selectedPantryItems.removeAll(where: {$0 == selectedPantryItem})
                }
            }
        }) {
            PantryItemView(pantryItem: selectedPantryItem)
                .frame(maxHeight: .infinity)
        }
        .padding([.top, .bottom], 8)
        .padding([.leading, .trailing], 16)
        .background(
            selectedPantryItems.contains(where: {$0 == selectedPantryItem})
            ?
            Color(uiColor: .systemGreen).opacity(0.4)
            :
                Colors.foreground
        )
        .cornerRadius(14.0)
    }
    
    
}

#Preview {
    PantrySelectionView(
        selectedPantryItems: .constant([]),
        generationAdditionalOptions: .constant(.normal))
        .background(Colors.background)
        .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
        .environmentObject(PremiumUpdater())
        .environmentObject(ProductUpdater())
        .environmentObject(RemainingUpdater())
}



PantryItemsParser.swift
//
//  PantryItemsParser.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/22/24.
//

import CoreData
import Foundation
import UIKit

class PantryItemsParser: ObservableObject {
    
    @Published var isLoading: Bool = false
    
    func parseGetPantryItemsFromImage(image: UIImage, input: String?) async throws -> [(name: String, category: String?)] {
        // Defer setting isLoading to false
        defer {
            DispatchQueue.main.async {
                self.isLoading = false
            }
        }
        
        // Set isLoading to true
        await MainActor.run {
            isLoading = true
        }
        
        // Get authToken with AuthHelper ensure
        let authToken: String
        do {
            authToken = try await AuthHelper.ensure()
        } catch {
            // TODO: Handle errors
            print("Error ensuring authToken when creating Recipe in RecipeGenerator... \(error)")
            throw GenerationError.auth
        }
        
        // Create parse pantry items request with image and input
        let parsePantryItemsRequest = ParsePantryItemsRequest(
            authToken: authToken,
            input: input,
            imageDataInput: ImageResizer.resizedJpegDataTo512(from: image))
        
        // Do parse pantry items request and get parse pantry items response
        let parsePantryItemsResponse = try await ChefAppNetworkService.parsePantryItems(request: parsePantryItemsRequest)
        
        // Return pantry items received
        return parsePantryItemsResponse.body.pantryItems.compactMap({
            if let name = $0.item {
                return (name: name.capitalized, category: $0.category?.capitalized)
            } else {
                return nil
            }
        })
    }
    
    func parseSavePantryItems(image: UIImage, input: String?, in managedContext: NSManagedObjectContext) async throws {
        // Defer setting isLoading to false
        defer {
            DispatchQueue.main.async {
                self.isLoading = false
            }
        }
        
        // Parse get pantry items from image
        let pantryItems = try await parseGetPantryItemsFromImage(image: image, input: input)
        
        // Set isLoading to true TODO: Is this good practice since isLoading is also used by parseGetPantryItemsFromImage, is it fine, or should I just have a different variable?
        await MainActor.run {
            isLoading = true
        }
        
        // Create duplicatePantryItemNames to track duplicate pantry items when inserting
        var duplicatePantryItemNames: [String] = []
        
        // Save to persistence
        for pantryItem in pantryItems {
            do {
                try await PantryItemCDClient.appendPantryItem(name: pantryItem.name.capitalized, category: pantryItem.category?.capitalized, in: managedContext)
            } catch PersistenceError.duplicateObject {
                print("Duplicate PantryItem found when appending pantry item")
                duplicatePantryItemNames.append(pantryItem.name.capitalized)
            }
        }
        
        // Throw duplicate error if duplicate items were found TODO: Is this good practice?
        if !duplicatePantryItemNames.isEmpty {
            throw PantryItemPersistenceError.duplicatePantryItemNames(duplicatePantryItemNames)
        }
    }
    
    func parseSavePantryItems(input: String?, in managedContext: NSManagedObjectContext) async throws {
        // Defer setting isLoading to false
        defer {
            DispatchQueue.main.async {
                self.isLoading = false
            }
        }
        
        // Set isLoading to true
        await MainActor.run {
            isLoading = true
        }
        
        // Get authToken with AuthHelper ensure
        let authToken: String
        do {
            authToken = try await AuthHelper.ensure()
        } catch {
            // TODO: Handle errors
            print("Error ensuring authToken when creating Recipe in RecipeGenerator... \(error)")
            throw GenerationError.auth
        }
        
        // Parse save pantry items
        try await ChefAppNetworkPersistenceManager.parseSavePantryItems(
            authToken: authToken,
            input: input,//automaticEntryItems.joined(separator: ", ") + "
" + automaticEntryText,
            in: managedContext)
    }
    
    
}


PanelParser.swift
//
//  PanelParser.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/17/23.
//

import Foundation
import UIKit

class PanelParser {
    
    fileprivate struct PanelArray: Codable {
        
        var panels: [Panel]
        
        enum CodingKeys: String, CodingKey {
            case panels
        }
        
    }
    
    static func parsePanelsGettingImagesFromFiles(fromJson json: String) throws -> [Panel]? {
        if let data = json.data(using: .utf8) {
            return try parsePanelsGettingImagesFromFiles(fromJson: data)
        }
        
        return nil
    }
    
    static func parsePanelsGettingImagesFromFiles(fromJson jsonData: Data) throws -> [Panel]? {
        // Get panels from jsonDecoder
        let panels = try JSONDecoder().decode(PanelArray.self, from: jsonData).panels
        
        // Return panels
        return panels
    }
    
    static func parsePanelsUpdatingSavedImagesFromNetwork(fromJson json: String) async throws -> [Panel]? {
        if let data = json.data(using: .utf8) {
            return try await parsePanelsUpdatingSavedImagesFromNetwork(fromJson: data)
        }
        
        return nil
    }
    
    static func parsePanelsUpdatingSavedImagesFromNetwork(fromJson jsonData: Data) async throws -> [Panel] {
        // Get panels from jsonDecoder
        let panels = try JSONDecoder().decode(PanelArray.self, from: jsonData).panels
        
        return panels
    }
    
}


Panel.swift
//
//  Panel.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/17/23.
//

import Foundation
import UIKit

struct Panel: Identifiable, Codable, Hashable {
    
    let id = UUID()
    
    let emoji: String
    let title: String
    let summary: String
    let prompt: String
    var components: [PanelComponent]
    
    enum CodingKeys: String, CodingKey {
        case emoji
        case title
        case summary
        case prompt
        case components
    }
    
}

//extension Panel {
//    
//    struct PanelComponentDecodable: Codable {
//        
//        var type: String
//        
//        enum CodingKeys: String, CodingKey {
//            case type
//        }
//        
//    }
//    
//    init(from decoder: Decoder) throws {
//        let container = try decoder.container(keyedBy: CodingKeys.self)
//        emoji = try container.decode(String.self, forKey: .emoji)
//        title = try container.decode(String.self, forKey: .title)
//        summary = try container.decode(String.self, forKey: .summary)
//        prompt = try container.decode(String.self, forKey: .prompt)
//        
//        components = []
//        
//        var componentContainer = try container.nestedUnkeyedContainer(forKey: .components)
//        while (!componentContainer.isAtEnd) {
//            let nestedDecoder = try componentContainer.superDecoder()
//            let containerAsPanelComponentDecodable = try nestedDecoder.container(keyedBy: PanelComponentDecodable.CodingKeys.self)
//            let type = try containerAsPanelComponentDecodable.decode(String.self, forKey: .type)
////            let panelComponentType = PanelComponentType.from(type)
////            print(panelComponentType)
//            
////            switch panelComponentType {
////            case .barSelection:
////                
////                let barSelectionComponent = try nestedDecoder.container(keyedBy: BarSelectionPanelComponent.CodingKeys.self)
////                components.append(barSelectionComponent.decode(BarSelectionPanelComponent.self, forKey: .))
////            }
//        }
//        
//    }
//    
//    func encode(to encoder: Encoder) throws {
//        
//    }
//    
//}


TextViewPanelComponent.swift
////
////  TextViewPanelComponent.swift
////  Barback
////
////  Created by Alex Coundouriotis on 9/17/23.
////
//
//import Foundation
//import SwiftUI
//
//struct TextViewPanelComponent: PanelComponent {
//    
//    var id = UUID()
//    
//    var title: String
//    var placeholder: String?
//    var detailTitle: String?
//    var detailText: String?
//    var promptPrefix: String
//    var required: Bool?
//    
//    var text: String = ""
//    
//    var finalizedPrompt: String? {
//        guard !text.isEmpty else {
//            return nil
//        }
//        
//        return promptPrefix + " " + text
//    }
//    
//    var placeholderUnwrapped: String {
//        placeholder ?? defaultPlaceholder
//    }
//    
//    private let defaultPlaceholder = "Tap to start typing..."
//    
//    enum CodingKeys: String, CodingKey {
//        case title
//        case placeholder
//        case detailTitle
//        case detailText
//        case promptPrefix
//        case required
//    }
//    
//}


TextFieldPanelComponentViewConfig.swift
//
//  TextFieldPanelComponentViewConfig.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/17/23.
//

import Foundation
import SwiftUI

struct TextFieldPanelComponentViewConfig: Identifiable, Codable, Hashable {
    
    var id = UUID()
    
    var placeholder: String?
    
    var placeholderUnwrapped: String {
        placeholder ?? defaultPlaceholder
    }
    
    private let defaultPlaceholder = "Tap to start typing..."
    
    enum CodingKeys: String, CodingKey {
        case placeholder
    }
    
}


PanelComponentType.swift
////
////  PanelComponentType.swift
////  Barback
////
////  Created by Alex Coundouriotis on 9/17/23.
////
//
//import Foundation
//
//enum PanelComponentType {
//    
//    case barSelection
//    case dropdown(DropdownPanelComponentViewConfig)
//    case ingredientsInput
//    case textField
//    
//}

//enum PanelComponentType: Identifiable, Codable, Hashable {
//    
//    var id: UUID {
//        any.id
//    }
//    
//    case barSelection(BarSelectionPanelComponent)
//    case dropdown(DropdownPanelComponent)
//    case ingredientsInput(IngredientsInputPanelComponent)
//    case textField(TextFieldPanelComponent)
//    
//    var any: any PanelComponent {
//        switch self {
//        case .barSelection(let component):
//            component
//        case .dropdown(let component):
//            component
//        case .ingredientsInput(let component):
//            component
//        case .textField(let component):
//            component
//        }
//    }
//    
//}
//
//extension PanelComponentType {
//    
//    enum CodingKeys: String, CodingKey {
//        
//        case type
//        
//    }
//    
//    init(from decoder: Decoder) throws {
//        let container = try decoder.container(keyedBy: CodingKeys.self)
//        let singleContainer = try decoder.singleValueContainer()
//        
//        let type = try container.decode(String.self, forKey: .type)
//        switch type.lowercased() {
//        case "barSelection".lowercased():
//            let barSelectionPanelComponent = try singleContainer.decode(BarSelectionPanelComponent.self)
//            self = .barSelection(barSelectionPanelComponent)
//        case "dropdown".lowercased():
//            let dropdownPanelComponent = try singleContainer.decode(DropdownPanelComponent.self)
//            self = .dropdown(dropdownPanelComponent)
//        case "ingredientsInput".lowercased():
//            let ingredientsInputPanelComponent = try singleContainer.decode(IngredientsInputPanelComponent.self)
//            self = .ingredientsInput(ingredientsInputPanelComponent)
//        case "textField".lowercased():
//            let textFieldPanelComponent = try singleContainer.decode(TextFieldPanelComponent.self)
//            self = .textField(textFieldPanelComponent)
////        case "multilineInput".lowercased():
////            let textViewPanelComponent = try singleContainer.decode(TextViewPanelComponent.self)
////            self = .textView(textViewPanelComponent)
//        default:
//            throw DecodingError.valueNotFound(Self.self, DecodingError.Context(codingPath: container.codingPath, debugDescription: "Invalid type for PanelComponentType.. \(type)"))
//        }
//    }
//    
//    func encode(to encoder: Encoder) throws {
//        var singleContainer = encoder.singleValueContainer()
//        
//        switch self {
//        case .barSelection(let barSelectionPanelComponent):
//            try singleContainer.encode(barSelectionPanelComponent)
//        case .dropdown(let dropdownPanelComponent):
//            try singleContainer.encode(dropdownPanelComponent)
//        case .ingredientsInput(let ingredientsInputPanelComponent):
//            try singleContainer.encode(ingredientsInputPanelComponent)
//        case .textField(let textFieldPanelComponent):
//            try singleContainer.encode(textFieldPanelComponent)
////        case .textView(let textViewPanelComponent):
////            try singleContainer.encode(textViewPanelComponent)
//        }
//    }
//    
//}


PanelComponent.swift
//
//  PanelComponent.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/17/23.
//

import Foundation

struct PanelComponent: Identifiable, Codable, Hashable {
    
    var id = UUID()
    
    var input: Input // For decoding - Sring value, configs are in the base PanelComponent {}
    var title: String
    var example: String?
    var detailTitle: String?
    var detailText: String?
    var promptPrefix: String?
    var required: Bool?
    
    var finalizedPrompt: String?
    
    enum Input: Codable, Hashable {
        case barSelection
        case dropdown(DropdownPanelComponentViewConfig)
        case ingredientsInput(TextFieldPanelComponentViewConfig)
        case textField(TextFieldPanelComponentViewConfig)
    }
    
    enum CodingKeys: String, CodingKey {
        case input
        case title
        case example
        case detailTitle
        case detailText
        case promptPrefix
        case required
    }
    
}

extension PanelComponent {
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.title = try container.decode(String.self, forKey: .title)
        self.detailTitle = try container.decodeIfPresent(String.self, forKey: .detailTitle)
        self.example = try container.decodeIfPresent(String.self, forKey: .example)
        self.detailText = try container.decodeIfPresent(String.self, forKey: .detailText)
        self.promptPrefix = try container.decodeIfPresent(String.self, forKey: .promptPrefix)
        self.required = try container.decodeIfPresent(Bool.self, forKey: .required)
        
        let inputString = try container.decode(String.self, forKey: .input)
        switch inputString.lowercased() {
        case "barselection":
            input = .barSelection
        case "dropdown":
//            let dropdownContainer = try decoder.container(keyedBy: DropdownPanelComponentViewConfig.CodingKeys.self)
//            let dropdownViewConfig = try dropdownContainer.decode(<#T##type: Bool.Type##Bool.Type#>, forKey: <#T##KeyedDecodingContainer<DropdownPanelComponentViewConfig.CodingKeys>.Key#>)
            input = .dropdown(try DropdownPanelComponentViewConfig(from: decoder))
        case "ingredientsinput":
            input = .ingredientsInput(try TextFieldPanelComponentViewConfig(from: decoder))
        case "textfield":
            input = .textField(try TextFieldPanelComponentViewConfig(from: decoder))
        default:
            throw DecodingError.valueNotFound(Input.self, DecodingError.Context(codingPath: [CodingKeys.input], debugDescription: "Could not find a valid value for \"input\" in the JSON. Please check your spelling and make sure you are using a valid input name."))
        }
    }
    
}

extension PanelComponent {
    
    var requiredUnwrapped: Bool {
        get {
            required ?? false
        }
        set {
            required = newValue
        }
    }
    
}


/***
 
 Panel json reference for and from GPT
 
 {
   "panels": [
     {
       "emoji": "🔧",
       "title": "Documentation Example",
       "summary": "This is a panel for documentation purposes.",
       "prompt": "Prompt for prompting AI to generate",
       "components": [
         {
           "input": "textField",
           "title": "Title displayed to user.",
           "example": "Example as placeholder for textField",
           "detailTitle": "Optional, shown as the title for a popup if user seeks more information",
           "detailText": "Optional, shown as the body for a popup if user seeks more information.",
           "promptPrefix": "Tells the AI what this field is about",
           "required": bool
         },
         {
           "input": "dropdown",
           "title": "Choose an option",
           "detailTitle": "Optional, shown as the title for a popup if user seeks more information",
           "detailText": "Optional, shown as the body for a popup if user seeks more information.",
           "promptPrefix": "Tells the AI what this field is about",
           "placeholder": "Placeholder for first option",
           "items": [
             "Option 1",
             "Option 2",
             "Option 3"
           ],
           "required": bool
         },
         {
           "input": "ingredientsInput",
           "title": "Enter ingredients",
           "detailTitle": "Optional, shown as the title for a popup if user seeks more information",
           "detailText": "Optional, shown as the body for a popup if user seeks more information.",
           "promptPrefix": "Tells the AI what this field is about",
           "required": bool
         }
       ]
     }
   ]
 }
 
 */

//protocol PanelComponent: Identifiable, Codable, Hashable {
//    
//    var id: UUID { get set }
//    
//    var title: String { get set }
//    var detailTitle: String? { get set }
//    var detailText: String? { get set }
//    var promptPrefix: String { get set }
//    var required: Bool? { get set }
//    
//    var finalizedPrompt: String? { get }
//    
//}
//
//extension PanelComponent {
//    
//    var requiredUnwrapped: Bool {
//        get {
//            required ?? false
//        }
//        set {
//            required = newValue
//        }
//    }
//    
//}


IngredientsInputPanelComponent.swift
////
////  IngredientsInputPanelComponent.swift
////  Barback
////
////  Created by Alex Coundouriotis on 9/22/23.
////
//
//import Foundation
//import SwiftUI
//
//struct IngredientsInputPanelComponent: PanelComponent {
//    
//    var id = UUID()
//    
//    var title: String
//    var placeholder: String?
//    var detailTitle: String?
//    var detailText: String?
//    var promptPrefix: String
//    var required: Bool?
//    
//    var text: String = ""
//    
//    var finalizedPrompt: String? {
//        guard !text.isEmpty else {
//            return nil
//        }
//        
//        return promptPrefix + " " + text
//    }
//    
//    var placeholderUnwrapped: String {
//        placeholder ?? defaultPlaceholder
//    }
//    
//    private let defaultPlaceholder = "Tap to start typing..."
//    
//    enum CodingKeys: String, CodingKey {
//        case title
//        case placeholder
//        case detailTitle
//        case detailText
//        case promptPrefix
//        case required
//    }
//    
//}


BarSelectionPanelComponent.swift
////
////  BarSelectionPanelComponent.swift
////  Barback
////
////  Created by Alex Coundouriotis on 9/22/23.
////
//
//import Foundation
//import SwiftUI
//
//struct BarSelectionPanelComponent: PanelComponent {
//    
//    var id = UUID()
//    
//    var title: String
//    var detailTitle: String?
//    var detailText: String?
//    var promptPrefix: String
//    var required: Bool?
//    
//    var selectedBarItems: [BarItem] = []
//    
//    var finalizedPrompt: String? {
//        get {
//            guard selectedBarItems.count > 0 else {
//                return nil
//            }
//            
////            return promptPrefix + selectedBarItems.compactMap(\.item).joined(separator: ", ")
//            return promptPrefix + selectedBarItems.compactMap({$0.item ?? $0.brandName ?? $0.alcoholType}).joined(separator: ", ")
//        }
//    }
//    
//    enum CodingKeys: String, CodingKey {
//        case title
//        case detailTitle
//        case detailText
//        case promptPrefix
//        case required
//    }
//    
//}


DropdownPanelComponentViewConfig.swift
//
//  DropdownPanelComponentViewConfig.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/17/23.
//

import Foundation
import SwiftUI

struct DropdownPanelComponentViewConfig: Identifiable, Codable, Hashable {
    
    var id = UUID()
    
    var placeholder: String?
    var items: [String]
    
    var placeholderUnwrapped: String {
        placeholder ?? defaultPlaceholder
    }
    
    private let defaultPlaceholder = "Tap to Select..."
    
    enum CodingKeys: String, CodingKey {
        case placeholder
        case items
    }
    
}


TitlePanelComponentView.swift
//
//  TitlePanelComponentView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/22/23.
//

import SwiftUI

struct TitlePanelComponentView: View {
    
    var panelComponent: PanelComponent
    
//    var title: String
//    var detailTitle: String?
//    var detailText: String?
    
    @State private var detailPresented = false
    
    var body: some View {
        HStack {
            Text(panelComponent.title)
                .font(.custom(Constants.FontName.body, size: 17.0))
                .minimumScaleFactor(0.5)
                .lineLimit(1, reservesSpace: false)
            
            if panelComponent.requiredUnwrapped {
                Text("*")
                    .font(.custom(Constants.FontName.black, size: 24.0))
                    .foregroundStyle(Colors.elementBackground)
            } else {
                Text("(optional)")
                    .font(.custom(Constants.FontName.light, size: 14.0))
                    .foregroundStyle(Colors.foregroundText)
                    .opacity(0.40)
            }
            
            if panelComponent.detailTitle != nil && panelComponent.detailText != nil {
                Button(action: {
                    HapticHelper.doLightHaptic()
                    
                    detailPresented = true
                }) {
                    Text(Image(systemName: "info.circle"))
//                        .resizable()
//                        .aspectRatio(contentMode: .fit)
                        .font(.custom(Constants.FontName.body, size: 24.0))
//                        .frame(maxHeight: 28)
                }
                .foregroundStyle(Colors.elementBackground)
            }
            
            Spacer()
        }
        .alert(panelComponent.detailTitle ?? "", isPresented: $detailPresented) {
            Button("Done", role: .cancel) {}
        } message: {
            Text(panelComponent.detailText ?? "")
        }
    }
    
}

#Preview {
    let dropdownPanelComponentViewConfig = DropdownPanelComponentViewConfig(
        items: [
            "Item 1",
            "Item 2"
        ])
    
    return VStack {
        TitlePanelComponentView(
            panelComponent: PanelComponent(
                input: .dropdown(dropdownPanelComponentViewConfig),
                title: "Title title title title title title",
                detailTitle: "Detail Title",
                detailText: "Detail Text",
                promptPrefix: "Prompt Prefix",
                required: true)
        )
    }
}


IngredientsInputPanelComponentView.swift
//
//  IngredientsInputPanelComponentView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/22/23.
//

import SwiftUI

struct IngredientsInputPanelComponentView: ComponentView {
    
    var panelComponent: PanelComponent
    var textFieldPanelComponentViewConfig: TextFieldPanelComponentViewConfig
    
    @Binding var isAddPantryItemPopupShowing: Bool
    @Binding var finalizedPrompt: String?
    @Binding var generationAdditionalOptions: RecipeGenerationAdditionalOptions
    
    @State private var isPantryShowing: Bool
    
    @State private var selectedPantryItems: [PantryItem] = []
    @State private var deselectedPantryItems: [PantryItem] = []
//    private var selectedPantryItemsBinding: Binding<[PantryItem]> {
//        Binding(
//            get: {
//                selectedPantryItems
//            },
//            set: { newValue in
//                selectedPantryItems = newValue
//                updateFinalizedPrompt()
//            })
//    }
    
    @State var text: String = ""
//    private var textBinding: Binding<String> {
//        Binding(
//            get: {
//                text
//            },
//            set: { newValue in
//                text = newValue
//                updateFinalizedPrompt()
//            })
//    }
    
    init(panelComponent: PanelComponent, textFieldPanelComponentViewConfig: TextFieldPanelComponentViewConfig, isAddPantryItemPopupShowing: Binding<Bool>, finalizedPrompt: Binding<String?>, generationAdditionalOptions: Binding<RecipeGenerationAdditionalOptions>) {
        self.panelComponent = panelComponent
        self.textFieldPanelComponentViewConfig = textFieldPanelComponentViewConfig
        self._isAddPantryItemPopupShowing = isAddPantryItemPopupShowing
        self._finalizedPrompt = finalizedPrompt
        self._generationAdditionalOptions = generationAdditionalOptions
        self._isPantryShowing = State(initialValue: panelComponent.requiredUnwrapped)
    }
    
    func updateFinalizedPrompt() {
        // Ensure there is either text or at least one selected bar item, otherwise set finalizedPrompt to nil and return
        guard !text.isEmpty || !selectedPantryItems.isEmpty else {
            finalizedPrompt = nil
            return
        }
        
        let panelComponentString = panelComponent.promptPrefix == nil ? "" : panelComponent.promptPrefix! + " "
        let selectedPantryItemsString = selectedPantryItems.isEmpty ? "" : selectedPantryItems.compactMap({$0.name}).joined(separator: ", ") + " "
        let textString = text.isEmpty ? "" : text
        
        finalizedPrompt = panelComponentString + selectedPantryItemsString + textString
    }
    
    
    var body: some View {
        VStack(spacing: 2) {
            TitlePanelComponentView(
                panelComponent: panelComponent)
            PanelTextField(
                placeholder: textFieldPanelComponentViewConfig.placeholderUnwrapped,
                text: $text)
            .onChange(of: selectedPantryItems) { newSelectedPantryItems in
                updateFinalizedPrompt()
            }
            PantrySelectionMiniView(
                selectedPantryItems: $selectedPantryItems,
                generationAdditionalOptions: $generationAdditionalOptions,
                axis: .horizontal)
            .onChange(of: text) { newText in
                updateFinalizedPrompt()
            }
            ExampleComponentView(
                panelComponent: panelComponent)
        }
    }
    
}

@available(iOS 17, *)
#Preview(traits: .sizeThatFitsLayout) {
    let textFieldPanelComponentViewConfig = TextFieldPanelComponentViewConfig()
    
    let panelComponent = PanelComponent(
        input: .ingredientsInput(textFieldPanelComponentViewConfig),
        title: "Title",
        promptPrefix: "Prompt Prefix")
    
    
    return IngredientsInputPanelComponentView(
        panelComponent: panelComponent,
        textFieldPanelComponentViewConfig: textFieldPanelComponentViewConfig,
        isAddPantryItemPopupShowing: .constant(false),
        finalizedPrompt: .constant("asdfasdf"),
        generationAdditionalOptions: .constant(.normal))
    .background(Colors.background)
}


DropdownPanelComponentView.swift
//
//  DropdownPanelComponentView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/22/23.
//

import SwiftUI

struct DropdownPanelComponentView: ComponentView {
    
    var panelComponent: PanelComponent
    var dropdownPanelComponentViewConfig: DropdownPanelComponentViewConfig
    
    @Binding var finalizedPrompt: String?
    @State var selected: String
    
    
    private let noneItem: String = "- None -"
    
//    private var selectedBinding: Binding<String> {
//        Binding(
//            get: {
//                selected
//            },
//            set: { newValue in
//                selected = newValue
//                updateFinalizedPrompt()
//            })
//    }
    
    init(panelComponent: PanelComponent, dropdownPanelComponentViewConfig: DropdownPanelComponentViewConfig, finalizedPrompt: Binding<String?>) {
        self.panelComponent = panelComponent
        self.dropdownPanelComponentViewConfig = dropdownPanelComponentViewConfig
        self._finalizedPrompt = finalizedPrompt
        self._selected = State(initialValue: dropdownPanelComponentViewConfig.placeholderUnwrapped)//State(initialValue: dropdownPanelComponentViewConfig.items.count > 0 ? dropdownPanelComponentViewConfig.items[0] : "")
    }
    
    func updateFinalizedPrompt() {
        // Ensure an item is selected by checking if selected is not empty, otherwise set finalizedPrompt to nil and return
        guard !selected.isEmpty else {
            finalizedPrompt = nil
            return
        }
        
        // Ensure selected item is not noneItem, otherwise set finalizedPrompt to nil and return
        guard selected != noneItem else {
            finalizedPrompt = nil
            return
        }
        
        // Set finalizedPrompt to panelComponent prompt prefix if not nil, a space, and selected item
        finalizedPrompt = (panelComponent.promptPrefix == nil ? "" : panelComponent.promptPrefix! + " ") + selected
    }
    
    var body: some View {
        VStack(spacing: 2) {
            TitlePanelComponentView(
                panelComponent: panelComponent)
            HStack {
                // Picker
                Menu {
                    Picker(selection: $selected, content: {
                        // Build each item in items in Text
                        ForEach(panelComponent.required ?? false ? dropdownPanelComponentViewConfig.items : ([noneItem] + dropdownPanelComponentViewConfig.items), id: \.self) { item in
                            Text(item)
                        }
                    }) {
                        // No label
                        Text(selected)
                            .font(.custom(Constants.FontName.medium, size: 17.0))
                        Image(systemName: "chevron.up.chevron.down")
                    }
                    .onChange(of: selected) { newSelected in
                        updateFinalizedPrompt()
                    }
                } label: {
                    Text(selected)
                        .font(.custom(Constants.FontName.medium, size: 17.0))
                    Image(systemName: "chevron.up.chevron.down")
                }
                .menuOrder(.fixed)
                .menuIndicator(.visible)
                .padding(15)
//                .background(
//                    RoundedRectangle(
//                        cornerRadius: 20.0)
//                    .fill(Colors.foreground))
                .background(
                    ZStack {
                        RoundedRectangle(
                            cornerRadius: 20.0)
                        .fill(Colors.foreground)
                        
                        RoundedRectangle(
                            cornerRadius: 20.0)
                        .stroke(lineWidth: 2.0)
                        .foregroundStyle(Colors.elementBackground)
                    })
                Spacer()
            }
            .foregroundStyle(Colors.foregroundText)
            ExampleComponentView(
                panelComponent: panelComponent)
        }
    }
    
}

#Preview {
    let dropdownPanelComponentViewConfig = DropdownPanelComponentViewConfig(
        items: [
            "First",
            "Second"
        ])
    let panelComponent = PanelComponent(
        input: .dropdown(dropdownPanelComponentViewConfig),
        title: "Title",
        promptPrefix: "Prompt Prefix",
        required: true)
    
    let selected = dropdownPanelComponentViewConfig.items.count > 0 ? dropdownPanelComponentViewConfig.items[0] : ""
    
    return DropdownPanelComponentView(
        panelComponent: panelComponent,
        dropdownPanelComponentViewConfig: dropdownPanelComponentViewConfig,
        finalizedPrompt: .constant("asdfasdf"))
    .background(Colors.background)
}


ComponentView.swift
//
//  ComponentView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/24/23.
//

import SwiftUI

protocol ComponentView: View {
    
    var finalizedPrompt: String? { get set }
    
}


PanelTextField.swift
//
//  PanelTextField.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/22/23.
//

import SwiftUI

struct PanelTextField: View {
    
    var placeholder: String
    
    @Binding var text: String
    
    
    @Environment(\.colorScheme) private var colorScheme
    
    var body: some View {
        HStack {
            TextField(placeholder, text: $text, axis: .vertical)
                .textFieldTickerTint(colorScheme == .light ? Colors.elementBackground : Colors.foregroundText) // TODO: Make sure the light mode ticker tint is correct, I removed textFieldTickerTint which was controlling the tint here
                .keyboardDismissingTextFieldToolbar("Done", color: Colors.elementBackground)
            .padding()
            .font(.custom(Constants.FontName.body, size: 17.0))
            .lineLimit(.max)
//                Spacer()
        }
        .modifier(RoundedBorderModifier(strokeStyle: Colors.background))
    }
    
}

#Preview {
    PanelTextField(
        placeholder: "Placeholder",
        text: .constant("Text")
    )
    .background(Colors.background)
}


PantrySelectionPanelComponentView.swift
//
//  BarSelectionPanelComponentView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/22/23.
//

import PopupView
import SwiftUI

struct PantrySelectionPanelComponentView: ComponentView {
    
    var panelComponent: PanelComponent
    
    @Binding var isAddPantryItemPopupShowing: Bool
    @Binding var finalizedPrompt: String?

    
    @State private var isPantryShowing: Bool
    @State private var selectedPantryItems: [PantryItem] = []
    @State private var generationAdditionalOptions: RecipeGenerationAdditionalOptions = .normal
    
    init(panelComponent: PanelComponent, isAddPantryItemPopupShowing: Binding<Bool>, finalizedPrompt: Binding<String?>) {
        self.panelComponent = panelComponent
        self._isAddPantryItemPopupShowing = isAddPantryItemPopupShowing
        self._finalizedPrompt = finalizedPrompt
        self._isPantryShowing = State(initialValue: panelComponent.requiredUnwrapped)
    }
    
    /* BODY */
    var body: some View {
        
        VStack(spacing: 2) {
            TitlePanelComponentView(
                panelComponent: panelComponent)
            PantrySelectionMiniView(
                selectedPantryItems: $selectedPantryItems,
                showsAdvancedOptions: false,
                generationAdditionalOptions: $generationAdditionalOptions,
                axis: .horizontal)
            .padding([.leading, .trailing], -16)
            .onChange(of: selectedPantryItems) { newSelectedPantryItems in
                updateFinalizedPrompt()
            }
            ExampleComponentView(
                panelComponent: panelComponent)
        }
    }
    
    /* PRIVATE FUNCTIONOS */
    private func updateFinalizedPrompt() {
        guard selectedPantryItems.count > 0 else {
            finalizedPrompt = nil
            return
        }
        
        finalizedPrompt = (panelComponent.promptPrefix == nil ? "" : panelComponent.promptPrefix! + " ") + selectedPantryItems.compactMap({$0.name ?? $0.category}).joined(separator: ", ")
    }
    
}

@available(iOS 17, *)
#Preview(traits: .sizeThatFitsLayout) {
    let panelComponent = PanelComponent(
        input: .barSelection,
        title: "Title",
        example: "ex. Example",
        detailTitle: "Detail Title",
        detailText: "Detail Text",
        promptPrefix: "Prompt Prefix",
        required: false)
    
    return PantrySelectionPanelComponentView(
        panelComponent: panelComponent,
        isAddPantryItemPopupShowing: .constant(false),
        finalizedPrompt: .constant("asdf"))
    .background(Colors.background)
}


ExampleComponentView.swift
//
//  ExampleComponentView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/10/23.
//

import SwiftUI

struct ExampleComponentView: View {
    
    var panelComponent: PanelComponent
    
    var body: some View {
        if let example = panelComponent.example {
            HStack {
                Text("ex. \(example)")
                    .font(.custom(Constants.FontName.lightOblique, size: 12.0))
                    .foregroundStyle(Colors.foregroundText)
                    .opacity(0.6)
                Spacer()
            }
        }
    }
}

@available(iOS 17.0, *)
#Preview(traits: .sizeThatFitsLayout) {
    ExampleComponentView(panelComponent: PanelComponent(
        input: .textField(TextFieldPanelComponentViewConfig()),
        title: "Title",
        example: "Example",
        promptPrefix: "Prompt Prefix"))
}


TextFieldPanelComponentView.swift
//
//  TextFieldPanelComponentView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/22/23.
//

import SwiftUI

struct TextFieldPanelComponentView: ComponentView {
    
    var panelComponent: PanelComponent
    var textFieldPanelComponentViewConfig: TextFieldPanelComponentViewConfig
    
    @Binding var finalizedPrompt: String?
    @State var text: String = ""
    
    
    var body: some View {
        
        VStack(spacing: 2) {
            TitlePanelComponentView(
                panelComponent: panelComponent)
            PanelTextField(
                placeholder: textFieldPanelComponentViewConfig.placeholderUnwrapped,
                text: $text)
            .onChange(of: text) { newText in
                updateFinalizedPrompt()
            }
            ExampleComponentView(
                panelComponent: panelComponent)
        }
        
    }
    
    func updateFinalizedPrompt() {
        guard !text.isEmpty else {
            finalizedPrompt = nil
            return
        }
        
        finalizedPrompt = (panelComponent.promptPrefix == nil ? "" : panelComponent.promptPrefix! + " ") + text
    }
    
}

@available(iOS 17, *)
#Preview(traits: .sizeThatFitsLayout) {
    let textFieldPanelComponentViewConfig = TextFieldPanelComponentViewConfig()
    
    let panelComponent = PanelComponent(
        input: .textField(textFieldPanelComponentViewConfig),
        title: "Title",
        detailTitle: "Test Detail Title",
        detailText: "Test Detail Text",
        promptPrefix: "Prompt Prefix",
        required: true)
    
    return TextFieldPanelComponentView(
        panelComponent: panelComponent,
        textFieldPanelComponentViewConfig: textFieldPanelComponentViewConfig,
        finalizedPrompt: .constant("asdf"))
    .padding()
    .background(Colors.background)
}


PanelView.swift
//
//  PanelView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/21/23.
//

import CoreData
import Foundation
import SwiftUI

struct PanelView: View {
    
    @ObservedObject var recipeGenerator: RecipeGenerator
    @State var panel: Panel
    @Binding var isShowing: Bool
//    var namespace: Namespace.ID
    
    
    @Environment(\.presentationMode) private var presentationMode: Binding<PresentationMode>
    @Environment(\.requestReview) private var requestReview
    
    @EnvironmentObject private var premiumUpdater: PremiumUpdater
    @EnvironmentObject private var remainingUpdater: RemainingUpdater

    var btnBack : some View { Button(action: {
            HapticHelper.doLightHaptic()
        
            self.presentationMode.wrappedValue.dismiss()
        }) {
            HStack {
                Text("Go Back")
                    .foregroundStyle(.black)
            }
        }
    }
    
    @StateObject private var adOrReviewCoordinator = AdOrReviewCoordinator()
    
    @State private var generationAdditionalOptions: RecipeGenerationAdditionalOptions = .normal
    
    @State private var finalizedPrompt: String = ""
    
    @State private var isAddBarItemPopupShowing: Bool = false
    
    @State private var isShowingUltraView: Bool = false
    
    @State private var recipeGenerationSpec: RecipeGenerationSpec?
    
    @GestureState private var dragOffset = CGSize.zero
    
//    @State private var finalizedPrompt: String = ""
    
    @State private var alertShowingGenerationError: Bool = false
    @State private var alertShowingCapReached: Bool = false
    
    var isShowingRecipeGenerationView: Binding<Bool> {
        Binding(
            get: {
                recipeGenerationSpec != nil
            },
            set: { value in
                if !value {
                    recipeGenerationSpec = nil
                    requestReview.callAsFunction()
                }
            })
    }
    
//    @State private var panelComponents: [PanelComponent]
//    private var panelComponentsBinding: Binding<[PanelComponent]> {
//        Binding(get: {
//            if let components = panel?.components {
//                return components
//            }
//            
//            return []
//        },
//        set: { newValue in
//            panel?.components = newValue
//        })
//    }
    
    private var submitButtonDisabled: Bool {
        finalizedPrompt == "" || recipeGenerator.isCreating
    }
    
//    init(recipeGenerator: RecipeGenerator, panel: Panel, namespace: Namespace.ID) {
//        self.recipeGenerator = recipeGenerator
//        self._panel = State(initialValue: panel)
//        self.namespace = namespace
//    }
    
    
    var body: some View {
        ZStack {
            VStack {
//                header
                
                ScrollView {
                    VStack {
                        // Header
                        
                        // Title Card
                        titlePanelCard
                        
                        // Panels
                        panelsStack
                            .onChange(of: panel.components) { newPanelComponents in
                                updateFinalizedPrompt()
                            }
                        
                    }
                    .padding()
                }
                
                Spacer()
                
                // Submit Button
                submitButton
                
                Spacer()
            }
//            .popup(isPresented: $isAddBarItemPopupShowing, view: {
//                GeometryReader { geometry in
//                    VStack {
//                        Spacer()
//                        HStack {
//                            Spacer()
//                            InsertBarItemView(
//                                isShowing: $isAddBarItemPopupShowing,
//                                textFieldColor: Colors.foreground,
//                                elementColor: Colors.elementColor)
//                                .padding(24.0)
//                                .background(Colors.background)
//                                .frame(width: geometry.size.width * (8 / 9))
//                                .cornerRadius(28.0)
//                            Spacer()
//                        }
//                        Spacer()
//                    }
//                }
//                .transition(.move(edge: .bottom))
//            }, customize: { popup in
//                popup
//                    .backgroundView({
//                        Color.clear
//                            .background(Material.ultraThin)
//                    })
//                    .closeOnTap(false)
//            })
        }
//        .circleBackground(
//            backgroundIndex: .constant(1),
//            colorUpdater: Colors)
//        .barbackHeader(backgroundColor: colorUpdater.elementColor, showsDivider: true, left: {
//            Button(action: {
//                withAnimation {
//                    isShowing = false
//                }
//            }) {
//                Text("Close")
//                    .font(.custom(Constants.FontName.black, size: 20.0))
//                    .foregroundStyle(Colors.elementText)
//                    .padding(.bottom, 8)
//                    .padding(.leading)
//            }
//        }, right: {
//            
//        })
//        .background(colorUpdater.elementColor)
        .toolbar {
            LogoToolbarItem()
            UltraToolbarItem(color: Colors.navigationItemColor)
        }
        .toolbarBackground(Colors.secondaryBackground, for: .navigationBar)
        .toolbarBackground(.visible, for: .navigationBar)
        .fullScreenCover(isPresented: isShowingRecipeGenerationView) {
//            var _didSaveRecipe: Bool = false
//            var didSaveRecipe: Binding = Binding(
//                get: {
//                    _didSaveRecipe
//                },
//                set: { newValue in
//                    if newValue {
//                        // TODO: Should this be somewhere else, maybe an onChange for a State?
//                        isShowingRecipeGenerationView = false
//                        isShowing = false
//                    }
//                    
//                    print(newValue)
//                    
//                    _didSaveRecipe = newValue
//                })
            if let recipeGenerationSpec {
                ZStack {
                    // TODO: Is it okay to have false for useAllIngredients here, or should it be true or defined in the panel spec and optionally get user input
                    RecipeGenerationView(
                        recipeGenerator: recipeGenerator,
                        recipeGenerationSpec: recipeGenerationSpec,
                        onDismiss: { isShowingRecipeGenerationView.wrappedValue = false },
                        didSaveRecipe: { _ in
                            // Dismiss
                            isShowingRecipeGenerationView.wrappedValue = false
                            isShowing = false
                            
                            // Show ad or review
                            Task {
                                await adOrReviewCoordinator.showWithCooldown(isPremium: premiumUpdater.isPremium)
                            }
                        })
                    .background(Colors.background)
                }
            }
        }
        .capReachedErrorAlert(isPresented: $alertShowingCapReached, isShowingUltraView: $isShowingUltraView)
        .interstitialInBackground(
            interstitialID: Keys.GAD.Interstitial.panelViewGenerate,
            disabled: premiumUpdater.isPremium,
            isPresented: $adOrReviewCoordinator.isShowingInterstitial)
        .ultraViewPopover(isPresented: $isShowingUltraView)
        .onReceive(adOrReviewCoordinator.$requestedReview) { newValue in
            if newValue {
                requestReview()
            }
        }
        .alert("Error Crafting", isPresented: $alertShowingGenerationError, actions: {
            Button("Close", role: .cancel, action: {
                
            })
        }) {
            Text("There was an issue crafting your recipe. Please try again later.")
        }
        
    }
    
//    var header: some View {
//        ZStack {
//            HStack {
//                VStack {
//                    Spacer()
//                    Button(action: {
//                        withAnimation {
//                            isShowing = false
//                        }
//                    }) {
//                        Text("Close")
//                            .font(.custom(Constants.FontName.black, size: 20.0))
//                            .foregroundStyle(Colors.elementText)
//                            .padding(.bottom, 8)
//                            .padding(.leading)
//                    }
//                }
//                Spacer()
//            }
//            
//            HStack {
//                Spacer()
//                VStack {
//                    Spacer()
//                    Text("Barback")
//                        .font(.custom(Constants.FontName.black, size: 28.0))
//                        .foregroundStyle(Colors.elementText)
//                        .padding(4)
//                }
//                Spacer()
//            }
//        }
//        .frame(height: 100)
//        .background(foregroundColor)
//    }
    
    var titlePanelCard: some View {
//        ZStack {
            HStack {
//                Spacer()
                HStack {
                    Spacer()
                    Text(panel.emoji)
                        .font(.custom(Constants.FontName.black, size: 38.0))
                        .lineLimit(.max)
                        .multilineTextAlignment(.center)
                    VStack {
                        // Card
                        HStack {
                            Text(panel.title)
                                .font(.custom(Constants.FontName.black, size: 20.0))
                                .lineLimit(.max)
                                .multilineTextAlignment(.center)
                                .minimumScaleFactor(0.5)
                            //                    Spacer()
                        }
                        HStack {
                            Text(panel.summary)
                                .font(.custom(Constants.FontName.body, size: 14.0))
                                .multilineTextAlignment(.center)
                                .minimumScaleFactor(0.5)
                            //                    Spacer()
                        }
                        
                    }
                    Spacer()
                }
            }
            .padding()
//        }
        .background(
            RoundedRectangle(cornerRadius: 28.0)
                .fill(Colors.foreground)
        )
//        .clipShape(RoundedRectangle(cornerRadius: 28.0))
    }
    
    var panelsStack: some View {
//        panel?.components[0].finalizedPrompt = "asdf"
        ForEach($panel.components) { $component in
            switch component.input {
            case .barSelection:
                PantrySelectionPanelComponentView(
                    panelComponent: component,
                    isAddPantryItemPopupShowing: $isAddBarItemPopupShowing,
                    finalizedPrompt: $component.finalizedPrompt)
            case .dropdown(let viewConfig):
                DropdownPanelComponentView(
                    panelComponent: component,
                    dropdownPanelComponentViewConfig: viewConfig,
                    finalizedPrompt: $component.finalizedPrompt)
            case .ingredientsInput(let viewConfig):
                IngredientsInputPanelComponentView(
                    panelComponent: component,
                    textFieldPanelComponentViewConfig: viewConfig,
                    isAddPantryItemPopupShowing: $isAddBarItemPopupShowing,
                    finalizedPrompt: $component.finalizedPrompt,
                    generationAdditionalOptions: $generationAdditionalOptions)
            case .textField(let viewConfig):
                TextFieldPanelComponentView(
                    panelComponent: component,
                    textFieldPanelComponentViewConfig: viewConfig,
                    finalizedPrompt: $component.finalizedPrompt)
            }
            Spacer(minLength: 20)
        }
    }
    
    var submitButton: some View {
        Button(action: {
            HapticHelper.doMediumHaptic()
            
            withAnimation {
                recipeGenerationSpec = RecipeGenerationSpec(
                    pantryItems: [],
                    suggestions: [],
                    input: finalizedPrompt,
                    generationAdditionalOptions: generationAdditionalOptions)
            }
        }) {
            Spacer()
            ZStack {
                Text("Create Recipe...")
                    .font(.custom(Constants.FontName.black, size: 24.0))
                    .foregroundStyle(Colors.elementText)
                HStack {
                    Spacer()
                    if !recipeGenerator.isCreating {
                        // Right chevron if not creating
                        Image(systemName: "chevron.right")
                            .font(.custom(Constants.FontName.heavy, size: 24.0))
                            .foregroundStyle(Colors.elementText)
                    } else {
                        // Progress view if creating
                        ProgressView()
                            .font(.custom(Constants.FontName.heavy, size: 24.0))
                            .tint(Colors.elementText)
                    }
                }
            }
            Spacer()
        }
        .disabled(submitButtonDisabled)
        .modifier(CardModifier(backgroundColor: Colors.elementBackground))
        .bounceable(disabled: submitButtonDisabled)
        .opacity(submitButtonDisabled ? 0.4 : 1.0)
        .padding()
    }
    
    private func updateFinalizedPrompt() {
        // TODO: I don't think that it's using the "prompt" text when creating the finalized prompt, so maybe that's something that needs to be fixed?
        
        let commaSeparator = ", "
        
        // Build completeFinalizedPrompt, ensuring that all required values' finalizedPrompts are not nil and return
        var completeFinalizedPrompt = ""
        for i in 0..<panel.components.count {
            let component = panel.components[i]
            
            // Unswrap finalizedPrompt, otherwise either return nil or continue
            guard let finalizedPrompt = component.finalizedPrompt else {
                // If required, return nil
                if component.requiredUnwrapped {
                    finalizedPrompt = ""
                    return
                }
                
                // Otherwise, continue
                continue
            }
            
            // Append to completeFinalizedPrompt
            completeFinalizedPrompt.append(finalizedPrompt)
            
            // If not the last index in panel.components, append the comma separator
            if i < panel.components.count - 1 {
                completeFinalizedPrompt.append(commaSeparator)
            }
        }
        
        finalizedPrompt = completeFinalizedPrompt
    }
    
}


#Preview {
//    @Namespace var namespace
    
    return PanelView(
        recipeGenerator: RecipeGenerator(),
        panel: Panel(
            emoji: "😊",
            title: "This is a Title",
            summary: "This is the description for the title",
            prompt: "Prompt",
            components: [
                PanelComponent(
                    input: .textField(TextFieldPanelComponentViewConfig(
                        placeholder: "Text Field Panel Component Placeholder")),
                    title: "Text Field Panel Title",
                    detailTitle: "Test Detail Title",
                    detailText: "Test Detail Text",
                    promptPrefix: "Text Field Panel Component Prompt Prefix",
                    required: true),
                PanelComponent(
                    input: .dropdown(DropdownPanelComponentViewConfig(
                        items: [
                            "First item",
                            "Second item"
                        ])),
                    title: "Dropdown Panel Title",
                    detailTitle: "Test Detail Title",
                    detailText: "Test Detail Text",
                    promptPrefix: "Dropdown Panel Prompt Prefix",
                    required: true),
                PanelComponent(
                    input: .barSelection,
                    title: "Bar Selection Component Title",
                    promptPrefix: "Bar Selection Component Prompt Prefix",
                    required: true)
        ]),
        isShowing: .constant(true))
        .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
        .environmentObject(PremiumUpdater())
        .environmentObject(ProductUpdater())
        .environmentObject(RemainingUpdater())
        .background(Colors.background)
}


PanelMiniView.swift
//
//  PanelMiniView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/18/23.
//

import Foundation
import SwiftUI

struct PanelMiniView<S: ShapeStyle & View, T: ShapeStyle>: View {
    
    var panel: Panel
    var textStyle: T
    var background: S
    
    var namespace: Namespace.ID
    
    var body: some View {
        ZStack {
//            Colors.foreground
//                .matchedGeometryEffect(id: "background", in: namespace)
            VStack {
                HStack {
                    Text(panel.emoji)
                        .font(.custom(Constants.FontName.black, fixedSize: 34.0))
//                        .aspectRatio(contentMode: .fit)
                    Spacer()
                }
                
                HStack {
                    Text(panel.title)
                        .font(Font.custom("avenir-black", fixedSize: 17.0))
                        .lineLimit(2)
                        .foregroundStyle(textStyle)
                        .multilineTextAlignment(.leading)
                        .padding(.bottom, 2)
                        .minimumScaleFactor(0.5)
                    Spacer()
                }
                
                HStack {
                    Text(panel.summary)
                        .font(Font.custom("avenir-book", size: 12.0))
                        .foregroundStyle(textStyle)
                        .multilineTextAlignment(.leading)
                        .minimumScaleFactor(0.5)
                    Spacer(minLength: 0)
                }
                Spacer()
            }
        }
        .padding([.leading, .trailing])
        .padding([.top, .bottom], 8)
        .frame(width: 180, height: 140)
//        .background(
//            RoundedRectangle(cornerRadius: 28.0)
//                .fill(background)
//        )
//        .clipShape(RoundedRectangle(cornerRadius: 28.0))
    }
    
}

@available(iOS 17, *)
#Preview("Create Panel", traits: .sizeThatFitsLayout) {
    @Namespace var namespace
    
    return PanelMiniView(
        panel: Panel(
            emoji: "😊",
            title: "Title",
            summary: "Description",
            prompt: "Prompt",
            components: []),
        textStyle: Colors.foregroundText,
        background: Colors.background,
        namespace: namespace)
}


IntroPresenterView.swift
//
//  IntroPresenterView.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 11/1/23.
//

import AVKit
//import FirebaseAnalytics
import SwiftUI

struct IntroPresenterView: View {
    
    @Binding var isShowing: Bool
    
    
    @Environment(\.colorScheme) private var colorScheme
    
    
    private let lightModeIntroNew1Name = "Intro New 1 Light"
    private let lightModeIntroNew1Extension = "mp4"
    private let darkModeIntroNew1Name = "Intro New 1 Dark"
    private let darkModeIntroNew1Extension = "mp4"
    
    private let lightModeIntroNew2Name = "Intro New 2 Light"
    private let lightModeIntroNew2Extension = "mp4"
    private let darkModeIntroNew2Name = "Intro New 2 Dark"
    private let darkModeIntroNew2Extension = "mp4"
    
    static let lightModeImage1Name = "Intro Screenshot 1 Light"
    static let darkModeImage1Name = "Intro Screenshot 1 Dark"
    static let lightModeImage2Name = "Intro Screenshot 2 Light"
    static let darkModeImage2Name = "Intro Screenshot 2 Dark"
    
    private let videoAspectRatio = 1284.0/2778.0
    
    private let showFirstButtonLoadingDelay: CGFloat = 1.0
    
    
//    @State private var video1AVPlayer: AVPlayer
//    @State private var video2AVPlayer: AVPlayer
    
    @State private var isShowingFirstButtonLoading: Bool = true
    
    
    init(isShowing: Binding<Bool>) {
        self._isShowing = isShowing
        
        let initialColorScheme: ColorScheme = UIScreen.main.traitCollection.userInterfaceStyle == .dark ? .dark : .light
//        self._video1AVPlayer = State(initialValue: IntroPresenterView.setupAVPlayer(
//            lightVideoName: lightModeIntroNew1Name,
//            lightVideoExtension: lightModeIntroNew1Extension,
//            darkVideoName: darkModeIntroNew1Name,
//            darkVideoExtension: darkModeIntroNew1Extension,
//            colorScheme: initialColorScheme))
//        self._video2AVPlayer = State(initialValue: IntroPresenterView.setupAVPlayer(
//            lightVideoName: lightModeIntroNew2Name,
//            lightVideoExtension: lightModeIntroNew2Extension,
//            darkVideoName: darkModeIntroNew2Name,
//            darkVideoExtension: darkModeIntroNew1Extension,
//            colorScheme: initialColorScheme))
    }
    
    
    var body: some View {
//        let generateImageAVPlayer = AVPlayer(url: Bundle.main.url(
//            forResource: colorScheme == .light ? lightModeIntroNew1Name : darkModeIntroNew1Name,
//            withExtension: colorScheme == .light ? lightModeIntroNew1Extension : darkModeIntroNew1Extension)!)
//        let scanImageAVPlayer = AVPlayer(url: Bundle.main.url(
//            forResource: colorScheme == .light ? lightModeIntro2Name : darkModeIntro2Name,
//            withExtension: colorScheme == .light ? lightModeIntro2Extension : darkModeIntro2Extension)!)
        
        NavigationStack {
            IntroView(
                image: Image(uiImage: UIImage(named: colorScheme == .dark ? IntroPresenterView.darkModeImage1Name : IntroPresenterView.lightModeImage1Name)!),
                isShowingButtonLoading: $isShowingFirstButtonLoading,
                destination: {
                    IntroView(
                        image: Image(uiImage: UIImage(named: colorScheme == .dark ? IntroPresenterView.darkModeImage2Name : IntroPresenterView.lightModeImage2Name)!),
                        isShowingButtonLoading: $isShowingFirstButtonLoading,
                        destination: {
                            UltraView(isShowing: $isShowing)
                                .toolbar(.hidden, for: .navigationBar)
                                .onAppear {
                                    IntroManager.isIntroComplete = true
                                }
                        })
//                IntroVideoView(
//                    avPlayer: $video1AVPlayer,
//                    showReplayDelay: 3.0,
//                    videoAspectRatio: videoAspectRatio,
//                    destination: {
//                        IntroVideoView(
//                            avPlayer: $video2AVPlayer,
//                            showReplayDelay: 2.0,
//                            videoAspectRatio: videoAspectRatio,
//                            destination: {
////                                IntroAssistantSelectionView {
//                                    UltraView(isShowing: $isShowing)
//                                        .toolbar(.hidden, for: .navigationBar)
//                                        .onAppear {
////                                            // Log fifth intro view
////                                            Analytics.logEvent("intro_progression_v5.4", parameters: [
////                                                "view": 5 as NSObject
////                                            ])
////                                            
////                                            Analytics.logEvent(AnalyticsEventScreenView,
////                                                               parameters: [AnalyticsParameterScreenName: "UltraViewFromIntro",
////                                                                           AnalyticsParameterScreenClass: "UltraViewFromIntro"])
//                                            
//                                            IntroManager.isIntroComplete = true
//                                        }
//                            })
//                        .onAppear {
////                            // Log third intro view
////                            Analytics.logEvent("intro_progression_v5.4", parameters: [
////                                "view": 3 as NSObject
////                            ])
////                            
////                            Analytics.logEvent(AnalyticsEventScreenView,
////                                               parameters: [AnalyticsParameterScreenName: "IntroView3",
////                                                           AnalyticsParameterScreenClass: "IntroView3"])
//                        }
//                    })
//                .onAppear {
////                    // Log second intro view
////                    Analytics.logEvent("intro_progression_v5.4", parameters: [
////                        "view": 2 as NSObject
////                    ])
////                    
////                    Analytics.logEvent(AnalyticsEventScreenView,
////                                       parameters: [AnalyticsParameterScreenName: "IntroView2",
////                                                   AnalyticsParameterScreenClass: "IntroView2"])
//                }
            })
            .onAppear {
//                // Log first intro view
//                Analytics.logEvent("intro_progression_v5.4", parameters: [
//                    "view": 1 as NSObject
//                ])
//                
//                Analytics.logEvent(AnalyticsEventScreenView,
//                                   parameters: [AnalyticsParameterScreenName: "IntroView1",
//                                               AnalyticsParameterScreenClass: "IntroView1"])
            }
        }
        .onAppear {
            DispatchQueue.main.async {
                // Load AVPlayerViewController so that video loading is faster
                AVPlayerViewController.load()
            }
            
            DispatchQueue.main.asyncAfter(deadline: .now() + showFirstButtonLoadingDelay) {
                withAnimation {
                    self.isShowingFirstButtonLoading = false
                }
            }
        }
    }
    
    
    static func setupAVPlayer(lightVideoName: String, lightVideoExtension: String, darkVideoName: String, darkVideoExtension: String, colorScheme: ColorScheme) -> AVPlayer {
        AVPlayer(url: Bundle.main.url(
            forResource: colorScheme == .light ? lightVideoName : darkVideoName,
            withExtension: colorScheme == .light ? lightVideoExtension : darkVideoExtension)!)
    }
    
}

#Preview {
    IntroPresenterView(
        isShowing: .constant(true))
        .environmentObject(PremiumUpdater())
        .environmentObject(ProductUpdater())
}


BackgroundVideoView.swift
//
//  BackgroundVideoView.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 3/2/24.
//

import _AVKit_SwiftUI
import AVFoundation
import Foundation
import SwiftUI

struct BackgroundVideoView: View {
    
    @State var imageName: String
    @State var imageExtension: String
    
    
    @State private var avPlayer: AVPlayer
    
    
    init(imageName: String, imageExtension: String) {
        self._imageName = State(initialValue: imageName)
        self._imageExtension = State(initialValue: imageExtension)
        
        self._avPlayer = State(initialValue: AVPlayer(url: Bundle.main.url(forResource: imageName, withExtension: imageExtension)!))
    }
    
    
    var body: some View {
        ZStack {
            VideoViewRepresentable(player: $avPlayer)
//                .ignoresSafeArea()
        }
    }
    
}

#Preview {
    
    BackgroundVideoView(
        imageName: "Scan Image Light",
        imageExtension: "m4v")
    
}


IntroAssistantSelectionView.swift
////
////  IntroAssistantSelectionView.swift
////  WriteSmith-SwiftUI
////
////  Created by Alex Coundouriotis on 3/30/24.
////
//
//import CoreData
//import Foundation
//import SwiftUI
//
//struct IntroAssistantSelectionView<Content: View>: View {
//    
////    @Binding var isPresented: Bool
//    @ViewBuilder var destination: ()->Content
//    
//    
//    @Environment(\.managedObjectContext) private var viewContext
//    
//    @FetchRequest(
//        sortDescriptors: [NSSortDescriptor(key: #keyPath(Assistant.usageMessages), ascending: false)],
//        predicate: NSPredicate(format: "%K = %d and %K = %d", #keyPath(Assistant.featured), true, #keyPath(Assistant.premium), false),
//        animation: .default)
//    private var assistants: FetchedResults<Assistant>
//    
//    @State private var faceDiameter: CGFloat = 106.0
//    @State private var faceFrame: CGRect = CGRect(x: 0, y: 0, width: 106.0, height: 106.0) // Width and height should be the same as faceDiameter
//    @State private var facialFeaturesScaleFactor: CGFloat = 0.76
//    @State private var faceColor: UIColor = UIColor(Colors.elementBackgroundColor)
//    @State private var faceStartAnimation: FaceAnimation = SmileCenterFaceAnimation(duration: 0.0)
//    @State private var circleInnerPadding: CGFloat = 0.0
//    
//    @State private var isShowingDestination: Bool = false
//    
//    @State private var isPulsatingNextButton: Bool = false
//    
//    @State private var selectedAssistant: Assistant?
//    
//    
//    var body: some View {
//        ZStack {
//            VStack {
//                Spacer()
//                
//                // Title
//                VStack(spacing: -12.0) {
//                    HStack {
//                        Text("Select Your")
//                        
//                        Spacer()
//                    }
//                    
//                    HStack {
//                        Text("Assistant...")
//                        
//                        Spacer()
//                    }
//                }
//                .font(.custom(Constants.FontName.heavy, size: 58.0))
//                .foregroundStyle(Colors.elementTextColor)
//                .lineLimit(2)
//                .minimumScaleFactor(0.5)
//                .padding([.leading, .trailing], 28)
//                
//                // Subtitle
//                HStack {
//                    VStack {
//                        Text("Choose your favorite **AI Assistant** to begin chatting. You can easily try other Assistants.")
//                            .font(.custom(Constants.FontName.bodyOblique, size: 14.0))
//                            .foregroundStyle(Colors.elementTextColor)
//                            .opacity(0.6)
//                    }
//                    
//                    Spacer()
//                }
//                .padding([.leading, .trailing], 28)
//                
//                faceAssistants
//                    .padding(28)
//                
//                Spacer()
//                
//                // Next Button
//                Button(action: {
//                    // Unwrap selectedAssistant, otherwise return
//                    guard let selectedAssistant = selectedAssistant else {
//                        // TODO: Handle errors if necessary
//                        print("Error unwrapping selectedAssistant in IntroAssistantSelectionView!")
//                        return
//                    }
//                    
//                    // Set as current Assistant
//                    do {
//                        try CurrentAssistantPersistence.setAssistant(selectedAssistant, in: viewContext)
//                    } catch {
//                        // TODO: Handle Errors
//                        print("Error setting Assistant to CurrentAssistantPersistence in IntroAssistantSelectionView... \(error)")
//                    }
//                    
//                    // Create Conversation with selectedAssistant and set in ConversationResumingManager
//                    do {
//                        let conversation = try ConversationCDHelper.appendConversation(
//                            modelName: GPTModels.gpt3turbo.rawValue,
//                            assistant: selectedAssistant,
//                            in: viewContext)
//                        
//                        do {
//                            try ConversationResumingManager.setConversation(conversation, in: viewContext)
//                        } catch {
//                            // TODO: Handle Errors
//                            print("Error setting Conversation to ConversationResumingManager in IntroAssistantSelectionView... \(error)")
//                        }
//                    } catch {
//                        // TODO: Handle Errors
//                        print("Error appending Conversation in IntroAssistantSelectionView... \(error)")
//                    }
//                    
//                    // Show destination
//                    DispatchQueue.main.async {
////                        self.isPresented = false
//                        self.isShowingDestination = true
//                    }
//                }) {
//                    ZStack {
//                        Text("Next...")
//                            .font(.custom(Constants.FontName.heavy, size: 24.0))
//                        
//                        HStack {
//                            Spacer()
//                            Text(Image(systemName: "chevron.right"))
//                        }
//                    }
//                }
//                .disabled(self.selectedAssistant == nil)
//                .padding()
//                .foregroundStyle(Colors.elementTextColor)
////                .foregroundStyle(Colors.elementBackgroundColor)
//                .background(Colors.buttonBackground)
////                .background(Colors.foreground)
//                .clipShape(RoundedRectangle(cornerRadius: UIConstants.cornerRadius))
//                .opacity(self.selectedAssistant == nil ? 0.4 : 1.0)
//                .padding()
//                .animatesPulsate(
//                    isPulsating: $isPulsatingNextButton,
//                    minScale: CGSize(width: 0.96, height: 0.96),
//                    maxScale: CGSize(width: 1.00, height: 1.00),
//                    speed: 0.5)
//                .animatesShake(
//                    isMoving: $isPulsatingNextButton,
//                    maxAngle: .degrees(0.5),
//                    speed: 0.25)
//            }
//        }
//        .background(Colors.elementBackgroundColor)
//        .navigationBarBackButtonHidden(true)
//        .onAppear {
//            // Set first assistant to random Assistant TODO: Commented out for now
//            DispatchQueue.main.async {
//                withAnimation {
//                    self.selectedAssistant = assistants.randomElement()
//                }
//            }
//        }
//        .onChange(of: selectedAssistant) { newValue in
//            if newValue == nil {
//                // Set isPulsatingNextButton to false if newValue is nil
//                isPulsatingNextButton = false
//            } else {
//                // Set isPulsatingNextButton to true otherwise, checking if selectedAssistant is still not nil before setting to true
//                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
//                    if self.selectedAssistant != nil {
//                        self.isPulsatingNextButton = true
//                    }
//                }
//            }
//        }
//        .navigationDestination(isPresented: $isShowingDestination, destination: destination)
//    }
//    
//    var faceAssistants: some View {
//        LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())]) {
//            ForEach(assistants) { assistant in
//                if let faceStyle = assistant.faceStyle,
//                   let name = assistant.name,
//                   let shortDescription = assistant.assistantShortDescription {
//                    Button(action: {
//                        DispatchQueue.main.async {
//                            withAnimation(.spring(duration: 0.2)) {
//                                self.selectedAssistant = assistant
//                            }
//                        }
//                    }) {
//                        FaceAssistantView(
//                            faceAnimationViewRepresentable: FaceAnimationViewRepresentable(
//                                frame: faceFrame,
//                                eyesImageName: faceStyle.eyesImageName,
//                                mouthImageName: faceStyle.mouthImageName,
//                                noseImageName: faceStyle.noseImageName,
//                                faceImageName: faceStyle.backgroundImageName,
//                                facialFeaturesScaleFactor: facialFeaturesScaleFactor,
//                                eyesPositionFactor: faceStyle.eyesPositionFactor,
//                                faceRenderingMode: faceStyle.faceRenderingMode,
//                                color: UIColor(Colors.elementBackgroundColor),
//                                startAnimation: SmileCenterFaceAnimation(duration: 0.0),
////                                queuedAnimations: self.selectedAssistant == assistant ? State(initialValue: [SmileLookUpFaceAnimation(), SmileLookUpFaceAnimation()]) : State(initialValue: []),
//                                idleAnimations: RandomFaceIdleAnimationSequence.smile.animationSequence.animations),
//                            circleInnerPadding: circleInnerPadding - 8.0,
//                            title: name,
//                            subtitle: shortDescription,
//                            premiumModel: false)
//                    }
//                    .foregroundStyle(assistant == selectedAssistant ? Colors.elementTextColor : .black)
//                    .frame(maxWidth: .infinity, maxHeight: .infinity)
//                    .padding(8)
//                    .background(assistant == selectedAssistant ? Colors.elementTextColor.opacity(0.2) : Colors.elementTextColor)
//                    .clipShape(RoundedRectangle(cornerRadius: 14.0))
//                }
//            }
//        }
//    }
//    
//}
//
//
//#Preview {
//    
//    IntroAssistantSelectionView(destination: {})
//        .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
//        .onAppear {
//            Task(priority: .high) {
////                do {
//////                    try await DefaultAssistantsCoreDataLoader.deleteDeviceCreatedAssistantsInCoreData(in: CDClient.mainManagedObjectContext)
////                    
////                    // TODO: Version handling
////                    if try await !DefaultAssistantsCoreDataLoader.deviceCreatedAssistantExists(in: CDClient.mainManagedObjectContext) {
////                        try await DefaultAssistantsCoreDataLoader.loadDefaultAssistantsInCoreData(in: CDClient.mainManagedObjectContext)
////                    }
////                } catch {
////                    // TODO: Handle Errors
////                    print("Error loading or checking default assistants in CoreData... \(error)")
////                }
//            }
//        }
////    IntroAssistantSelectionView(destination: {
////        
////    })
////    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
//    
//}


IntroVideoView.swift
//
//  IntroVideoView.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 3/2/24.
//

import AVKit
import Foundation
import SwiftUI
import UIKit

struct IntroVideoView<Content: View>: View {
    
    @Binding var avPlayer: AVPlayer
    @State var showReplayDelay: CGFloat
    @State var videoAspectRatio: CGFloat
    @ViewBuilder var destination: ()->Content
    
    
    @Environment(\.colorScheme) private var colorScheme
    
    private let blurryOverlayImageName = Constants.ImageName.blurryOverlay
    
    @State private var isDisplayingReplayButton: Bool = false
    
    @State private var isShowingNext: Bool = false
    
    
//    var videoViewRepresentableTopPadding: CGFloat {
//        get {
    //            let additionalOffset = UIScreen.screenWidth < 388 ? 50.0 : 0.0
//            // Get device width and height, multiply device width by aspect ratio, subtract product from device height to get top padding if positive otherwise zero
//            print(UIScreen.screenWidth)
//            let topPadding = UIScreen.screenWidth * (1 / videoAspectRatio) - UIScreen.screenHeight - additionalOffset
//            
//            if topPadding < 0 {
//                return 0
//            }
//            
//            return topPadding
//        }
//    }
    
    
    var body: some View {
        ZStack {
            // Background Video View
//            BackgroundVideoView(
//                imageName: colorScheme == .light ? lightModeVideoName : darkModeVideoName,
//                imageExtension: colorScheme == .light ? lightModeVideoExtension : darkModeVideoExtension)
            Colors.videoMatchedColor
            
            ZStack {
                VideoViewRepresentable(player: $avPlayer)
//                    .padding(.top, -50)
            }
            .aspectRatio(videoAspectRatio, contentMode: .fit)
//            .padding(.top, videoViewRepresentableTopPadding)
        }
        .ignoresSafeArea()
        .toolbar(.hidden, for: .navigationBar)
        .navigationDestination(isPresented: $isShowingNext, destination: destination)
        .background(Colors.secondaryBackground)
        .overlay(alignment: .bottom) {
            
            // Button within container with blurry overlay background
            VStack {
                //                let additionalYOffset = 80.0
                Spacer()
                
                //                ZStack {
                //                    Image(blurryOverlayImageName)
                //                        .resizable()
                //                        .frame(height: 400)
                //                        .offset(y: 18)
                //                        .foregroundStyle(Colors.secondaryBackground)
                
                VStack(spacing: 0.0) {
                    if isDisplayingReplayButton {
                        Button(action: {
                            HapticHelper.doSuccessHaptic()
                            
                            resetAVPlayer()
                            playVideo()
                        }) {
                            Text("\(Image(systemName: "arrow.triangle.2.circlepath")) Replay")
                                .font(.custom(Constants.FontName.body, size: 17.0))
                                .foregroundStyle(Colors.foregroundText)
                        }
                        
                    }
                    Button(action: {
                        // Do light haptic
                        HapticHelper.doLightHaptic()
                        
                        // Pause avPlayer
                        avPlayer.pause()
                        
                        // Show next view
                        isShowingNext = true
                    }) {
                        ZStack {
                            Text("Next...")
                                .font(.custom(Constants.FontName.heavy, size: 24.0))
                            
                            HStack {
                                Spacer()
                                Text(Image(systemName: "chevron.right"))
                            }
                        }
                    }
                    .padding()
                    .foregroundStyle(Colors.foregroundText)
                    //                    .foregroundStyle(Colors.elementBackgroundColor)
                    .background(Colors.background)
                    //                    .background(Colors.foreground)
                    .clipShape(RoundedRectangle(cornerRadius: Constants.UI.cornerRadius))
                    .bounceable()
                    .padding()
                    //                    .padding(.top, blurryOverlayImageYOffset + buttonYOffset)
                    //                    .padding()
                    //                    .padding(.top, -48)
                }
                .padding(.bottom)
                
                //                }
                //                .offset(y: UIScreen.screenHeight / 2 - additionalYOffset)
            }
        }
        .onAppear {
            playVideo()
        }
    }
    
    
    func resetAVPlayer() {
        self.avPlayer.pause()
        self.avPlayer.seek(to: .zero)
        self.isDisplayingReplayButton = false
    }
    
    func playVideo() {
        DispatchQueue.main.async {
//            self.avPlayer = IntroVideoView.setupAVPlayer(
//                lightVideoName: lightVideoName,
//                lightVideoExtension: lightVideoExtension,
//                darkVideoName: darkVideoName,
//                darkVideoExtension: darkVideoExtension,
//                colorScheme: colorScheme)
            
            self.avPlayer.play()
        }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + showReplayDelay) {
            withAnimation {
                self.isDisplayingReplayButton = true
            }
        }
        
    }
    
}

#Preview {
    
    func setupAVPlayer(lightVideoName: String, lightVideoExtension: String, darkVideoName: String, darkVideoExtension: String, colorScheme: ColorScheme) -> AVPlayer {
        AVPlayer(url: Bundle.main.url(
            forResource: colorScheme == .light ? lightVideoName : darkVideoName,
            withExtension: colorScheme == .light ? lightVideoExtension : darkVideoExtension)!)
    }
    
//    let avPlayer = AVPlayer(url: Bundle.main.url(forResource: "Intro New 1 Light", withExtension: "mp4")!)
    
    return IntroVideoView(
        avPlayer: .constant(
            setupAVPlayer(
                lightVideoName: "Intro New 1 Light",
                lightVideoExtension: "mp4",
                darkVideoName: "Intro New 1 Dark",
                darkVideoExtension: "mp4",
                colorScheme: .light)),
        showReplayDelay: 2.0,
        videoAspectRatio: 1284.0/2778.0,
        destination: {
        
    })
    
}


IntroView.swift
//
//  IntroView.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 11/1/23.
//

import SwiftUI

struct IntroView<Content: View>: View {
    
    @State var image: Image
    @Binding var isShowingButtonLoading: Bool
    @ViewBuilder var destination: ()->Content
    
    
    @State private var isShowingNext: Bool = false
    
    var body: some View {
        VStack {
            Spacer(minLength: 40)
            
            image
                .resizable()
                .aspectRatio(contentMode: .fit)
            
            Button(action: {
                // Do light haptic
                HapticHelper.doLightHaptic()
                
                // Show next view
                isShowingNext = true
            }) {
                ZStack {
                    Text("Next...")
                        .font(.custom(Constants.FontName.heavy, size: 24.0))
                    
                    HStack {
                        Spacer()
                        if isShowingButtonLoading {
                            ProgressView()
                                .tint(Colors.elementBackground)
                        } else {
                            Text(Image(systemName: "chevron.right"))
                        }
                    }
                }
            }
            .padding()
            .foregroundStyle(Colors.elementText)
//            .foregroundStyle(Colors.elementBackgroundColor)
            .background(Colors.elementBackground)
//            .background(Colors.foreground)
            .clipShape(RoundedRectangle(cornerRadius: Constants.UI.cornerRadius))
            .bounceable(disabled: isShowingButtonLoading)
            .opacity(isShowingButtonLoading ? 0.4 : 1.0)
            .disabled(isShowingButtonLoading)
            .padding()
        }
        .background(Colors.background)
        .toolbar(.hidden, for: .navigationBar)
        .navigationDestination(isPresented: $isShowingNext, destination: destination)
    }
    
}

#Preview {
    NavigationStack {
        IntroView(
            image: Image(uiImage: UIImage(named: IntroPresenterView.lightModeImage1Name)!),
            isShowingButtonLoading: .constant(false),
            destination: {
            Text("You've got to the destination!")
                .toolbar(.hidden, for: .navigationBar)
        })
    }
}


UltraButton.swift
//
//  UltraButton.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 10/27/23.
//

import SwiftUI

struct UltraButton: View {
    
    let color: Color
    @State var sparkleDiameter: CGFloat = 28.0
    @State var fontSize: CGFloat = 20.0
    @State var cornerRadius: CGFloat = 24.0
    @State var horizontalSpacing: CGFloat = 4.0
    @State var innerPadding: CGFloat = 8.0
//    @State var lineWidth: CGFloat = 2.0
    
    @EnvironmentObject var premiumUpdater: PremiumUpdater
    @EnvironmentObject var productUpdater: ProductUpdater
    @EnvironmentObject var remainingUpdater: RemainingUpdater
    
    
    @Environment(\.colorScheme) private var colorScheme: ColorScheme
    
    @State private var isShowingUltraView: Bool = false
    
    private var sparkleImageName: String {
        Constants.ImageName.sparkleWhiteGif//colorScheme == .dark ? Constants.ImageName.sparkleDarkGif : Constants.ImageName.sparkleLightGif
    }
    
    var body: some View {
        ZStack {
            Button(action: {
                // Do light haptic
                HapticHelper.doLightHaptic()
                
                // Show Ultra View
                isShowingUltraView = true
            }) {
                HStack(spacing: horizontalSpacing) {
                    SwiftyGif(name: sparkleImageName)
                        .frame(width: sparkleDiameter, height: sparkleDiameter)
                        .colorMultiply(color)
                    
                    Text("\(remainingUpdater.remaining ?? 0)")
                        .font(.custom(Constants.FontName.black, size: fontSize))
                }
//                .foregroundStyle(Colors.navigationItemColor)
                .foregroundStyle(color)
                .padding(innerPadding)
                .padding([.leading, .trailing], innerPadding / 2)
                .background(
                    ZStack {
//                        RoundedRectangle(cornerRadius: cornerRadius)
//                            .fill(Colors.elementTextColor)
                        RoundedRectangle(cornerRadius: cornerRadius)
//                            .stroke(Colors.navigationItemColor, lineWidth: 2.0)
                            .stroke(color, lineWidth: 2.0)
                    }
                )
            }
        }
        .ultraViewPopover(isPresented: $isShowingUltraView)
    }
    
}

#Preview {
    UltraButton(color: Colors.elementBackground)
        .background(.yellow)
        .environmentObject(RemainingUpdater())
        .environmentObject(PremiumUpdater())
        .environmentObject(ProductUpdater())
}


UltraReviewView.swift
//
//  UltraReviewView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/7/23.
//

import SwiftUI

struct UltraReviewView: View {
    
    @State var stars: Int
    @State var text: String
    
    var body: some View {
        ZStack {
            VStack {
                HStack {
                    Spacer()
                    Image("LeftFeather")
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 32.0)
                    VStack {
                        HStack {
                            Image(systemName: "star.fill")
                                .font(.custom(Constants.FontName.body, size: 14.0))
                            Image(systemName: "star.fill")
                                .font(.custom(Constants.FontName.body, size: 14.0))
                            Image(systemName: "star.fill")
                                .font(.custom(Constants.FontName.body, size: 14.0))
                            Image(systemName: "star.fill")
                                .font(.custom(Constants.FontName.body, size: 14.0))
                            Image(systemName: "star.fill")
                                .font(.custom(Constants.FontName.body, size: 14.0))
                        }
                        Text("\"\(text)\"")
                            .multilineTextAlignment(.center)
                            .font(.custom(Constants.FontName.body, size: 12.0))
                            .minimumScaleFactor(0.5)
                            .padding(.top, 8)
                    }
                    Image("RightFeather")
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 32.0)
                    Spacer()
                }
            }
        }
    }
    
}

#Preview {
    UltraReviewView(
        stars: 5,
        text: "The easiest way to craft custom cocktails.")
        .padding(40)
}


UltraReviewModel.swift
//
//  UltraReviewModel.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/7/23.
//

import Foundation

struct UltraReviewModel: Identifiable, Hashable {
    
    var id = UUID()
    
    var starCount: Int
    var text: String
    
}


UltraView.swift
//
//  UltraView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/4/23.
//

import AdSupport
import AppsFlyerLib
import SwiftUI
import StoreKit

struct UltraView: View {
    
//    @ObservedObject var ultraViewModel: UltraViewModel
    @Binding var isShowing: Bool
//    @State var ultraReviewModels: [UltraReviewModel] = UltraReviewModelRepository.models.shuffled()
    
    
    private enum ValidSubscriptions {
        // The subscription id represented as an enum
        case weekly
        case monthly
    }
    
    
    private let showCloseButtonDelay = 2
    private let initialReviewSwitchDelay = 2
    private let reviewSwitchDelay = 3
    private let minReviewGeometryHeight: CGFloat = 100.0
    
    @EnvironmentObject private var premiumUpdater: PremiumUpdater
    @EnvironmentObject private var productUpdater: ProductUpdater
    
    @State private var closeButtonShowing: Bool = false
    @State private var selectedSubscription: ValidSubscriptions = .weekly
    @State private var selectedReviewIndex: Int = 0
    
    @State private var shouldAnimateReviews: Bool = true
    
    @State private var alertShowingDEBUGErrorPurchasing: Bool = false
    @State private var alertShowingErrorRestoringPurchases: Bool = false
    @State private var alertShowingErrorLoading: Bool = false
    
    @State private var isLoadingPurchase: Bool = false
    
    @State private var isShowingPrivacyPolicyWebView: Bool = false
    @State private var isShowingTermsWebView: Bool = false
    
    @State private var isInitialReview: Bool = true
    @State private var justInteractedWithReviews: Bool = false
    
    @State private var errorPurchasing: Error?
    
    
    private let currencyNumberFormatter: NumberFormatter = {
        let currencyNumberFormatter = NumberFormatter()
        currencyNumberFormatter.numberStyle = .decimal
        currencyNumberFormatter.maximumFractionDigits = 2
        currencyNumberFormatter.minimumFractionDigits = 2
        return currencyNumberFormatter
    }()
    
    
    init(isShowing: Binding<Bool>) {
        self._isShowing = isShowing
    }
    
    
    var body: some View {
        ZStack {
            VStack {
                // Header Container
                HStack {
                    VStack(spacing: 0.0) {
                        Color.clear
                            .background(
                                ZStack {
                                    Image(Constants.ImageName.ultraTitle)
                                        .resizable()
                                        .aspectRatio(contentMode: .fill)
                                }
                            )
                            .frame(maxWidth: .infinity, minHeight: 40)
                        
                        VStack {
                            Text("Your AI Chef")
                                .font(.custom(Constants.FontName.black, fixedSize: 42.0))
                                .padding(.top, 8)
                                .onLongPressGesture {
                                    // Show debug error on long press if there is an error stored from when purchasing
                                    if errorPurchasing != nil {
                                        alertShowingDEBUGErrorPurchasing = true
                                    }
                                }
                            
                            Text("Custom recipes from your ingredients.")
                                .font(.custom(Constants.FontName.body, fixedSize: 18.0))
                        }
                        .frame(maxWidth: .infinity)
                        .background(Colors.background)
                    }
                    .foregroundStyle(Colors.foregroundText)
                }
                
                // Features
                Spacer()
                features
                Spacer()
                
                // Buttons Container
                VStack {
                    HStack {
                        Text("Directly Supports the Developer")
                            .font(.custom(Constants.FontName.bodyOblique, size: 12.0))
                            .foregroundStyle(Colors.foregroundText)
                        Text("- Cancel Anytime")
                            .font(.custom(Constants.FontName.blackOblique, size: 12.0))
                            .foregroundStyle(Colors.foregroundText)
                    }
                    .padding(.top, -4)
                    
                    purchaseButtons
                    
                    iapRequiredButtons
                }
                .padding()
            }
            .ignoresSafeArea()
            
            VStack {
                HStack {
                    Button(action: {
                        HapticHelper.doLightHaptic()
                        
                        withAnimation {
                            isShowing = false
                        }
                    }) {
                        Spacer()
                        ZStack {
                            Text(Image(systemName: "xmark"))
                                .font(.custom(Constants.FontName.body, size: closeButtonShowing ? 24.0 : 17.0))
                                .foregroundStyle(Colors.background)
                                .scaleEffect(1.1)
                                .padding(.trailing)
                            
                            Text(Image(systemName: "xmark"))
                                .font(.custom(Constants.FontName.body, size: closeButtonShowing ? 24.0 : 17.0))
                                .foregroundStyle(Colors.foreground)
                                .padding(.trailing)
                        }
                    }
                    .opacity(closeButtonShowing ? 1.0 : 0.2)
                }
                
                Spacer()
            }
        }
        .background(Color("TertiaryBackgroundColor"))
        .task{ await showCloseButtonAfterDelay() }
//        .task { await animateReviews() }
        .alert("Error restoring purchases...", isPresented: $alertShowingErrorRestoringPurchases, actions: {
            Button("Close", role: .cancel, action: {
                
            })
        }) {
            Text("You can try tapping on the subsciption you previously purchased. Apple will prevent a double charge.")
        }
        .alert("DEBUG Error Purchasing", isPresented: $alertShowingDEBUGErrorPurchasing, actions: {
            Button("Close", role: .cancel) {
                
            }
            
            Button("Copy Error") {
                PasteboardHelper.copy(errorPurchasing?.localizedDescription ?? "No Error")
            }
        }) {
            Text(errorPurchasing?.localizedDescription ?? "No Error")
        }
        .alert("Error Loading", isPresented: $alertShowingErrorLoading) {
            Button("Close", action: {
                
            })
        } message: {
            Text("There was an error loading your purchase. Please check your network connection and try again.")
        }
    }
    
    var features: some View {
        VStack(alignment: .leading, spacing: 4.0) {
            HStack(alignment: .top) {
                Text(Image(systemName: "checkmark.square.fill"))
                    .font(.custom(Constants.FontName.body, fixedSize: 24.0))
                    .padding(.top, -4)
                    .padding(.trailing, 8)
                
                Text("Unlimited")
                    .font(.custom(Constants.FontName.black, fixedSize: 20.0))
                Text("Recipes")
                    .font(.custom(Constants.FontName.body, fixedSize: 20.0))
            }
            HStack(alignment: .top) {
                Text(Image(systemName: "checkmark.square.fill"))
                    .font(.custom(Constants.FontName.body, fixedSize: 24.0))
                    .padding(.top, -4)
                    .padding(.trailing, 8)
                
                Text("Five-Star")
                    .font(.custom(Constants.FontName.black, fixedSize: 20.0))
                Text("AI Chef")
                    .font(.custom(Constants.FontName.body, fixedSize: 20.0))
            }
            HStack(alignment: .top) {
                Text(Image(systemName: "checkmark.square.fill"))
                    .font(.custom(Constants.FontName.body, fixedSize: 24.0))
                    .padding(.top, -4)
                    .padding(.trailing, 8)
                
                Text("Remove")
                    .font(.custom(Constants.FontName.black, fixedSize: 20.0))
                Text("Ads")
                    .font(.custom(Constants.FontName.body, fixedSize: 20.0))
            }
            HStack(alignment: .top) {
                Text(Image(systemName: "checkmark.square.fill"))
                    .font(.custom(Constants.FontName.body, fixedSize: 24.0))
                    .padding(.top, -4)
                    .padding(.trailing, 8)
                
                VStack(alignment: .leading) {
                    HStack {
                        Text("Unlock")
                            .font(.custom(Constants.FontName.body, fixedSize: 20.0))
                        Text("20+")
                            .font(.custom(Constants.FontName.black, fixedSize: 20.0))
                    }
                    Text("Creative Features!")
                        .font(.custom(Constants.FontName.black, fixedSize: 20.0))
                }
            }
        }
        .foregroundStyle(Colors.foregroundText)
        .minimumScaleFactor(0.8)
        .padding(20)
//        .background(Colors.elementBackground)
//        .clipShape(RoundedRectangle(cornerRadius: 28.0))
//        .padding()
    }
    
    var iapRequiredButtons: some View {
        HStack {
            Button(action: {
                HapticHelper.doLightHaptic()
                
                isShowingPrivacyPolicyWebView = true
            }) {
                Text("Privacy")
                    .font(.custom(Constants.FontName.body, size: 11.0))
                    .foregroundStyle(Colors.foregroundText)
            }
            .fullScreenCover(isPresented: $isShowingPrivacyPolicyWebView) {
                VStack {
                    WebView(url: URL(string: "\(Constants.HTTPSConstants.chitChatServerStaticFiles)\(Constants.HTTPSConstants.privacyPolicy)")!)
                        .chefAppHeader(showsDivider: true, left: {
                            Button(action: {
                                HapticHelper.doLightHaptic()
                                
                                withAnimation {
                                    isShowingPrivacyPolicyWebView = false
                                }
                            }) {
                                Text("Back")
                                    .font(.custom(Constants.FontName.black, size: 20.0))
                                    .foregroundStyle(Colors.foregroundText)
                                    .padding(.bottom, 8)
                                    .padding(.leading)
                            }
                        }, right: {
                            
                        })
                        .background(Colors.elementBackground)
                        .ignoresSafeArea()
                }
            }
            
            Button(action: {
                HapticHelper.doLightHaptic()
                
                isShowingTermsWebView = true
            }) {
                Text("Terms")
                    .font(.custom(Constants.FontName.body, size: 11.0))
                    .foregroundStyle(Colors.foregroundText)
            }
            .fullScreenCover(isPresented: $isShowingTermsWebView) {
                VStack {
                    WebView(url: URL(string: "\(Constants.HTTPSConstants.chitChatServerStaticFiles)\(Constants.HTTPSConstants.termsAndConditions)")!)
                        .chefAppHeader(showsDivider: true, left: {
                            Button(action: {
                                withAnimation {
                                    isShowingTermsWebView = false
                                }
                            }) {
                                Text("Back")
                                    .font(.custom(Constants.FontName.black, size: 20.0))
                                    .foregroundStyle(Colors.foregroundText)
                                    .padding(.bottom, 8)
                                    .padding(.leading)
                            }
                        }, right: {
                            
                        })
                        .background(Colors.elementBackground)
                        .ignoresSafeArea()
                }
            }
            
            Spacer()
            
            Button(action: {
                HapticHelper.doLightHaptic()
                
                Task {
                    do {
                        // TODO: How is this processed and how does it actually communicate with the server? Does it at all? Should it call update transaction on the server?
                        try await AppStore.sync()
                        
                        HapticHelper.doSuccessHaptic()
                    } catch {
                        // TODO: Handle Errors
                        print("Error syncing with AppStore in UltraView... \(error)")
                    }
                }
            }) {
                Text("Restore")
                    .font(.custom(Constants.FontName.body, size: 11.0))
                    .foregroundStyle(Colors.foregroundText)
            }
        }
        .padding([.leading, .trailing])
    }
    
    var purchaseButtons: some View {
        VStack(spacing: 8.0) {
//            if let weeklyProduct = productUpdater.weeklyProduct {
//                if let introductaryOffer = weeklyProduct.subscription?.introductoryOffer {
//                    ZStack {
//                        HStack {
//                            Toggle(isOn: freeTrialSelected) {
//                                        let introductaryText = introductaryOffer.price == 0.0 ? "Enable Free Trial" : "Enable Special Offer"
//
//                                        Text(introductaryText)
//                                    .font(.custom(Constants.FontName.medium, size: 17.0))
//
//                            }
//                            .onTapGesture {
//                                HapticHelper.doMediumHaptic()
//                            }
//                            .tint(Colors.elementBackgroundColor)
//                            .foregroundStyle(Colors.elementBackgroundColor)
//                        }
//                    }
//                    .padding(8)
//                    .padding([.leading, .trailing], 8)
//                    .background(
//                        ZStack {
//                            RoundedRectangle(cornerRadius: 14.0)
//                                .fill(Colors.userChatTextColor)
//                        }
//                    )
//                }
//            }
            
            Button(action: {
                // Do light haptic
                HapticHelper.doLightHaptic()
                
                // Set selected subscription to weekly
                selectedSubscription = .weekly
            }) {
                ZStack {
                    if let weeklyProduct = productUpdater.weeklyProduct {
                        let productPriceString = currencyNumberFormatter.string(from: weeklyProduct.price as NSNumber) ?? weeklyProduct.displayPrice
                        
                        HStack {
                            if let introductaryOffer = weeklyProduct.subscription?.introductoryOffer {
                                let offerPriceString = introductaryOffer.price == 0.99 ? "99¢" : currencyNumberFormatter.string(from: introductaryOffer.price as NSNumber) ?? introductaryOffer.displayPrice
                                
                                if introductaryOffer.paymentMode == .freeTrial || introductaryOffer.price == 0.0 {
                                    // Free Trial
                                    let durationString = "\(introductaryOffer.period.value)"
                                    let unitString = switch introductaryOffer.period.unit {
                                    case .day: "Day"
                                    case .week: "Week"
                                    case .month: "Month"
                                    case .year: "Year"
                                    @unknown default: ""
                                    }
                                    
                                    Text("\(durationString) \(unitString) Free Trial")
                                        .font(.custom(Constants.FontName.black, size: 17.0))
                                    +
                                    Text(" - then \(productPriceString) / week")
                                        .font(.custom(Constants.FontName.body, size: 15.0))
                                } else {
                                    // Discount
                                    VStack(alignment: .leading, spacing: 0.0) {
                                        Text("Special Offer - \(offerPriceString) / week")
                                            .font(.custom(Constants.FontName.black, size: 17.0))
                                        let durationString = introductaryOffer.periodCount.word
                                        
                                        Text("for \(durationString) weeks, then \(productPriceString) / week")
                                            .font(.custom(Constants.FontName.bodyOblique, size: 16.0))
                                            .minimumScaleFactor(0.69)
                                            .lineLimit(1)
                                    }
                                }
                                
                            } else {
                                Text("\(productPriceString) / week")
                                    .font(.custom(Constants.FontName.black, size: 17.0))
                            }
                            
                            
                            
                            Spacer()
                            
                            Text(Image(systemName: selectedSubscription == .weekly ? "checkmark.circle.fill" : "circle"))
                                .font(.custom(Constants.FontName.body, size: 28.0))
                                .foregroundStyle(Colors.foregroundText)
                                .padding([.top, .bottom], -6)
                        }
                    } else {
                        HStack {
                            Spacer()
                            Text("Blank")
                                .opacity(0.0)
                            Spacer()
                        }
                    }
                }
            }
            .padding(12)
            .foregroundStyle(Colors.foregroundText)
            .background(
                ZStack {
                    let cornerRadius = 14.0
                    RoundedRectangle(cornerRadius: cornerRadius)
                        .fill(Colors.foreground)
//                    RoundedRectangle(cornerRadius: cornerRadius)
//                        .stroke(Colors.foreground, lineWidth: selectedSubscription == .weekly ? 0.5 : 0.5)
                }
            )
            .opacity(isLoadingPurchase ? 0.4 : 1.0)
            .disabled(isLoadingPurchase)
//            .bounceable(disabled: isLoadingPurchase)
            
            Button(action: {
                // Do light haptic
                HapticHelper.doLightHaptic()
                
                // Set selected subscription to monthly
                selectedSubscription = .monthly
            }) {
                ZStack {
                    if let monthlyProduct = productUpdater.monthlyProduct {
                        let productPriceString = currencyNumberFormatter.string(from: monthlyProduct.price as NSNumber) ?? monthlyProduct.displayPrice
                        
                        HStack {
                            VStack(alignment: .leading, spacing: 0.0) {
                                Text("Monthly - \(productPriceString) / month")
                                    .font(.custom(Constants.FontName.body, size: 17.0))
                                Text("That's 30% Off Weekly!")
                                    .font(.custom(Constants.FontName.black, size: 12.0))
                            }
                            
                            Spacer()
                            
                            Text(Image(systemName: selectedSubscription == .monthly ? "checkmark.circle.fill" : "circle"))
                                .font(.custom(Constants.FontName.body, size: 28.0))
                                .foregroundStyle(Colors.foregroundText)
                                .padding([.top, .bottom], -6)
                        }
                    }
                }
            }
            .padding(12)
            .foregroundStyle(Colors.foregroundText)
            .background(
                ZStack {
                    let cornerRadius = 14.0
                    RoundedRectangle(cornerRadius: cornerRadius)
                        .fill(Colors.foreground)
//                    RoundedRectangle(cornerRadius: cornerRadius)
//                        .stroke(Colors.foreground, lineWidth: selectedSubscription == .monthly ? 0.5 : 0.5)
                }
            )
            .opacity(isLoadingPurchase ? 0.4 : 1.0)
            .disabled(isLoadingPurchase)
//            .bounceable(disabled: isLoadingPurchase)
            
            Button(action: {
                // Do medium haptic
                HapticHelper.doMediumHaptic()
                
                // Purchase
                purchase()
                
//                // Print to server console
//                Task {
//                    guard let authToken = AuthHelper.get() else {
//                        print("Could not unwrap authToken in UltraView!")
//                        return
//                    }
//
//                    let printToConsoleRequst = PrintToConsoleRequest(
//                        authToken: authToken,
//                        message: "Tapped purchase button!")
//
//                    do {
//                        try await ChitChatHTTPSConnector.printToConsole(request: printToConsoleRequst)
//                    } catch {
//                        print("Error sending print to console request in UltraView... \(error)")
//                    }
//                }
            }) {
                ZStack {
                    Text("Next")
                        .font(.custom(Constants.FontName.heavy, size: 20.0))
                    
                    HStack {
                        Spacer()
                        
                        if isLoadingPurchase {
                            ProgressView()
                                .tint(Colors.elementText)
                        } else {
                            Text(Image(systemName: "chevron.right"))
                        }
                    }
                }
            }
            .padding(18)
            .foregroundStyle(Colors.elementText)
            .background(Colors.elementBackground)
            .clipShape(RoundedRectangle(cornerRadius: 14.0))
            .opacity(isLoadingPurchase ? 0.4 : 1.0)
            .disabled(isLoadingPurchase)
            .bounceable(disabled: isLoadingPurchase)
        }
    }
    
//    var reviews: some View {
//        HStack {
//            GeometryReader { geometry in
//                if geometry.size.height > minReviewGeometryHeight {
//                    TabView(selection: $selectedReviewIndex) {
//                        ForEach(0..<ultraReviewModels.count, id: \.self) { i in
//                            let ultraReviewModel = ultraReviewModels[i]
//                            VStack {
//                                UltraReviewView(
//                                    stars: ultraReviewModel.starCount,
//                                    text: ultraReviewModel.text)
//                                .padding()
//                                //                        .frame(maxWidth: geometry.size.width)
//                                .background(Material.regular)
//                                .clipShape(RoundedRectangle(cornerRadius: 28.0))
//                                .frame(width: geometry.size.width / 1.2)
//                                .padding(.bottom, 8)
//                            }
//                            .id(ultraReviewModel)
//                        }
//                    }
//                    //                .indexViewStyle(.page(backgroundDisplayMode: .interactive))
//                    .tabViewStyle(.page(indexDisplayMode: .never))
//                    .onAppear {
//                        UIPageControl.appearance().currentPageIndicatorTintColor = UIColor(Colors.foregroundText.opacity(0.8))
//                        UIPageControl.appearance().pageIndicatorTintColor = UIColor(Colors.foregroundText.opacity(0.2))
//                    }
//                    .gesture(DragGesture()
//                        .onChanged({ value in
//                            // Set justInteractedWithReviews to true on drag
//                            justInteractedWithReviews = true
//                        }))
//                }
//            }
//        }
//    }
    
    func showCloseButtonAfterDelay() async {
        do {
            try await Task.sleep(nanoseconds: UInt64(1_000_000_000 * showCloseButtonDelay))
        } catch {
            // TODO: Handle errors
            print("Error sleeping to show the close button in UltraView... \(error)")
        }
        
        withAnimation {
            closeButtonShowing = true
        }
    }
    
//    func animateReviews() async {
//        while shouldAnimateReviews {
//            do {
//                // Sleep for the correct period of time
//                try await Task.sleep(nanoseconds: UInt64(1_000_000_000 * (isInitialReview ? initialReviewSwitchDelay : reviewSwitchDelay)))
//
//                // Ensure justInteractedWithReviews is false, otherwise set to false and continue to not animate for another loop and delay after user interacted with reviews
//                guard !justInteractedWithReviews else {
//                    justInteractedWithReviews = false
//                    continue
//                }
//
//                // Increment selectedReviewIndex, or set to 0 if the next index would be out of range for ultraReviewModels
//                if selectedReviewIndex + 1 >= ultraReviewModels.count {
//                    DispatchQueue.main.async {
//                        withAnimation {
//                            self.selectedReviewIndex = 0
//                        }
//                    }
//                } else {
//                    DispatchQueue.main.async {
//                        withAnimation {
//                            self.selectedReviewIndex += 1
//                        }
//                    }
//                }
//
//                // Set isInitialReview to false since it will be set to true when the view is loaded
//                isInitialReview = false
//            } catch {
//                // TODO: Handle errors
//                print("Error sleeping to switch the review in UltraView... \(error)")
//                shouldAnimateReviews = false
//            }
//        }
//    }
    
    func purchase() {
//        // Unwrap tappedPeriod
//        guard let selectedSubscription = selectedSubscription else {
//            // TODO: Handle errors
//            print("Could not unwrap tappedPeriod in purchase in UltraView!")
//            return
//        }
        // Get product to purchase
        let product = switch selectedSubscription {
        case .weekly:
            productUpdater.weeklyProduct
        case .monthly:
            productUpdater.monthlyProduct
        }
        
        // Unwrap product
        guard let product = product else {
            // TODO: Handle errors
            print("Could not unwrap product in purchase in UltraView!")
            
            return
        }
        
        // Set isLoadingPurchase to true
        isLoadingPurchase = true
        
        Task {
            defer {
                isLoadingPurchase = false
            }
            
            // Unwrap authToken
            guard let authToken = try? await AuthHelper.ensure() else {
                // If the authToken is nil, show an error alert that the app can't connect to the server and return
                alertShowingErrorLoading = true
                return
            }
            
            // Purchase
            let transaction: StoreKit.Transaction
            do {
                transaction = try await IAPManager.purchase(product)
            } catch {
                // TODO: Handle errors
                print("Error purchasing product in UltraView... \(error)")
                errorPurchasing = error
                return
            }
            
            // If isPremium, log purchase with AppsFlyer
            AppsFlyerLib.shared().logEvent(AFEventPurchase, withValues: [
                AFEventParamContentId: "12345",
                AFEventParamContentType: "ultra_dollar",
                AFEventParamRevenue: 1.0,
                AFEventParamCurrency: "USD"
            ])
            
            // Log Conversion to Pinterest through server if it has not been logged
#if DEBUG
            UserDefaults.standard.set(false, forKey: Constants.UserDefaults.pinterestConversionLoggedOnce)
#endif
            if !UserDefaults.standard.bool(forKey: Constants.UserDefaults.pinterestConversionLoggedOnce) {
                Task {
                    // Get idfa
                    let idfa = ASIdentifierManager.shared().advertisingIdentifier.uuidString
                    
                    // Get authToken
                    let authToken: String
                    do {
                        authToken = try await AuthHelper.ensure()
                    } catch {
                        // TODO: Handle errors
                        print("Error ensuring authToken in UltraView... \(error)")
                        return
                    }
                    
                    let logPinterestConversionRequest = LogPinterestConversionRequest(
                        authToken: authToken,
                        idfa: idfa,
                        eventName: Constants.Additional.pinterestCheckoutEventName,
                        eventID: Constants.Additional.pinterestCheckoutEventID,
                        test: false)
                    
                    do {
                        let logPinterestConversionResponse = try await ChefAppNetworkService.logPinterestConversion(request: logPinterestConversionRequest)
                        
                        // If logPinterestConversionResponse didLog is true set pinterestConversionLoggedOnce in user defaults to true
                        if logPinterestConversionResponse.body.didLog {
                            UserDefaults.standard.set(true, forKey: Constants.UserDefaults.pinterestConversionLoggedOnce)
                            
                        }
                    } catch {
                        // TODO: Handle errors
                        print("Error logging pinterest conversion in UltraView... \(error)")
                    }
                }
            }
            
//            // Refresh receipt and try to get it if it's made available.. the delegate wasn't working but the refresh receipt seemed to make the receipt immidiately available here so maybe!
//            IAPManager.refreshReceipt()
//            
//            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
//                // Get the receipt if it's available.
//                if let appStoreReceiptURL = Bundle.main.appStoreReceiptURL,
//                   FileManager.default.fileExists(atPath: appStoreReceiptURL.path) {
//                    
//                    
//                    do {
//                        let receiptData = try Data(contentsOf: appStoreReceiptURL, options: .alwaysMapped)
//                        print(receiptData)
//                        
//                        
////                        let receiptString = receiptData.base64EncodedString(options: [])
//                        
//                        
//                        // Update tenjin with transaction originalID as String and receipt
//                        TenjinSDK.transaction(
//                            withProductName: product.displayName,
//                            andCurrencyCode: "USD",
//                            andQuantity: 1,
//                            andUnitPrice: NSDecimalNumber(decimal: product.price),
//                            andTransactionId: "\(transaction.originalID)",
//                            andReceipt: receiptData)
//                        
//                    } catch {
//                        print("Couldn't read receipt data with error: " + error.localizedDescription)
//                    }
//                } else {
//                    // Update tenjin without receipt
//                    TenjinSDK.transaction(
//                        withProductName: product.displayName,
//                        andCurrencyCode: "USD",
//                        andQuantity: 1,
//                        andUnitPrice: NSDecimalNumber(decimal: product.price))
//                }
//            }
            
//            // Log event_purchase to tenjin
//            TenjinSDK.sendEvent(withName: "event_purchase")
//            
//            // Log event_purchase_value to tenjin
//            TenjinSDK.sendEvent(withName: "event_purchase_value", andEventValue: "\(Int(NSInteger(truncating: product.price as NSNumber)))")
//            
//            // Log purchase to Facebook
//            AppEvents.shared.logEvent(.startTrial)
//            
//            // Log purchase to Adjust
//            let adjEvent = ADJEvent(eventToken: "event_initiate_trial")
//            adjEvent?.setRevenue(NSDecimalNumber(decimal: transaction.price ?? 0.0).doubleValue, currency: "USD")
//            Adjust.trackEvent(adjEvent)
//            
//            // Log purchase to AppsFlyer
//            AppsFlyerLib.shared().logEvent(AFEventPurchase,
//            withValues: [
//                AFEventParamContentId:"event_purchase_custom",
//                AFEventParamContentType : "category_subscription_purchases_custom",
//                AFEventParamRevenue: 200,
//                AFEventParamCurrency:"USD"
//            ]);
            
            if #available(iOS 16.1, *) {
                Task {
                    do {
                        try await SKAdNetwork.updatePostbackConversionValue(3, coarseValue: .low)
                    } catch {
                        print("Error updating postback conversion value in UltraView... \(error)")
                    }
                }
            } else {
                Task {
                    do {
                        try await SKAdNetwork.updatePostbackConversionValue(1)
                    } catch {
                        print("Error updating psotback conversion value in UltraVIew... \(error)")
                    }
                }
            }
            
//            // Update Branch
//            if let skTransaction = transaction as? SKPaymentTransaction {
//                let event = BranchEvent(name: "PURCHASE")
//                event.logEvent(with: skTransaction)
//            }
            
            // Register the transaction ID with the server
            try await premiumUpdater.registerTransaction(authToken: authToken, transactionID: transaction.originalID)

            
            // If premium on complete, do success haptic and dismiss
            if premiumUpdater.isPremium {
                // Do success haptic
                HapticHelper.doSuccessHaptic()
                
                // Dismiss
                DispatchQueue.main.async {
                    isShowing = false
                }
            }
        }
    }
    
}

#Preview {
    
    UltraView(isShowing: .constant(false))
        .environmentObject(PremiumUpdater())
        .environmentObject(ProductUpdater())
        .environmentObject(RemainingUpdater())
    
}


UltraViewModel.swift
////
////  UltraViewModel.swift
////  Barback
////
////  Created by Alex Coundouriotis on 10/7/23.
////
//
//import Foundation
//import StoreKit
//import SwiftUI
//
//class UltraViewModel: ObservableObject {
//    
//    @Published var isLoading: Bool = false
//    @Published var showLoadingErrorAlert: Bool = false
//    @Published var shouldRetryLoadingOnError: Bool = false
//    @Published var subscriptionActive: Bool = false
//    
//    @EnvironmentObject private var premiumUpdater: PremiumUpdater
//    
//    
//    func purchase(subscriptionPeriod: SubscriptionPeriod) async {
//        guard let authToken = AuthHelper.get() else {
//            // TODO: Handle errors
//            showLoadingErrorAlert = true
//            print("Cound not unwrap authToken in purchase in UltraViewModel!")
//            return
//        }
//        
//        defer {
//            DispatchQueue.main.async {
//                self.isLoading = false
//            }
//        }
//        
//        DispatchQueue.main.async {
//            self.isLoading = true
//        }
//        
//        do {
//            guard let json = try await IAPHTTPSClient.getIAPStuffFromServer(authToken: authToken) else {
//                // TODO: Handle errors
//                DispatchQueue.main.async {
//                    self.showLoadingErrorAlert = true
//                }
//                
//                print("Could not unwrap json from getting IAP stuff from server with IAPHTTPSClient in purchase in UltraViewModel!")
//                return
//            }
//            
//            try await handleGetIAPStuffFromServerResponse(json, subscriptionPeriod: subscriptionPeriod)
//        } catch {
//            // TODO: Handle errors
//            DispatchQueue.main.async {
//                self.showLoadingErrorAlert = true
//            }
//            
//            print("Error getting IAP stuff from server with IAPHTTPSClient in purchase in UltraViewModel... \(error)")
//        }
//    }
//    
//    private func handleGetIAPStuffFromServerResponse(_ json: [String: Any], subscriptionPeriod: SubscriptionPeriod) async throws {
//        guard let success = json["Success"] as? Int else { showGeneralIAPErrorAndUnhide(); return }
//
//        if success == 1 {
//            guard let body = json["Body"] as? [String: Any] else { showGeneralIAPErrorAndUnhide(); return }
//            guard let sharedSecret = body["sharedSecret"] as? String else { showGeneralIAPErrorAndUnhide(); return }
//            guard let productIDs = body["productIDs"] as? [String] else { showGeneralIAPErrorAndUnhide(); return }
//            
//            if productIDs.count > 0 {
//                // Get products from server
//                let products = try await IAPManager.fetchProducts(productIDs: productIDs)
//                
//                guard var productToPurchase: Product = products.first(where: {IAPManager.getSubscriptionPeriod(product: $0) == subscriptionPeriod}) else {
//                    showGeneralRetryableIAPErrorAndUnhide()
//                    return
//                }
//                
//                guard let authToken = try? await AuthHelper.ensure() else {
//                    // If the authToken is nil, show an error alert that the app can't connect to the server and return
//                    showGeneralIAPErrorAndUnhide()
//                    
//                    return
//                }
//                
//                // Purchase the product!
//                let transaction = try await IAPManager.purchase(productToPurchase)
//                
//                // Register the transaction ID with the server
//                try await premiumUpdater.registerTransaction(authToken: authToken, transactionID: transaction.id)
//            }
//        }
//    }
//    
//    private func showGeneralRetryableIAPErrorAndUnhide() {
//        // TODO: Handle errors better
//        shouldRetryLoadingOnError = true
//        showGeneralIAPErrorAndUnhide()
//    }
//    
//    private func showGeneralIAPErrorAndUnhide() {
//        // TODO: Handle errors better
//        DispatchQueue.main.async {
//            self.showLoadingErrorAlert = true
//        }
//    }
//    
//}


UltraReviewModelRepository.swift
//
//  UltraReviewModelRepository.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/7/23.
//

import Foundation

struct UltraReviewModelRepository {
    
    static let models: [UltraReviewModel] = [
        UltraReviewModel(
            starCount: 5,
            text: "I've never been able to mix. Now I come up with something every day!"),
        UltraReviewModel(
            starCount: 5,
            text: "I just don't tell my friends an AI made it 😉"),
        UltraReviewModel(
            starCount: 5,
            text: "It takes your bland bar and uses AI to "),
        UltraReviewModel(
            starCount: 5,
            text: "You'll be surprised how much you can make."),
        UltraReviewModel(
            starCount: 5,
            text: "I bet you'll be able to make 100+ drinks from what you have."),
        UltraReviewModel(
            starCount: 5,
            text: "I couldn't mix a drink before until I discovered Barback."),
        UltraReviewModel(
            starCount: 5,
            text: "Forget about googling recipes, Barback's AI creates them based on what I have."),
        UltraReviewModel(
            starCount: 5,
            text: "Surprisingly addictive! I love trying out the AI-generated cocktails."),
        UltraReviewModel(
            starCount: 5,
            text: "Transformed my unassuming home bar into a cocktail wonderland, thanks to Barback's AI."),
        UltraReviewModel(
            starCount: 5,
            text: "Incredibly innovative! The AI actually learns what I like and customizes recipes."),
        UltraReviewModel(
            starCount: 5,
            text: "Who needs a professional bartender when you've got Barback?"),
        UltraReviewModel(
            starCount: 5,
            text: "This is a game changer for casual mixologists. Watch out, you could become cocktail obsessed!"),
        UltraReviewModel(
             starCount: 5,
             text: "Hosting parties has never been easier. My guests can't get enough of these unique creations!"),
        UltraReviewModel(
            starCount: 5,
            text: "Barback is the perfect blend of technology and mixology, making cocktail creation a breeze."),
        UltraReviewModel(
            starCount: 5,
            text: "I used to be a shy guy, now I'm the life of the party. I owe it all to Barback. Cheers!"),
        UltraReviewModel(
            starCount: 5,
            text: "Barback's AI makes cocktails so good, it kind of makes me question humanity's capabilities."),
        UltraReviewModel(
            starCount: 5,
            text: "I tried to compete with the AI in mixing drinks. Long story short, I had to retire from my bartending career."),
        UltraReviewModel(
            starCount: 5,
            text: "Tried to set my old drink recipes on fire to honour my newly found love for Barback. Luckily, my smoke alarm is working."),
        UltraReviewModel(
            starCount: 5,
            text: "The subscription is so worth it! It's like having a world-class mixologist at your fingertips 24/7."),
        UltraReviewModel(
            starCount: 5,
            text: "Best money I have spent! With Barback, I've got limitless cocktail recipes. Never gets boring."),
        UltraReviewModel(
            starCount: 5,
            text: "I tried the free version and got hooked. Upgrading to the subscription was a no-brainer."),
        UltraReviewModel(
            starCount: 5,
            text: "I was skeptical at first, but after indulging in the subscription, I couldn't be happier. It's like my home bar went pro."),
        UltraReviewModel(
            starCount: 5,
            text: "The subscription adds a whole new level -  the drink combinations are endless, and it constantly surprises me."),
        UltraReviewModel(
            starCount: 5,
            text: "I don't normally subscribe to apps, but this was a great investment. It's changed my perspective on enjoying cocktails at home."),
        UltraReviewModel(
            starCount: 5,
            text: "This subscription saves me so much money! Instead of going out, I can mix awesome drinks right at home."),
        UltraReviewModel(
            starCount: 5,
            text: "This subscription saved me cash! Instead of restocking my bar, I made some brand new ones with what I already have."),
        UltraReviewModel(
            starCount: 5,
            text: "My subscription has not just made my bar more efficient, but also adventurous. Every time I want to entertain, there's something fantastic to serve."),
        UltraReviewModel(
            starCount: 5,
            text: "Yes to the subscription! It's like a masterclass in mixology, all for less than the cost of a few cocktails at the bar."),
        UltraReviewModel(
            starCount: 5,
            text: "The subscription is an absolute gem! It takes the guesswork out and now every cocktail is a masterpiece."),
        UltraReviewModel(
            starCount: 5,
            text: "I love the discovery aspect of this app, it has created wild and wonderful cocktails from ingredients I already owned."),
        UltraReviewModel(
            starCount: 5,
            text: "Barback turned my modest stash into an eclectic mix of cocktails. I'm discovering new and amazing drinks every day."),
        UltraReviewModel(
            starCount: 5,
            text: "So many undiscovered gems in my own bar! Having Barback is like owning a treasure map to cocktail heaven."),
        UltraReviewModel(
            starCount: 5,
            text: "Who knew I could make so many different cocktails from the handful of ingredients I have? Barback showed me the way."),
        UltraReviewModel(
            starCount: 5,
            text: "Discovering new drinks without having to buy new ingredients is a game changer. Barback is a true cocktail innovator."),
        UltraReviewModel(
            starCount: 5,
            text: "Barback has unlocked a new world of drinks without me spending a dime on new ingredients."),
        UltraReviewModel(
            starCount: 5,
            text: "Unveiled a host of new drink possibilities that I wasn’t aware I could make from my existing bar ingredients."),
        UltraReviewModel(
            starCount: 5,
            text: "I took my cocktail game to the next level thanks to Barback. New drinks with the same old ingredients? Count me in."),
        UltraReviewModel(
            starCount: 5,
            text: "The 'discovery' feature in this app is incredible. It's amazing how many different drinks I can concoct with what I’ve got."),
        UltraReviewModel(
            starCount: 5,
            text: "Barback showed me the creative ways to make incredible new drinks with ingredients I already had. Couldn’t be more pleased."),
        UltraReviewModel(
            starCount: 5,
            text: "Crafting my own drinks has never been so exciting! I've discovered combinations with ingredients I never thought possible."),
        UltraReviewModel(
            starCount: 5,
            text: "Barback has redefined 'Crafting'. I was blown away by the unique drinks I could make with simple ingredients."),
        UltraReviewModel(
            starCount: 5,
            text: "The 'Crafting' feature is brilliant. I've discovered a whole new world of cocktail possibilities with the ingredients I already had."),
        UltraReviewModel(
            starCount: 5,
            text: "My favorite part of Barback is the crafting experience. It's an exciting journey of crafting and experimenting with my own drinks."),
        UltraReviewModel(
            starCount: 5,
            text: "This crafting feature is a taste bud adventure! It's amazing how many drinks I can craft from my regular bar items."),
        UltraReviewModel(
            starCount: 5,
            text: "Forget mundane drinks, the crafting element of Barback allows me to create, experiment and discover. It's honestly thrilling."),
        UltraReviewModel(
            starCount: 5,
            text: "Barback has taken crafting to a whole new level. It's like a personal mixology course in the palm of my hand."),
        UltraReviewModel(
            starCount: 5,
            text: "I've been crafting a new drink every day with Barback. It's my personal challenge and I love it!"),
        UltraReviewModel(
            starCount: 5,
            text: "The power of crafting with Barback is undeniably addictive. I've surprised myself with the wide range of drinks I can make."),
        UltraReviewModel(
            starCount: 5,
            text: "Crafting on Barback? Game changer. It's like having a world-class bartender guiding you through every ingredient.")
    ]
    
}


EntryView.swift
//
//  EntryView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/20/23.
//

import Foundation
import PopupView
import SwiftUI

struct EntryView: View {
    
    @State var generateMessage: String
    @Binding var selectedPantryItems: [PantryItem]
    @Binding var generationAdditionalOptions: RecipeGenerationAdditionalOptions
    @Binding var selectedSuggestions: [String]
    let showsTitle: Bool
    var onDismiss: () -> Void
    
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @FetchRequest(sortDescriptors: [NSSortDescriptor(keyPath: \PantryItem.updateDate, ascending: false)], animation: .default) private var pantryItems: FetchedResults<PantryItem>
    
//    @State private var isDisplayingBrowseSuggestions: Bool = false
    @State private var isDisplayingAdvancedOptions: Bool = false
    
    @State private var isShowingPantrySelectionView: Bool = false
    
    
    var body: some View {
        
        ZStack {
            VStack {
                //                ScrollView {
                ScrollView {
                    VStack {
                        HStack {
                            VStack(spacing: 0.0) {
                                if showsTitle {
                                    title
                                        .padding(.top)
                                        .padding([.leading, .trailing])
                                        .fixedSize(horizontal: false, vertical: true)
                                }
                                
                                message
                                    .fixedSize(horizontal: false, vertical: true)
                                    .padding(.top)
                                    .padding([.leading, .trailing])
                                
                                browseSuggestions
                                    .padding(.top)
                                
                                advancedOptions
                                    .padding(.top)
                            }
                        }
                        
                        //                        // Selected pantry items
                        //                        if !selectedPantryItems.isEmpty {
                        //                            selectedPantryItemsDisplay
                        //                        }
                        
                        //                        if !isDisplayingAdvancedOptions {
                        VStack(spacing: 0.0) {
                            Divider()
                            
                            // Add from pantry
                            addFromPantry
                            
                            Spacer(minLength: 80.0)
                        }
                        //                        }
                    }
                    
                    //                }
                    //                     , customize: { popup in
                    //                popup
                    //                    .backgroundView({
                    //                        Color.clear
                    //                            .background(Material.ultraThin)
                    //                    })
                    //            })
                    .onTapGesture {
                        KeyboardDismisser.dismiss()
                    }
                }
            }
            
//            VStack {
//                header
//                
//                Spacer()
//            }
        }
        .navigationBarTitleDisplayMode(.inline)
        .toolbarBackground(Colors.background, for: .navigationBar)
        .toolbar {
//            LogoToolbarItem(foregroundColor: Colors.elementBackground)
            ToolbarItem(placement: .principal) {
                Text("Create Recipes")
                    .font(.damion, 32)
                    .foregroundStyle(Colors.elementBackground)
            }
            ToolbarItem(placement: .topBarTrailing) {
                Button(action: {
                    onDismiss()
                }) {
                    Text("Close")
                        .font(.heavy, 17)
                        .foregroundStyle(Colors.elementBackground)
                }
            }
        }
    }
        
//    var header: some View {
//        VStack {
//            Spacer()
//            if onDismiss != nil {
//                KeyboardDismissingButton(action: {
//                    HapticHelper.doLightHaptic()
//                    
//                    withAnimation(.easeInOut(duration: 0.2)) {
//                        onDismiss?()
//                    }
//                }) {
//                    Text(Image(systemName: "xmark"))
//                        .font(.custom(Constants.FontName.heavy, size: 28.0))
//                        .foregroundStyle(Colors.elementBackground)
//                        .padding([.leading, .trailing])
//                    //                                        .padding([.bottom], 10.0)
//                }
//            }
//        }
//        .frame(height: 100.0)
//        .ignoresSafeArea()
//    }
    
    var title: some View {
        HStack {
            Text("Create Recipe...")
//                .font(.custom(Constants.FontName.black, size: 34.0))
                .font(.custom(Constants.FontName.damion, size: 42.0))
            //                                    .padding([.bottom], 10.0)
            Spacer()
        }
    }
    
    var message: some View {
        HStack {
            Text(generateMessage)
                .font(.custom(Constants.FontName.body, size: 17.0))
                .multilineTextAlignment(.leading)
            Spacer()
        }
    }
    
    var browseSuggestions: some View {
        VStack {
//            KeyboardDismissingButton(action: {
//                isDisplayingBrowseSuggestions.toggle()
//            }) {
//                Text(isDisplayingBrowseSuggestions ? "Hide Suggestions" : "Browse Suggestions...")
//                    .font(.custom(Constants.FontName.heavy, size: 14.0))
//                    .padding([.leading, .trailing], 16)
//                    .padding([.top, .bottom], 8)
//                    .background(Colors.foreground)
//                    .tint(elementColor)
//                    .clipShape(RoundedRectangle(cornerRadius: 14.0))
//                Spacer()
//            }
//            .padding()
            
//            if isDisplayingBrowseSuggestions {
//                VStack {
//                    HStack {
//                        Text("Tap to add to prompt...")
//                            .font(.custom(Constants.FontName.bodyOblique, size: 14.0))
//                            .foregroundStyle(Colors.foregroundText)
//                        Spacer()
//                    }
//                }
//                .padding([.leading, .trailing])
                
                ScrollView(.horizontal) {
                    VStack {
                        HStack {
                            ForEach(SuggestionsModel.topSuggestions, id: \.self) { suggestion in
                                Button(action: {
                                    HapticHelper.doLightHaptic()
                                    
                                    // Remove suggestion from selectedSuggestions if it's in there otherwise add it
                                    if selectedSuggestions.contains(suggestion) {
                                        withAnimation(.bouncy(duration: 0.5)) {
                                            selectedSuggestions.removeAll(where: {$0 == suggestion})
                                        }
                                    } else {
                                        withAnimation(.bouncy(duration: 0.5)) {
                                            selectedSuggestions.append(suggestion)
                                        }
                                    }
                                }) {
                                    Text(suggestion)
                                        .font(.custom(Constants.FontName.medium, size: 14.0))
                                }
                                .padding(8)
                                .foregroundStyle(Colors.foregroundText)
                                .background(selectedSuggestions.contains(suggestion) ? Color(uiColor: .systemGreen).opacity(0.4) : .clear)
                                .background(Colors.foreground)
                                .clipShape(RoundedRectangle(cornerRadius: 14.0))
                            }
                            
                            Spacer()
                        }
                        .padding([.leading, .trailing])
                        
                        HStack {
                            ForEach(SuggestionsModel.bottomSuggestions, id: \.self) { suggestion in
                                Button(action: {
                                    HapticHelper.doLightHaptic()
                                    
                                    // Remove suggestion from selectedSuggestions if it's in there otherwise add it
                                    if selectedSuggestions.contains(suggestion) {
                                        withAnimation(.bouncy(duration: 0.5)) {
                                            selectedSuggestions.removeAll(where: {$0 == suggestion})
                                        }
                                    } else {
                                        withAnimation(.bouncy(duration: 0.5)) {
                                            selectedSuggestions.append(suggestion)
                                        }
                                    }
                                }) {
                                    Text(suggestion)
                                        .font(.custom(Constants.FontName.medium, size: 14.0))
                                }
                                .padding(8)
                                .foregroundStyle(Colors.foregroundText)
                                .background(selectedSuggestions.contains(suggestion) ? Color(uiColor: .systemGreen).opacity(0.4) : .clear)
                                .background(Colors.foreground)
                                .clipShape(RoundedRectangle(cornerRadius: 14.0))
                            }
                            
                            Spacer()
                        }
                        .padding([.leading, .trailing])
                    }
                }
                .scrollIndicators(.never)
                
//            }
        }
    }
    
    var advancedOptions: some View {
        PantryRecipeGenerationAdvancedOptionsView(
            isDisplayingAdvancedOptions: $isDisplayingAdvancedOptions,
            generationAdditionalOptions: $generationAdditionalOptions)
    }
    
//    var selectedPantryItemsDisplay: some View {
//        VStack(alignment: .leading, spacing: 8.0) {
//            Text("Selected Ingredients:")
//                .font(.custom(Constants.FontName.body, size: 17.0))
//                .foregroundStyle(Colors.foregroundText)
//                .padding([.leading, .trailing])
//            
//            ScrollView(.horizontal) {
//                HStack {
//                    ForEach(selectedPantryItems) { selectedPantryItem in
//                        if let name = selectedPantryItem.name {
//                            Button(action: {
//                                selectedPantryItems.removeAll(where: {$0 == selectedPantryItem})
//                            }) {
//                                Text(name)
//                                    .font(.custom(Constants.FontName.body, size: 17.0))
//                                    .foregroundStyle(Colors.foregroundText)
//                                    .padding([.top, .bottom], 8)
//                                    .padding([.leading, .trailing])
//                                    .background(Color(uiColor: .systemGreen).opacity(0.4))
//                                    .clipShape(RoundedRectangle(cornerRadius: 14.0))
//                            }
//                        }
//                    }
//                }
//                .padding([.leading, .trailing])
//            }
//        }
//    }
    
    var addFromPantry: some View {
        VStack {
            HStack {
                Text("Tap to add ingredients from your pantry...")
                    .font(.custom(Constants.FontName.bodyOblique, size: 14.0))
                    .foregroundStyle(Colors.foregroundText)
                    .padding([.leading, .trailing])
                
                Spacer()
            }
            .padding([.top, .bottom], 8)
            
            HStack {
                PantrySelectionView(
                    selectedPantryItems: $selectedPantryItems,
                    showsAdvancedOptions: false,
                    generationAdditionalOptions: $generationAdditionalOptions)
                
//                Spacer()
            }
        }
    }
    
}


#Preview {
    
    ZStack {
        Spacer()
    }
    .overlay {
        EntryView(
            generateMessage: "AI Chef here, tell me what you want to recipe or get inspired from suggestions. 😊",
            selectedPantryItems: .constant([]),
            generationAdditionalOptions: .constant(.normal),
            selectedSuggestions: .constant([]),
            showsTitle: true,
            onDismiss: {
                
            }
        )
        .background(Colors.background)
        .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
        .environmentObject(PremiumUpdater())
        .environmentObject(ProductUpdater())
        .environmentObject(RemainingUpdater())
    }
    
    
}



GlassImageView.swift
//
//  GlassImageView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/21/23.
//

import Foundation
import SwiftUI

struct GlassImageView: View {
    
    var drinkColors: [Color]?
    var image: Image
    var height: CGFloat
    var cornerRadius: CGFloat = 24.0
    
    var body: some View {
        
            ZStack {
                RoundedRectangle(cornerRadius: cornerRadius)
                    .aspectRatio(contentMode: .fill)
                    .foregroundStyle(LinearGradient(colors: drinkColors ?? [.black, .black], startPoint: .bottom, endPoint: .top))
                    .scaledToFit()
                image
                    .resizable()
                    .renderingMode(.template)
                    .aspectRatio(contentMode: .fit)
                    .frame(height: height * 0.60)
//                                            .foregroundStyle(LinearGradient(colors: drinkColors ?? [.black, .black], startPoint: .bottom, endPoint: .top))
                    .foregroundStyle(Colors.foreground)
//                    .shadow(color: Colors.text, radius: 1)
            }
            .frame(height: height)
            .frame(minHeight: 0)
        
    }
    
}


RecipeIngredientEditorView.swift
//
//  RecipeIngredientEditorView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/2/23.
//

import SwiftUI

struct RecipeIngredientEditorView: View {
    
    @State var measuredIngredient: RecipeMeasuredIngredient
    @Binding var isShowing: Bool
    
    
    @Environment(\.managedObjectContext) var viewContext
    @Environment(\.colorScheme) private var colorScheme
    
    let testList: [String] = [
        "asdf",
        "asdf2",
        "asdf3"
    ]
    
    @State private var usingFormattedEditor: Bool = false
    
    @State private var newAmount: String
    @State private var newFraction: String
    @State private var newAbbreviatedMeasurement: AbbreviatedMeasurement
    
    @State private var newMeasurement: String
    
    @State private var newIngredient: String
    
    @State private var alertShowingDeleteEmpty: Bool = false
    @State private var alertShowingHasChangesToSave: Bool = false
    @State private var alertShowingRevertIngredient: Bool = false
    
    var formattedMeasurement: String {
        if usingFormattedEditor {
            var measurement = ""
            if !newAmount.isEmpty {
                measurement += newAmount
                measurement += " "
            }
            
            if !newFraction.isEmpty {
                measurement += newFraction
                measurement += " "
            }
            
            if newAbbreviatedMeasurement != Measurements.blankAbbreviatedMeasurement {
                measurement += newAbbreviatedMeasurement.abbreviation
                measurement += " "
            }
            
            return measurement.trimmingCharacters(in: .whitespaces)
        } else {
            return newMeasurement.trimmingCharacters(in: .whitespaces)
        }
    }
    
    var formattedIngredient: String {
        newIngredient.trimmingCharacters(in: .whitespaces)
    }
    
    var finalizedMeasuredIngredient: String {
        (formattedMeasurement.isEmpty ? "" : formattedMeasurement + " ") + (formattedIngredient.isEmpty ? "" : formattedIngredient)
    }
    
    var hasChanges: Bool {
//        (measuredIngredient.measurementModified != formattedMeasurement && measuredIngredient.measurement != formattedMeasurement) || (measuredIngredient.ingredientModified != formattedIngredient && measuredIngredient.ingredient != formattedIngredient)
        print(measuredIngredient.nameAndAmountModified ?? "empty")
        print(formattedIngredient)
        return measuredIngredient.nameAndAmountModified ?? measuredIngredient.nameAndAmount ?? "" != finalizedMeasuredIngredient
//        return measuredIngredient.measurementModified ?? measuredIngredient.measurement ?? "" != formattedMeasurement || measuredIngredient.ingredientModified ?? measuredIngredient.ingredient ?? "" != formattedIngredient
    }
    
    init(measuredIngredient: RecipeMeasuredIngredient, isShowing: Binding<Bool>) {
        self._measuredIngredient = State(initialValue: measuredIngredient)
        self._isShowing = isShowing
        
        // Parse measurement and ingredient
        if let measurementAndIngredient = measuredIngredient.nameAndAmountModified ?? measuredIngredient.nameAndAmount {
            if let parsedMeasuredIngredient = MeasurementIngredientParser.parseFirstMeasurement(from: measurementAndIngredient, leastToGreatestPossibleFractionValues: MeasuredIngredientPickerView.defaultMinToMaxFractionStrings) {
                // If using formatted editor
                _newIngredient = State(initialValue: parsedMeasuredIngredient.ingredient)
                _newAmount = State(initialValue: parsedMeasuredIngredient.amount ?? "")
                _newFraction = State(initialValue: parsedMeasuredIngredient.fraction ?? "")
                _newAbbreviatedMeasurement = State(initialValue: parsedMeasuredIngredient.abbreviatedMeasurementArray[parsedMeasuredIngredient.abbreviatedMeasurementIndex]) // TODO: Is it a good idea to use safe here? Is there any reason to catch this not being in the array?
                _newMeasurement = State(initialValue: "")
                _usingFormattedEditor = State(initialValue: true)
            } else {
                // If not using formatted editor
                _newIngredient = State(initialValue: measurementAndIngredient)
                _newAmount = State(initialValue: "")
                _newFraction = State(initialValue: "")
                _newAbbreviatedMeasurement = State(initialValue: Measurements.blankAbbreviatedMeasurement)
                
                _newMeasurement = State(initialValue: "")
                
                _usingFormattedEditor = State(initialValue: false)
            }
        } else {
            // If cannot unwrap measurementAndIngredient
            _newIngredient = State(initialValue: "")
            _newAmount = State(initialValue: "")
            _newFraction = State(initialValue: "")
            _newAbbreviatedMeasurement = State(initialValue: Measurements.blankAbbreviatedMeasurement)
            
            _newMeasurement = State(initialValue: "")
            
            _usingFormattedEditor = State(initialValue: false)
        }
    }
    
    
    var body: some View {
        VStack {
            HStack {
                Text("Edit Ingredient")
                    .font(.custom(Constants.FontName.black, size: 24.0))
                Spacer()
                Button(action: {
                    HapticHelper.doLightHaptic()
                    
                    if hasChanges {
                        alertShowingHasChangesToSave = true
                    } else {
                        withAnimation {
                            do {
                                try self.saveNewValuesAndClose()
                            } catch {
                                // TODO: Handle Errors
                                print("Error saving new values and closing in RecipeIngredientEditorView... \(error)")
                            }
                        }
                    }
                }) {
                    Text(Image(systemName: "xmark"))
                        .font(.custom(Constants.FontName.black, size: 24.0))
                        .foregroundStyle(Colors.elementBackground)
                }
            }
            
            HStack(spacing: 4.0) {
                if usingFormattedEditor {
                    // Use newAmount, newFraction, and newAbbreviatedMeasurement if using formatted editor
                    ZStack {
                        MeasuredIngredientPickerView(
                            amount: $newAmount,
                            fraction: $newFraction,
                            abbreviatedMeasurement: $newAbbreviatedMeasurement)
                        .padding(.leading, -10)
                        .padding(.trailing, -5)
                    }
                } else {
//                    // Use measurement if not using formatted editor
//                    TextField("Measurement", text: $newMeasurement)
//                        .textFieldTickerTint(colorScheme == .light ? Colors.elementBackground : Colors.foregroundText)
//                        .keyboardDismissingTextFieldToolbar("Done", color: Colors.elementBackground)
//                        .font(.custom(Constants.FontName.body, size: 17.0))
//                        .frame(minHeight: 40)
//                        .frame(maxWidth: 200)
//                        .padding([.leading, .trailing])
//                        .padding([.top, .bottom], 8)
//                        .background(Colors.foreground)
//                        .clipShape(UnevenRoundedRectangle(cornerRadii: RectangleCornerRadii(topLeading: 14.0, bottomLeading: 14.0)))
//                        .fixedSize(horizontal: true, vertical: true)
                }
                
                // Ingredient is common
                TextField("Ingredient*", text: $newIngredient, axis: .vertical)
                    .textFieldTickerTint(colorScheme == .light ? Colors.elementBackground : Colors.foregroundText)
                    .keyboardDismissingTextFieldToolbar("Done", color: Colors.elementBackground)
                    .font(.custom(Constants.FontName.black, size: 17.0))
                    .frame(minHeight: 40)
                    .padding([.leading, .trailing])
                    .padding([.top, .bottom], 8)
                    .background(Colors.foreground)
                    .clipShape(usingFormattedEditor
                               ?
                               // Only round the right side if using formatted editor
                               UnevenRoundedRectangle(cornerRadii: RectangleCornerRadii(bottomTrailing: 14.0, topTrailing: 14.0))
                               :
                                // Round all sides if not using formatted editor since this is the only field used
                                UnevenRoundedRectangle(cornerRadii: RectangleCornerRadii(topLeading: 14.0, bottomLeading: 14.0, bottomTrailing: 14.0, topTrailing: 14.0)))
            }
            .padding(.bottom)
            
            HStack {
                Button(action: {
                    HapticHelper.doLightHaptic()
                    
                    markForDeletion()
                    
                    withAnimation {
                        isShowing = false
                    }
                }) {
                    Text(Image(systemName: "trash"))
                        .aspectRatio(contentMode: .fit)
                        .font(.custom(Constants.FontName.heavy, size: 20.0))
                        .foregroundStyle(Colors.elementText)
                        .fixedSize(horizontal: true, vertical: true)
                }
                .padding(8)
                .background(Color(uiColor: .systemRed))
                .clipShape(RoundedRectangle(cornerRadius: 14.0))
                
                Button(action: {
                    HapticHelper.doWarningHaptic()
                    
                    alertShowingRevertIngredient = true
                }) {
                    Text(Image(systemName: "clock.arrow.circlepath"))
                        .aspectRatio(contentMode: .fit)
                        .font(.custom(Constants.FontName.medium, size: 20.0))
                        .foregroundStyle(Colors.elementText)
                        .fixedSize(horizontal: true, vertical: true)
                }
                .padding(8)
                .background(Color(uiColor: .systemYellow))
                .clipShape(RoundedRectangle(cornerRadius: 14.0))
                
                Button(action: {
                    HapticHelper.doSuccessHaptic()
                    
                    do {
                        try saveNewValuesAndClose()
                    } catch {
                        // TODO: Handle Errors
                        print("Error saving new values and closing in RecipeIngredientEditorView... \(error)")
                    }
                }) {
                    Spacer()
                    Text(measuredIngredient.markedForDeletion ? "Restore & Save" : "Save")
                        .font(.custom(Constants.FontName.heavy, size: 20.0))
                        .foregroundStyle(Colors.elementText)
                    Spacer()
                }
                .padding(8)
                .background(Colors.elementBackground)
                .clipShape(RoundedRectangle(cornerRadius: 14.0))
            }
            .fixedSize(horizontal: false, vertical: true)
            
        }
        .alert("Empty Ingredient", isPresented: $alertShowingDeleteEmpty, actions: {
            Button("Cancel", role: .cancel, action: {
                
            })
            
            Button("Delete", role: .destructive, action: {
                // Delete measured ingredient from viewContext and save context
                do {
                    try viewContext.performAndWait {
                        viewContext.delete(measuredIngredient)
                        
                        try viewContext.save()
                    }
                } catch {
                    // TODO: Handle Errors
                    print("Error deleting measuredIngredient in RecipeIngredientEditorView... \(error)")
                }
                
                withAnimation {
                    isShowing = false
                }
            })
        }) {
            Text("Please ensure there is text in the \"Ingredient\" field before saving.")
        }
        .alert("Save Changes", isPresented: $alertShowingHasChangesToSave, actions: {
            Button("Save", role: nil, action: {
                do {
                    try saveNewValuesAndClose()
                } catch {
                    // TODO: Handle Errors
                    print("Error saving new values and closing in RecipeIngredientEditorView... \(error)")
                }
            })
            
            Button("Don't Save", role: .destructive, action: {
                withAnimation {
                    isShowing = false
                }
            })
            
            Button("Back", role: .cancel, action: {
                
            })
        }) {
            Text("You have unsaved changes to this ingredient. Save changes?")
        }
        .alert("Revert Ingredient", isPresented: $alertShowingRevertIngredient, actions: {
            Button("Revert", role: nil, action: {
                do {
                    try revertIngredientAndMeasurement()
                } catch {
                    // TODO: Handle Error, show alert or something
                    print("Error reverting ingredient in RecipeIngredientEditorView... \(error)")
                }
                
                withAnimation {
                    isShowing = false
                }
            })
            
            Button("Cancel", role: .cancel, action: {
                
            })
        }) {
            Text("Revert ingredient to its original value?")
        }
    }
    
    private func markForDeletion() {
        measuredIngredient.markedForDeletion = true
        
        saveContext()
    }
    
    private func revertIngredientAndMeasurement() throws {
        try viewContext.performAndWait {
            measuredIngredient.nameAndAmount = nil
            measuredIngredient.markedForDeletion = false
            
            try viewContext.save()
        }
    }
    
    private func saveNewValuesAndClose() throws {
        // Ensure ingredient is not empty, otherwise show delete empty alert
        guard !formattedIngredient.isEmpty else {
            alertShowingDeleteEmpty = true
            return
        }
        
        try viewContext.performAndWait {
            if usingFormattedEditor {
                // Set modified values, resetting if the new ones are the same as the original values and setting if they are different
                let formattedMeasurementAndIngredient = formattedMeasurement + " " + formattedIngredient
                if formattedMeasurementAndIngredient == measuredIngredient.nameAndAmount {
                    measuredIngredient.nameAndAmountModified = nil
                } else {
                    measuredIngredient.nameAndAmountModified = formattedMeasurementAndIngredient
                }
            } else {
                // Set modified values to just ingredient, resetting if the new ingredient is the same as nameAndAmount and setting if they are different
                if formattedIngredient == measuredIngredient.nameAndAmount {
                    measuredIngredient.nameAndAmountModified = nil
                } else {
                    measuredIngredient.nameAndAmountModified = formattedIngredient
                }
            }
            
            // Set as not marked for deletion
            measuredIngredient.markedForDeletion = false
            
            // Save context
            try viewContext.save()
            
            // Dismiss
            withAnimation {
                isShowing = false
            }
        }
    }
    
    private func saveContext() {
        do {
            try viewContext.save()
        } catch {
            // TODO: Handle errors
            print("Could not save context in RecipeIngredientEditorView... \(error)")
        }
    }
}

@available(iOS 17.0, *)
#Preview(traits: .sizeThatFitsLayout) {
    let context = PersistenceController.shared.container.viewContext
    
    let measuredIngredient = RecipeMeasuredIngredient(context: context)
    
    measuredIngredient.nameAndAmount = "22a cup Ingredient"
    
    try! context.save()
    
    return RecipeIngredientEditorView(
        measuredIngredient: measuredIngredient,
        isShowing: .constant(true))
    .padding()
    .background(Colors.background)
}


RecipeOfTheDayReloadButton.swift
//#Preview {
//    
//    RecipeOfTheDayReloadButton()
//    
//}

////
////  RecipeOfTheDayReloadButton.swift
////  ChefApp-SwiftUI
////
////  Created by Alex Coundouriotis on 11/29/24.
////
//
//import SwiftUI
//
//struct RecipeOfTheDayReloadButton: View {
//    
//    let recipe: Recipe
//    let timeFrame: RecipeOfTheDayView.TimeFrames
////    let onReload: (_ recipe: Recipe, _ timeFrame: RecipeOfTheDayView.TimeFrames) -> Void
//    let onReload: () -> Void
//    
//    @State private var alertShowingConfirmReloadRecipe: Bool = false
//    
//    var body: some View {
//        Button(action: {
//            // If recipe is not saved, show alert
//            if !recipe.saved {
//                alertShowingConfirmReloadRecipe = true
//            } else {
//                onReload()
//            }
//        }) {
//            Image(systemName: "arrow.triangle.2.circlepath")
//        }
//        .alert("Reload Recipe?", isPresented: $alertShowingConfirmReloadRecipe, actions: {
//            Button("Reload") {
//                onReload()
//            }
//            Button("Cancel", role: .cancel) {
//                
//            }
//        }) {
//            Text("Create a new \(timeFrame.displayString.lowercased())? This will overrite the existing recipe.")
//        }
//    }
//    
//}
//
////#Preview {
////    
////    RecipeOfTheDayReloadButton()
////    
////}


Measurements.swift
//
//  Measurements.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/2/23.
//

import Foundation

struct Measurements {
    
    static let blankAbbreviatedMeasurement: AbbreviatedMeasurement = AbbreviatedMeasurement(
        abbreviation: "",
        alternatives: [])
    
    static let orderedMassMeasurements: [AbbreviatedMeasurement] = [
        AbbreviatedMeasurement(
            abbreviation: "g",
            alternatives: [
                "gram",
                "grams"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "oz",
            alternatives: [
                "ounce",
                "ounces"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "lb",
            alternatives: [
                "lbs",
                "pound",
                "pounds"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "kg",
            alternatives: [
                "kgs",
                "kilogram",
                "kilograms"
            ])
    ]

    static let orderedLengthMeasurements: [AbbreviatedMeasurement] = [
        AbbreviatedMeasurement(
            abbreviation: "mm",
            alternatives: [
                "millimeter",
                "millimeters"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "cm",
            alternatives: [
                "centimeter",
                "centimeters"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "in",
            alternatives: [
                "inch",
                "inches"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "ft",
            alternatives: [
                "foot",
                "feet"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "yd",
            alternatives: [
                "yard",
                "yards"
            ])
    ]

    static let orderedVolumeMeasurements: [AbbreviatedMeasurement] = [
        AbbreviatedMeasurement(
            abbreviation: "ml",
            alternatives: [
                "milliliter",
                "milliliters"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "tsp",
            alternatives: [
                "teaspoon",
                "teaspoons",
                "tsps"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "tbsp",
            alternatives: [
                "tablespoon",
                "tablespoons",
                "tbsps"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "fl oz",
            alternatives: [
                "fluid ounce",
                "fluid ounces"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "cup",
            alternatives: [
                "cup",
                "cups"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "pt",
            alternatives: [
                "pint",
                "pints"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "qt",
            alternatives: [
                "quart",
                "quarts"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "l",
            alternatives: [
                "litre",
                "litres",
                "liter",
                "liters"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "gal",
            alternatives: [
                "gallon",
                "gallons"
            ])
    ]

    static let orderedTemperatureMeasurements: [AbbreviatedMeasurement] = [
        AbbreviatedMeasurement(
            abbreviation: "C",
            alternatives: [
                "C",
                "celsius"
            ]),
        AbbreviatedMeasurement(
            abbreviation: "F",
            alternatives: [
                "F",
                "fahrenheit"
            ])
    ]
    
    static let allOrderedMeasurements: [[AbbreviatedMeasurement]] = [
        orderedMassMeasurements,
        orderedLengthMeasurements,
        orderedVolumeMeasurements,
        orderedTemperatureMeasurements
    ]
    
}


AbbreviatedMeasurement.swift
//
//  AbbreviatedMeasurement.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/2/23.
//

import Foundation

struct AbbreviatedMeasurement: Hashable {
    var abbreviation: String
    var alternatives: [String]
}


IngredientMeasurementAmountParser.swift
////
////  IngredientMeasurementAmountParser.swift
////  Barback
////
////  Created by Alex Coundouriotis on 10/3/23.
////
//
//import Foundation
//
//class IngredientMeasurementAmountParser {
//    
//    struct ParsedMeasurementAmount {
//        var amount: String?
//        var fraction: String?
//        var abbreviatedMeasurementArray: [AbbreviatedMeasurement]
//        var abbreviatedMeasurementIndex: Int
//    }
//    
//    static func parseFirstMeasurement(from string: String, leastToGreatestPossibleFractionValues: [String]) -> ParsedMeasurementAmount? {
//        for abbreviatedMeasurementArray in Measurements.allOrderedMeasurements {
//            for i in 0..<abbreviatedMeasurementArray.count {
//                // Get abbreviatedMeasurement
//                let abbreviatedMeasurement = abbreviatedMeasurementArray[i]
//                
//                // Loop through abbreviation and alternatives for abbreviatedMeasurement
//                for j in 0..<(1 + abbreviatedMeasurement.alternatives.count) {
//                    // Get measurementString
//                    let measurementString = j == 0 ? abbreviatedMeasurement.abbreviation : abbreviatedMeasurement.alternatives[j - 1]
//                    
//                    // Create regular expression pattern..
//                    // Right now it is different than below, and it will match any number with or without decimal and or fraction followed by any amount of whitespace and measurementString
////                    - `\b`: This is a word boundary. This ensures that the match will not be part of a larger word.
////                    - `(?<amount>\d+(?:\.\d+)?(?:\s+\d+\/\d+)?)?`: This is an optional named group (called "amount") that matches amounts with the following pattern `numbers , ( decimal numbers or fractional numbers)`. Numbers can be decimal or fractional as follows:
////                      - `\d+`: Match one or more digits.
////                      - `(?:\.\d+)?`: Non-capturing group (due to `?:`) to optionally match a decimal number i.e `.and any number of digits afterwards`.
////                      - `(?:\s+\d+\/\d+)?`: Non-capturing group (due to `?:`) to optionally match a fraction number `i.e space, digits , slash '/' , digits`
////                    - `\s*`: Match zero or more whitespace characters.
////                    - `(?<unit>\w+)?`: This is an optional named group (called "unit") that matches one or more word characters.
////                    - `\s*`: Match zero or more whitespace characters.
////                    - `(?<ingredient>.*)?`: This is another optional named group (called "ingredient") that matches any character (.) zero or more times (*), i.e., it will match whatever is left in the string after matching the amount and unit.
////                    - `\b`: This is again a word boundary.
////                    let pattern = "\b\d+(\.\d+)?+\s+\b\(measurementString)\b"
////                    let pattern = "(\d+(\.\d+)?\s*)(\d+/\d+\s*)?(\(measurementString)\b)"
////                    let pattern = "\b(?<amount>\d+(?:\.\d+)?(?:\s+\d+\/\d+)?)?(?:\s*(?<unit>\w+))?(?:\s*(?<ingredient>.*))?\b"
//                    /* Get Number and Fraction Strings */
//                    let amountName = "amount"
////                    let amountMeasurementPattern = "\b(?<\(amountName)>\d+(?:\.\d+)?(?:\s+\d+\/\d+)?)\s+\b\(measurementString)\b"
//                    let amountMeasurementPattern = "\b(?<\(amountName)>(?:\d+)?(?:\.\d+)?((?:\d\s+)?(?:\d+\/\d+))?)\s+\b\(measurementString)\b"
//                    
//                    // Create regular expression with the option of caseInsensitive to search for matching string regardless of case
//                    let amountMeasurementRegex = try? NSRegularExpression(pattern: amountMeasurementPattern, options: .caseInsensitive)
//                    
//                    // Get the first match and unwrap, otherwise continue TODO: Maybe the measurement thing support multiple matches.. is that even necessary?
//                    guard let amountMeasurementFirstMatch = amountMeasurementRegex?.firstMatch(in: string, range: NSRange(location: 0, length: string.utf16.count)) else {
//                        continue
//                    }
//                    
//                    // Get the amountString from amount in firstMatch
//                    let amountNSRange = amountMeasurementFirstMatch.range(withName: amountName)
//                    guard amountNSRange.location != NSNotFound, let amountRange = Range(amountNSRange, in: string) else {
//                        continue
//                    }
//                    let amountString = String(string[amountRange])
//                    
//                    // Parse amountString into amount number and fraction
////                    let numberName = "number"
////                    let fractionName = "fraction"
////                    let amountNumberFractionPattern = "\b(?<\(numberName)>\d+(?:.\d+)?)?(?:(?<\(fractionName)>\s+\d+\/\d+)?)"
//                    
//                    // Create regular expression with the option of caseInsensitive to serach for matching string regardless of case, even though its numbers here I guess lol
////                    let amountNumberFractionRegex = try? NSRegularExpression(pattern: amountNumberFractionPattern, options: .caseInsensitive)
//                    
//                    // Get the first match and unwrap, otherwise continue
////                    guard let amountNumberFractionFirstMatch = amountNumberFractionRegex?.firstMatch(in: amountString, range: NSRange(location: 0, length: amountString.utf16.count)) else {
////                        continue
////                    }
//                    
//                    
//                    
//                    // Will always be in the format 1, 1.5, 1/2, or 1 1/2
//                    // So split by spaces, we get (1), (1.5), (1/2), (1, 1/2)
//                    // If the first is a double, get its fraction
//                    
//                    // Split amountString by space
//                    let spaceSplitAmountString = amountString.split(separator: " ")
//                    
//                    // Ensure spaceString has at least one and no more than 2 values, otherwise continue
//                    guard spaceSplitAmountString.count > 0 && spaceSplitAmountString.count <= 2 else {
//                        continue
//                    }
//                    
//                    // Get the numberString and fractionString
//                    var numberString: String? = nil, fractionString: String? = nil
//                    if let intValue = Int(String(spaceSplitAmountString[0])) {
//                        // If it's an int, set the numberString as an int
//                        numberString = "\(intValue)"
//                        
//                        // Get the fraction if there is one
//                        if spaceSplitAmountString.count == 2, let solvedFractionFromSecondAmountString = StringFractionSolver.solveFraction(from: String(spaceSplitAmountString[1])) {
//                            // Set fractionString to the result of getFractionString from DecimalToFractionStringAdapter
//                            fractionString = DecimalToFractionStringAdapter.getFractionString(from: solvedFractionFromSecondAmountString, leastToGreatestPossibleValues: leastToGreatestPossibleFractionValues)
//                        }
//                    } else {
//                        // Ensure the count of spaceSplitAmountString is 1 before proceeding, otherwise continue, as there should only be one double or a fraction by itself or with a whole number
//                        guard spaceSplitAmountString.count == 1 else {
//                            continue
//                        }
//                        
//                        // TODO: If first number is a double or fraction and there is a second number, continue
//                        // Not a int, check if it is a double or fraction, setting doubleValue with the double or solved fraction equation, otherwise continue
//                        let solvedDoubleValue: Double
//                        if let doubleValue = Double(String(spaceSplitAmountString[0])) {
//                            // Got double, so set solvedDoubleValue to doubleValue
//                            solvedDoubleValue = doubleValue
//                        } else {
//                            // Solve fraction and set to solvedDoubleValue, otherwise continue
//                            guard let solvedFractionFromFirstAmountString = StringFractionSolver.solveFraction(from: String(spaceSplitAmountString[0])) else {
//                                continue
//                            }
//                            solvedDoubleValue = solvedFractionFromFirstAmountString
//                        }
//                        
//                        // numberString is the Int value of solvedDoubleValue
//                        numberString = String(Int(solvedDoubleValue))
//                        
//                        // fractionString is the result of getFractionString from DecimalToFractionStringAdapter
//                        fractionString = DecimalToFractionStringAdapter.getFractionString(from: solvedDoubleValue, leastToGreatestPossibleValues: leastToGreatestPossibleFractionValues)
//                        
//                        // If numberString is 0 and there is a fraction, set numberString to nil
//                        if fractionString != nil, numberString != nil, let numberStringInt = Int(numberString!), numberStringInt == 0 {
//                            numberString = nil
//                        }
//                    }
//                    
//                    
//                    
////                    let numberNSRange = amountNumberFractionFirstMatch.range(withName: numberName)
////                    let fractionNSRange = amountNumberFractionFirstMatch.range(withName: fractionName)
////                    if numberNSRange.location != NSNotFound, let numberRange = Range(numberNSRange, in: amountString) {
////                        numberString = String(amountString[numberRange]).trimmingCharacters(in: .whitespaces)
////                    }
////                    if fractionNSRange.location != NSNotFound, let fractionRange = Range(fractionNSRange, in: amountString) {
////                        fractionString = String(amountString[fractionRange]).trimmingCharacters(in: .whitespaces)
////                    }
//                    
//                    /* Get Ingredient */
//                    // Get and unwrap amount measurement measurement range in string from amountMeasurementFirstMatch range, otherwise continue
//                    guard let amountMeasurementRangeInString = Range(amountMeasurementFirstMatch.range, in: string) else {
//                        continue
//                    }
//                    
////                    // Get ingredient from string if range location is 0 or range location + range length is the length of the string and get measurementOnLeft depending on if the measurement is on the left side of the string, otherwise return TODO: How would I convert these to using the measurementRangeInString?
////                    let ingredient: String
////                    let measurementOnLeft: Bool
////                    if amountMeasurementFirstMatch.range.location == 0 {
////                        // If measurement is at the beginning of the string, set ingredient to everything after the range
////                        ingredient = String(string[amountMeasurementRangeInString.upperBound...]).trimmingCharacters(in: .whitespaces)
////                        measurementOnLeft = true
////                    } else if amountMeasurementFirstMatch.range.location + amountMeasurementFirstMatch.range.length == string.count {
////                        // If measurement is at the end of the string, set ingredient to everything before the range
////                        ingredient = String(string[..<amountMeasurementRangeInString.lowerBound]).trimmingCharacters(in: .whitespaces)
////                        measurementOnLeft = false
////                    } else {
////                        // First match is not at the beginning or end of the string, so continue TODO: Maybe allow for more flexibility?
////                        continue
////                    }
////                    
////                    // Get measurement from string
////                    let measurement = String(string[measurementRangeInString])
////
////                    // Parse the number out of the measurement string, continuing if any optionals fail to unwrap
////                    let numberPattern = "\d+(\.\d+)?"
////                    let numberRegex = try? NSRegularExpression(pattern: numberPattern)
////                    guard let numberFirstMatch = numberRegex?.firstMatch(in: measurement, range: NSRange(location: 0, length: measurement.utf16.count)), let numberRange = Range(numberFirstMatch.range, in: measurement) else {
////                        continue
////                    }
////                    guard let amount = Double(String(measurement[numberRange])) else {
////                        continue
////                    }
//                    
//                    // Return ParsedMeasurementIngredient with amount, abbreviatedMeasurementArray, index of abbreviated measurement i, ingredient string, and if the measurement is on the left side
//                    return ParsedMeasurementAmount(
//                        amount: numberString,
//                        fraction: fractionString,
//                        abbreviatedMeasurementArray: abbreviatedMeasurementArray,
//                        abbreviatedMeasurementIndex: i)
//                }
//            }
//        }
//        
//        return nil
//        
//    }
//    
//}


RecipeOfTheDayGenerator.swift
//
//  RecipeOfTheDayGenerator.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/30/24.
//

import CoreData
import Foundation
import SwiftUI

class RecipeOfTheDayGenerator: RecipeGenerator {
    
    @Published var isLoadingPreGeneration: Bool = false
    
    var isLoading: Bool {
        isLoadingPreGeneration || (isCreating && !isFinalizing && !isGeneratingBingImage && !isGeneratingTags)
    }
    
    func reloadDailyRecipe(dailyRecipes: FetchedResults<Recipe>, pantryItems: FetchedResults<PantryItem>, recipe: Recipe, timeFrame: RecipeOfTheDayView.TimeFrames, in managedContext: NSManagedObjectContext) async {
        guard !isLoading else { return }
        defer { DispatchQueue.main.async { self.isLoadingPreGeneration = false } }
        await MainActor.run { isLoadingPreGeneration = true }
        
        // Get name of previous recipe so that the new one can be different than it
        let previousRecipeName = recipe.name ?? ""
        
        // Delete or save and update recipe
        await deleteOrSaveAndUpdateRecipe(recipe, in: managedContext)
        
        // Generate new daily recipe
        do {
            try await generateDailyRecipe(dailyRecipes: dailyRecipes, pantryItems: pantryItems, timeFrame: timeFrame, additionalModifiers: "

Make it different than \(previousRecipeName).", in: managedContext)
        } catch {
            // TODO: Handle Errors if Necessary
            print("Error generating daily recipe in reload process in RecipeOfTheDayContainer, continuing... \(error)")
        }
    }
    
    func processDailyRecipes(dailyRecipes: FetchedResults<Recipe>, pantryItems: FetchedResults<PantryItem>, in managedContext: NSManagedObjectContext) async {
        guard !isLoading else { return }
        defer { DispatchQueue.main.async { self.isLoadingPreGeneration = false } }
        await MainActor.run { isLoadingPreGeneration = true }
        
//                guard let currentTimeFrame = RecipeOfTheDayView.TimeFrames.timeFrame(for: Date()) else {
//                    // TODO: Handle Errors
//                    print("Could not unwrap currentTimeFrame in RecipeOfTheDayContainer!")
//                    return
//                }
        
        // Scrub yesterday and previous days' recipes that are not saved and save ones that should be
        for dailyRecipe in dailyRecipes {
            if let creationDate = dailyRecipe.creationDate {
                if !Calendar.current.isDateInToday(creationDate) {
                    // Delete or save and update recipe because not today
                    await deleteOrSaveAndUpdateRecipe(dailyRecipe, in: managedContext)
                }
            } else {
                // Delete or save and update recipe because no creationDate TODO: Should this just outright delete it?
                await deleteOrSaveAndUpdateRecipe(dailyRecipe, in: managedContext)
            }
        }
        
        // Generate new daily breakfast, lunch, and dinner recipes as necessary
        do {
            try await generateDailyRecipe(dailyRecipes: dailyRecipes, pantryItems: pantryItems, timeFrame: .breakfast, additionalModifiers: nil, in: managedContext)
        } catch {
            // TODO: Handle Errors if Necessary
            print("Error generating daily breakfast recipe in RecipeOfTheDayContainer, continuing... \(error)")
        }
        do {
            try await generateDailyRecipe(dailyRecipes: dailyRecipes, pantryItems: pantryItems, timeFrame: .lunch, additionalModifiers: nil, in: managedContext)
        } catch {
            // TODO: Handle Errors if Necessary
            print("Error generating daily breakfast recipe in RecipeOfTheDayContainer, continuing... \(error)")
        }
        do {
            try await generateDailyRecipe(dailyRecipes: dailyRecipes, pantryItems: pantryItems, timeFrame: .dinner, additionalModifiers: nil, in: managedContext)
        } catch {
            // TODO: Handle Errors if Necessary
            print("Error generating daily breakfast recipe in RecipeOfTheDayContainer, continuing... \(error)")
        }
    }
    
    func deleteOrSaveAndUpdateRecipe(_ recipe: Recipe, in managedContext: NSManagedObjectContext) async {
        if recipe.saved {
            // Save by setting isDailyRecipe and isSavedToRecipes to false
            do {
                try await RecipeCDClient.updateRecipe(recipe, dailyRecipe_isDailyRecipe: false, in: managedContext)
            } catch {
                // TODO: Handle Errors
                print("Error updating recipe isDailyRecipe in RecipeOfTheDayContainer... \(error)")
            }
        } else {
            // Delete
            do {
                try await RecipeCDClient.deleteRecipe(recipe, in: managedContext)
            } catch {
                // TODO: Handle Errors
                print("Error deleting recipe in RecipeOfTheDayContainer, continuing... \(error)")
            }
        }
    }
    
    func generateDailyRecipe(dailyRecipes: FetchedResults<Recipe>, pantryItems: FetchedResults<PantryItem>, timeFrame: RecipeOfTheDayView.TimeFrames, additionalModifiers: String?, in managedContext: NSManagedObjectContext) async throws {
        // Set isLoadingPreGeneration to false since pre-generation loading is complete
        await MainActor.run { isLoadingPreGeneration = false }
        
        // Create if no dailyRecipe for timeFrame
        if !dailyRecipes.contains(where: {
            //            guard let dailyRecipeTimeFrame = RecipeOfTheDayView.TimeFrames.timeFrame(for: $0.creationDate ?? Date()) else {
            //                // TODO: Delete recipe? Handle this
            //                return false
            //            }
            guard let dailyRecipeTimeFrameID = $0.dailyRecipe_timeFrameID,
                  let dailyRecipeTimeFrame = RecipeOfTheDayView.TimeFrames(rawValue: dailyRecipeTimeFrameID) else {
                // TODO: Delete recipe? Handle this
                print("Could not unwrap timeFrameID or timeFrame in RecipeOfTheDayContainer!")
                return false
            }
            
            return timeFrame == dailyRecipeTimeFrame
        }) {
            // Generate daily recipe and image for current time frame
            do {
                let recipe = try await create(
                    ingredients: pantryItems.compactMap(\.name).joined(separator: ", "),
                    modifiers: "Select from this list and create a delicious \(timeFrame.displayString)." + (additionalModifiers ?? ""),
                    expandIngredientsMagnitude: 0,
                    dailyRecipe_isDailyRecipe: true,
                    dailyRecipe_timeFrameID: timeFrame.rawValue,
                    in: managedContext)
                
                try await generateBingImage(
                    recipe: recipe,
                    in: managedContext)
            } catch {
                // TODO: Handle Errors
                print("Error creating recipe in RecipeOfTheDayContainer... \(error)")
            }
        } else {
            throw RecipeOfTheDayError.recipeOfTheDayExistsForTimeframe
        }
    }
    
}


CapReachedCard.swift
//
//  CapReachedCard.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/19/24.
//

import SwiftUI

struct CapReachedCard: View {
    
    @State private var isShowingUltraView: Bool = false
    
    var body: some View {
        ZStack {
            HStack {
                Spacer()
                VStack {
                    Spacer()
                    Text("Cap Reached")
                        .font(.custom(Constants.FontName.black, size: 28.0))
                        .foregroundStyle(Colors.foregroundText)
                        .padding(.bottom, 8)
                    
                    Text("Full recipes use a lot of resources to generate, so free users are limited. Please upgrade to get unlimited recipes & more!")
                        .font(.custom(Constants.FontName.body, size: 17.0))
                        .foregroundStyle(Colors.foregroundText)
                        .multilineTextAlignment(.center)
                        .padding(.bottom, 8)
                    
                    Text("Unlock 3 Days FREE by Upgrading Today...")
                        .font(.custom(Constants.FontName.heavyOblique, size: 14.0))
                        .multilineTextAlignment(.center)
                    
                    Button(action: {
                        HapticHelper.doLightHaptic()
                        
                        isShowingUltraView = true
                    }) {
                        Spacer()
                        VStack {
                            Text("Upgrade Now \(Image(systemName: "chevron.right"))")
                                .font(.custom(Constants.FontName.black, size: 24.0))
                            Text("First 3 Days Free & UNLIMITED!")
                                .font(.custom(Constants.FontName.bodyOblique, size: 14.0))
                        }
                        Spacer()
                    }
                    .foregroundStyle(Colors.elementText)
                    .padding()
                    .background(Colors.elementBackground)
                    .clipShape(RoundedRectangle(cornerRadius: 24.0))
                    Spacer()
                }
                Spacer()
            }
        }
        .padding()
        .background(Colors.foreground)
        .clipShape(RoundedRectangle(cornerRadius: 24.0))
        .ultraViewPopover(isPresented: $isShowingUltraView)
    }
    
}

#Preview {
    CapReachedCard()
}


RecipeGenerationView.swift
//
//  RecipeGenerationView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/3/23.
//

// Generates and lists between 1-2 for free and 3-5 for premium names and summaries, with a button to generate another for premium and some blank "tap to unlock" premium promotional locked name and summary rows

import CoreData
import SwiftUI

struct RecipeGenerationView: View {
    
    @ObservedObject var recipeGenerator: RecipeGenerator
    let recipeGenerationSpec: RecipeGenerationSpec
//    @Binding var selectedPantryItems: [PantryItem]
//    @Binding var selectedSuggestions: [String]
//    @Binding var input: String
//    @Binding var generationAdditionalOptions: RecipeGenerationAdditionalOptions
    let onDismiss: () -> Void
    let didSaveRecipe: (Recipe) -> Void
    
    
    private let lockedRecipePanelCount: Int = Int.random(in: 2...5)
    private let lockedRecipePanelShowDelay: CGFloat = 0.5
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @EnvironmentObject private var premiumUpdater: PremiumUpdater
    
//    @State private var isLoadingRecipe: Bool = false
    
    @State private var createdRecipes: [Recipe] = []
    
    @State private var presentingRecipe: Recipe?
    
    @State private var lockedRecipePanelsShowing: Int = 0
    @State private var isLoadingLockedRecipePanels: Bool = false
    
    @State private var isDisplayingCapReachedCard: Bool = false
    
    @State private var isShowingUltraView: Bool = false
    
    private var maxAutoGenerate: Int {
        premiumUpdater.isPremium ? Constants.Generation.premiumAutomaticRecipeGenerationLimit : Constants.Generation.freeAutomaticRecipeGenerationLimit
    }
    
    private var parsedInput: String {
        // TODO: Should I add anything else to the input string if selectedPantryItems is not empty?
        // Create parsedInput starting with input
        var parsedInput = recipeGenerationSpec.input
        
        // If selectedPantryItems is not empty add generationAdditionalOptions additional string and selectedPantryItems separated by commas
        if !recipeGenerationSpec.pantryItems.isEmpty {
            parsedInput += recipeGenerationSpec.generationAdditionalOptions == .boostCreativity ? "
Ingredients: " : recipeGenerationSpec.generationAdditionalOptions == .useOnlyGivenIngredients ? "
Select From: " : "
Ingredients: "
            parsedInput += recipeGenerationSpec.pantryItems.compactMap({$0.name}).joined(separator: ", ") // TODO: Should there be anything else if the name cannot be unwrapped? Since that is the only attribute besides category it's most likely always going to be filled, right, or at least it's expected behaviour to be filled, so it's probably fine to just compactmap filtering with just the name
        }
        
        return parsedInput
    }
    
    private var parsedInputDifferentThanNewRecipes: String {
        parsedInput + (createdRecipes.count > 0 ? "
Different than: " + createdRecipes.compactMap({$0.name != nil && $0.summary != nil ? "\($0.name!), \($0.summary!)" : nil}).joined(separator: "
And different than: ") : "")
    }
    
    private var parsedModifiers: String? {
        // Right now if selectedSuggestions is empty nil, otherwise just the selectedSuggestions separated by commas
        recipeGenerationSpec.suggestions.isEmpty ? nil : recipeGenerationSpec.suggestions.joined(separator: ", ")
    }
    
    private var isLoadingRecipe: Bool {
        recipeGenerator.isCreating
    }
    
    var body: some View {
        ZStack {
            VStack(spacing: 0.0) {
                //            header
                
                generatingList
            }
        }
        .chefAppHeader(
            showsDivider: true,
            left: {
                Button(action: {
                    HapticHelper.doLightHaptic()
                    
                    onDismiss()
                }) {
                    Text("Close")
                        .font(.custom(Constants.FontName.heavy, size: 20.0))
                        .foregroundStyle(Colors.elementText)
                        .padding(.leading)
                        .padding(.bottom, 10)
                }
            },
            right: {
                
            })
        .ignoresSafeArea()
        .saveRecipePopup(
            recipe: $presentingRecipe,
            didSaveRecipe: { recipe in
                didSaveRecipe(recipe)
            })
        .ultraViewPopover(isPresented: $isShowingUltraView)
        .task {
            do {
                // Clear recipeGenerator createdRecipes
                await MainActor.run {
                    createdRecipes = []
                }
                
                // Generate next
                try await generateNext()
                
                // Do light haptic
                HapticHelper.doLightHaptic()
                
                // If not premium, show locked recipe panels
                if !premiumUpdater.isPremium {
                    try await showLockedRecipePanels()
                }
            } catch {
                // TODO: Handle errors
                print("Could not generate next recipe in RecipeGenerationView... \(error)")
            }
        }
        .onChange(of: isShowingUltraView, perform: { value in
            // If ultra view is dismissed, generateNext in case the user has upgraded to premium
            if !value {
                Task {
                    do {
                        // Generate next if newRecipeIDs is less than maxAutoGenerate, which may happen if the user upgrades to premium and therefore has more recipes that can be generated
                        if createdRecipes.count < maxAutoGenerate {
                            // Generate next
                            try await generateNext()
                            
                            // Do light haptic
                            HapticHelper.doLightHaptic()
                        }
                        
                    } catch {
                        // TODO: Handle errors
                        print("Could not generate next recipe in RecipeGenerationView... \(error)")
                    }
                }
            }
        })
        .onReceive(recipeGenerator.$isCapReached) { newValue in
            if !premiumUpdater.isPremium {
                isDisplayingCapReachedCard = newValue
            }
        }
    }
    
    var generatingList: some View {
        ZStack {
            ScrollView {
                //                let newRecipes = recipes.compactMap({ recipe in
                //                    newRecipeIDs.contains(where: { newRecipeID in
                //                        recipe.recipeID == newRecipeID
                //                    }) ? recipe : nil
                //                })
                // Instructional text at the top
                if !isDisplayingCapReachedCard {
                    Text("Tap a preview to finish generating...")
                        .font(.custom(Constants.FontName.bodyOblique, size: 17.0))
                        .padding()
                        .opacity(0.8)
                }
                
                // Cap reached card
                if isDisplayingCapReachedCard {
                    CapReachedCard()
                        .padding()
                }
                
                // Recipe Panels
                ForEach(createdRecipes) { recipe in
//                    if recipe.contains(where: {$0 == recipe.recipeID}) {
                        if let name = recipe.name {
                            Button(action: {
                                HapticHelper.doLightHaptic()
                                
                                presentingRecipe = recipe
                            }) {
                                VStack {
                                    RecipeMiniView.from(recipe: recipe)
                                    if let ingredients = recipe.measuredIngredients?.allObjects as? [RecipeMeasuredIngredient] {
                                        ScrollView(.horizontal) {
                                            HStack {
                                                ForEach(ingredients) { ingredient in
                                                    if let ingredientNameAndAmount = ingredient.nameAndAmount {
                                                        Text(ingredientNameAndAmount) // TODO: Parse out ingredient names
                                                            .font(.custom(Constants.FontName.body, size: 12.0))
                                                            .padding([.leading, .trailing])
                                                            .padding([.top, .bottom], 2)
                                                            .background(Colors.background)
                                                            .clipShape(RoundedRectangle(cornerRadius: 15.0))
                                                            .lineLimit(1)
                                                    }
                                                }
                                                
                                                Spacer()
                                            }
                                        }
                                    }
                                }
                                .tint(Colors.foregroundText)
                                
                                Text(Image(systemName: "chevron.right"))
                                    .font(.custom(Constants.FontName.body, size: 17.0))
                                    .foregroundStyle(Colors.foregroundText)
                            }
                            .padding()
                            .background(Colors.foreground)
                            .clipShape(RoundedRectangle(cornerRadius: 28.0))
                            .padding([.leading, .trailing])
                        }
//                    }
                    //                    Text(recipe.name ?? "")
                    //                    if let updateDate = recipe.updateDate {
                    //                        Text(NiceDateFormatter.dateFormatter.string(from: updateDate))
                    //                    }
                }
                
                // Premium Locked Panels
                if !premiumUpdater.isPremium {
                    ForEach(0..<lockedRecipePanelsShowing, id: \.self) { i in
                        Button(action: {
                            HapticHelper.doLightHaptic()
                            
                            isShowingUltraView = true
                        }) {
                            ZStack {
                                HStack {
                                    Spacer()
                                    Text(Image(systemName: "chevron.right"))
                                        .font(.custom(Constants.FontName.body, size: 17.0))
                                        .foregroundStyle(Colors.foregroundText)
                                }
                                
                                VStack {
                                    HStack {
                                        Spacer()
                                        VStack {
                                            Text(Image(systemName: "lock"))
                                                .font(.custom(Constants.FontName.medium, size: 24.0))
                                                .foregroundStyle(Colors.foregroundText)
                                            Text("Tap to Unlock More")
                                                .font(.custom(Constants.FontName.medium, size: 17.0))
                                                .foregroundStyle(Colors.foregroundText)
                                        }
                                        Spacer()
                                    }
                                }
                            }
                        }
                        .padding()
                        .background(Colors.foreground)
                        .clipShape(RoundedRectangle(cornerRadius: 28.0))
                        .padding([.leading, .trailing])
                    }
                }
                
                // Loading Recipe Panel
                if isLoadingRecipe || isLoadingLockedRecipePanels {
                    ZStack {
                        HStack {
                            Spacer()
                            VStack(spacing: 0.0) {
                                Text("Creating...")
                                    .font(.custom(Constants.FontName.black, size: 24.0))
                                    .foregroundStyle(Colors.foregroundText)
                                ProgressView()
                                    .foregroundStyle(Colors.foregroundText)
                            }
                            Spacer()
                        }
                    }
                    .padding()
                    .background(Colors.foreground)
                    .clipShape(RoundedRectangle(cornerRadius: 28.0))
                    .padding([.leading, .trailing])
                }
                
                // Tap to Craft Another Panel
                if !isLoadingRecipe && !isLoadingLockedRecipePanels && !isDisplayingCapReachedCard {
                    ZStack {
                        Button(action: {
                            HapticHelper.doLightHaptic()
                            
                            if premiumUpdater.isPremium {
                                Task {
                                    do {
                                        try await generateNext()
                                        
                                        HapticHelper.doSuccessHaptic()
                                    } catch {
                                        // TODO: Handle errors
                                        print("Could not generate next recipe in RecipeGenerationView... \(error)")
                                    }
                                }
                            } else {
                                isShowingUltraView = true
                            }
                        }) {
                            Spacer()
                            Text("Tap to Craft Another...")
                                .font(.custom(Constants.FontName.heavy, size: 24.0))
                                .foregroundStyle(Colors.elementBackground)
                            if !premiumUpdater.isPremium {
                                Text(Image(systemName: "lock"))
                                    .font(.custom(Constants.FontName.heavy, size: 24.0))
                                    .foregroundStyle(Colors.elementBackground)
                            }
                            Spacer()
                        }
                    }
                    .padding()
                    .background(Colors.foreground)
                    .clipShape(RoundedRectangle(cornerRadius: 28.0))
                    .padding([.leading, .trailing])
                    .disabled(isLoadingRecipe || isLoadingLockedRecipePanels)
                    .opacity(isLoadingRecipe || isLoadingLockedRecipePanels ? 0.4 : 1.0)
                }
                
                Spacer(minLength: 80.0)
            }
            .scrollIndicators(.never)
        }
    }
    
    func generateNext() async throws {
        print(parsedInputDifferentThanNewRecipes)
        
        // If recipeID can be unwrapped from creating a recipe with recipeGenerator, get recipe ingredients preview, update remaining, and generateNext
        let recipe = try await recipeGenerator.create(
            ingredients: parsedInputDifferentThanNewRecipes,
            modifiers: parsedModifiers,
            expandIngredientsMagnitude: recipeGenerationSpec.generationAdditionalOptions.rawValue, // TODO: This should also be some string value on the server instead of expandIngredientsMagnitude as the advanced options could have more functionality this way :)
            in: viewContext)
        
        createdRecipes.append(recipe)
        
        // Generate bing image
        try await recipeGenerator.generateBingImage(
            recipe: recipe,
            in: viewContext)
        
        // Set isLoadingRecipe to false and generate next if it is auto generating
        if createdRecipes.count < maxAutoGenerate {
            HapticHelper.doLightHaptic()
            
            try await generateNext()
        }
    }
    
//    func generateBingImage(recipe: Recipe, in managedContext: NSManagedObjectContext) async {
//        /* Bing Image */
//        do {
//            try await recipeGenerator.generateBingImage(recipe: recipe, in: viewContext)
//        } catch {
//            // TODO: Handle Errors
//            print("Error generating bing image in RecipeView... \(error)")
//        }
//    }
    
    func showLockedRecipePanels() async throws {
        // Ensure user is not premium, otherwise return
        guard !premiumUpdater.isPremium else {
            // TODO: Handle errors
            return
        }
        
        // Defer setting lockedPanelsLoading to false to ensure it is set when the function finishes
        defer {
            isLoadingLockedRecipePanels = false
        }
        
        // Set lockedPanelsLoading to true to get the loading indicator back
        isLoadingLockedRecipePanels = true
        
        for i in 0..<lockedRecipePanelCount {
            try await Task.sleep(nanoseconds: UInt64(1_000_000_000 * lockedRecipePanelShowDelay))
            
            lockedRecipePanelsShowing += 1
        }
    }
    
}

#Preview {
    let context = CDClient.mainManagedObjectContext
    
    let recipe = Recipe(context: context)
    
    recipe.name = "Test recipe name"
    
    try! context.save()
    
//    UserDefaults.standard.set("", forKey: Constants.UserDefaults.authTokenKey)
    
    return RecipeGenerationView(
        recipeGenerator: RecipeGenerator(),
        recipeGenerationSpec: RecipeGenerationSpec(
            pantryItems: [],
            suggestions: [],
            input: "something delicious with coca cola",
            generationAdditionalOptions: .normal),
        onDismiss: {
            
        },
        didSaveRecipe: { recipe in
            
        })
    .environment(\.managedObjectContext, context)
    .environmentObject(PremiumUpdater())
    .environmentObject(ProductUpdater())
    .environmentObject(RemainingUpdater())
    .background(Colors.background)
}



SaveRecipeView.swift
//
//  SaveRecipeView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/6/23.
//

import Foundation
import SwiftUI

struct SaveRecipeView: View {
    
    @ObservedObject var recipe: Recipe
//    var namespace: Namespace.ID? = nil
//    var imageAnimationID: String? = nil
//    var nameAnimationID: String? = nil
//    var summaryAnimationID: String? = nil
    let onDismiss: () -> Void
    var didSaveRecipe: () -> Void
    
    
    @Environment(\.managedObjectContext) var viewContext
    
    @StateObject var recipeGenerator: RecipeGenerator = RecipeGenerator()
    
    var body: some View {
        VStack(spacing: 0.0) {
//            header
            
            RecipeView(
                recipeGenerator: recipeGenerator,
                recipe: recipe,
                showsCloseButton: false,
//                namespace: namespace,
//                imageAnimationID: imageAnimationID,
//                nameAnimationID: nameAnimationID,
//                summaryAnimationID: summaryAnimationID,
                onDismiss: onDismiss)
        }
        .navigationBarTitleDisplayMode(.inline)
        .toolbarBackground(Colors.background, for: .navigationBar)
        .navigationTitle("Save Recipe")
        .toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button(action: {
                    HapticHelper.doLightHaptic()
                    
                    withAnimation {
                        onDismiss()
                    }
                }) {
                    Text("Back")
                        .font(.custom(Constants.FontName.heavy, size: 17.0))
                        .foregroundStyle(Colors.elementBackground)
                }
            }
            
            ToolbarItem(placement: .topBarTrailing) {
                Button(action: {
                    HapticHelper.doLightHaptic()
                    
                    Task {
                        await setAsSaved()
                    }
                    
                    didSaveRecipe()
                }) {
                    Text("Save")
                        .font(.custom(Constants.FontName.heavy, size: 17.0))
                        .foregroundStyle(Colors.elementBackground)
                }
            }
        }
    }
    
    func setAsSaved() async {
        do {
            try await RecipeCDClient.updateRecipe(recipe, saved: true, in: viewContext)
        } catch {
            // TODO: Handle errors
            print("Error updating recipe to be saved in SaveRecipeView... \(error)")
        }
    }
    
}

extension View {
    
    func saveRecipePopup(recipe: Binding<Recipe?>, didSaveRecipe: @escaping (Recipe) -> Void) -> some View {
        self
            .popover(item: recipe) { unwrappedRecipe in
                // The approach with this one is that the onDismiss is not sent directly to the caller but instead just dismissed and didSaveRecipe still is sent but also with the recipe and the view is dismissed also
                NavigationStack {
                    SaveRecipeView(
                        recipe: unwrappedRecipe,
                        onDismiss: {
                            recipe.wrappedValue = nil
                        },
                        didSaveRecipe: {
                            recipe.wrappedValue = nil
                            didSaveRecipe(unwrappedRecipe)
                        })
                }
            }
    }
    
    func saveRecipePopup(isPresented: Binding<Bool>, recipe: Recipe, didSaveRecipe: @escaping () -> Void) -> some View {
        self
            .popover(isPresented: isPresented) {
                NavigationStack {
                    SaveRecipeView(
                        recipe: recipe,
                        onDismiss: { isPresented.wrappedValue = false },
                        didSaveRecipe: didSaveRecipe)
                }
            }
    }
    
}

#Preview {
    var recipe: Recipe {
        let viewContext = PersistenceController.shared.container.viewContext
        
        var recipe = Recipe(entity: Recipe.entity(), insertInto: viewContext)
        recipe.input = "Drink input"
        recipe.name = "Sparkling Mint Vodka"
        recipe.summary = "A refreshing and minty cocktail with a hint of vodka and a sparkling twist!"
        recipe.imageData = Data(referencing: NSData(base64Encoded: "iVBORw0KGgoAAAANSUhEUgAAAFQAAACcCAYAAADh0IwYAAAACXBIWXMAACE3AAAhNwEzWJ96AAAEAElEQVR4nO2d23HbMBBFL91AnA7iDtJBWkkpLiUlpASkA7kDuILIFWw+FNqU+MAucC0OyXtmNMMH5IHP7JLLhWR3AH4C+AZBoQOQAPxYeR574eUBF6GCw/lh7RnsjJMilIsilEx6MLO09iz2RGdm6LrO1p7IHjCzrk/5P6vOZB+8AUAv9LziRPbCCfgQelpxInvhDChCmShCyShCyZyA/2UTAJVO7TyZWR4KPQP4su6ctouZdcBHygO6jrbw2m8Mheo6Wk/uNxShHHK/oQjlkPsNRSiH3G8oQjnkfuO9bAJUizbwZGYZGAtVLVpBX4MC1ykP6Dpaw8tw51aorqNxrpwpQtvJwx1FaDt5uKMIbScPd7Qu304e7lyVTYBq0Qrea1BAQpsZ1qDAdMprjd7P6+0BXUPbyLcHpoTqTu9nVGZOCVUt6mcUfFNC8+fPY79IaBvp9oBSnsyoDgVUiwb4amZXASihDdwW9cB8HarivsyoqAdU2LeQpw7OCZ0cLMpIaD1p6qBSnsyc0HTPSWyUyZ6HIrSeyQcgXUPJTBb2gIr7ElNFPaCUp7Mk9GXh3NGZfEoCloWq6zRPnjuhlCezJDTdaxIbZHbdTRFax+zlUELJKOXrUMqTUcrfi9lHT0CPnwuMFud6JLSCued4QClPpyRUz/NjFp2UhOp5fsyiE6U8mZLQfI9JbIy8dFJC4+Slk0p5MhJKpiQ03WMSGyMtnVSEkpFQMirs4+Slk4vNEUANkluWGiOAUp6OhJLxCJ39lMQBKXbfPEJz+zx2Q/EmrZQnI6FkPEL1de8PUmmAR6iK+wBKeTISSkZlU4xUGiChZJTyZCSUjFI+RrEmL/ZDAfVEe0q9UEApT0dCyUioH1df2CtUf9TFeXNWhJKRUDIS6sfVxvQKVZPZ6cArVE1mJ0p5MhJKRinvJ3kG6aZERilPRkLJSKif7BnkbTA/AvjbOKFN42kuA06hgLr2XqFKeTISSkZCfbgb7BGh6to7UISSkVAyEuojewdGhLp/6A7J3oESSkYpT0ZCyUioD3eDPSL0yF179xJQRKjWlRwo5clIqI9PSfnDYmbu+4e7Yw8ct2vv7dYDilA6EkpGQsuE/uZKVOhbcPweyJHBUaFHflpyoZQnI6FkJLRM6DIXFXrEBknod9ZNiYxSnoyEkpHQMikyOCo0B8cfDgklo5QnI6FlcmSwhBYwsxwZH10COdy3QSLLH0BQKHC8daWoUKU8GQldJvxPDmuEHmkZJNxdqxGaKt6zVXL0DTVCf1e8Z6v8Cr/DzMIvXKLUdv76XeWmUugjLs3mtX/pz3olAI93EzoQ+4zLhXttAaxXBvDc4iRc2E/Rdd13XKJ2y5wjn7Kb4x8K3rA2wlbxlAAAAABJRU5ErkJggg==")!)
        recipe.recipeID = 0
        
        var mi1 = RecipeMeasuredIngredient(entity: RecipeMeasuredIngredient.entity(), insertInto: viewContext)
        mi1.nameAndAmount = "ingredient and measurement"
        mi1.recipe = recipe
        
        var mi2 = RecipeMeasuredIngredient(entity: RecipeMeasuredIngredient.entity(), insertInto: viewContext)
        mi2.nameAndAmount = "2 1/4 cup another ingredient"
        mi2.recipe = recipe
        
        var rd1 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
        rd1.index = 1
        rd1.string = "First direction"
        rd1.recipe = recipe
        
        var rd2 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
        rd2.index = 2
        rd2.string = "Second direction"
        rd2.recipe = recipe
        
        var rd3 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
        rd3.index = 3
        rd3.string = "Third direction"
        rd3.recipe = recipe
        
        var rd4 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
        rd4.index = 4
        rd4.string = "Fourth direction"
        rd4.recipe = recipe
        
        var rd5 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
        rd5.index = 5
        rd5.string = "Fifth direction"
        rd5.recipe = recipe
        
        var rd6 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
        rd6.index = 6
        rd6.string = "Sixth direction"
        rd6.recipe = recipe
        
        var rd7 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
        rd7.index = 7
        rd7.string = "Seventh direction"
        rd7.recipe = recipe
        
        var rd8 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
        rd8.index = 8
        rd8.string = "Eighth direction"
        rd8.recipe = recipe
        
        // TODO: Test images
        
//        var glassGradientColor1 = GlassGradientColor(entity: GlassGradientColor.entity(), insertInto: viewContext)
//        glassGradientColor1.index = 1
//        glassGradientColor1.hexadecimal = "20B2AA"
//        glassGradientColor1.drink = drink
//        
//        var glassGradientColor2 = GlassGradientColor(entity: GlassGradientColor.entity(), insertInto: viewContext)
//        glassGradientColor2.index = 2
//        glassGradientColor2.hexadecimal = "FFFFFF"
//        glassGradientColor2.drink = drink
        
//        var glassGradientColor3 = GlassGradientColor(entity: GlassGradientColor.entity(), insertInto: viewContext)
//        glassGradientColor3.index = 3
//        glassGradientColor3.hexadecimal = "808080"
//        glassGradientColor3.drink = drink
        
        try! viewContext.save()
        
        return recipe
    }
    
    return SaveRecipeView(
//        recipeGenerator: RecipeGenerator(),
        recipe: recipe,
        onDismiss: {
            
        },
        didSaveRecipe: {
            
        })
    .environmentObject(PremiumUpdater())
    .environmentObject(ProductUpdater())
    .environmentObject(RemainingUpdater())
}


RecipeOfTheDayGenerationSwipeView.swift
//
//  RecipeOfTheDayGenerationSwipeView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/7/24.
//

import SwiftUI

struct RecipeOfTheDayGenerationSwipeView: View {
    
    let recipeOfTheDayGenerationSpec: RecipeOfTheDayContainer.RecipeOfTheDayGenerationSpec
    let dailyRecipes: FetchedResults<Recipe>
    let onDismiss: () -> Void
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @StateObject private var recipeOfTheDayGenerator = RecipeOfTheDayGenerator()
    @StateObject private var recipeSwipeCardsViewModel = RecipeSwipeCardsView.Model(cards: [])
    
    @State private var recipeToOverwriteDailyRecipeWith: Recipe?
    //    @State private var alertShowingOverwriteRecipe: Bool = false
    
    var alertShowingOverwriteRecipe: Binding<Bool> {
        Binding(
            get: {
                recipeToOverwriteDailyRecipeWith != nil
            },
            set: { value in
                if !value {
                    recipeToOverwriteDailyRecipeWith = nil
                }
            })
    }
    
    var body: some View {
        RecipeGenerationSwipeView(
            recipeGenerator: recipeOfTheDayGenerator,
            recipeSwipeCardsViewModel: recipeSwipeCardsViewModel,
            recipeGenerationSpec: recipeOfTheDayGenerationSpec.recipeGenerationSpec,
            onSwipe: { recipe, direction in
                HapticHelper.doLightHaptic()
                
                if direction == .right {
                    saveOrLoadSaveAlert(recipe: recipe)
                }
            },
            onDetailViewSave: saveOrLoadSaveAlert,
            onUndo: { recipe, previousSwipeDirection in
                // There should be nothing here becuase it dismisses on swipe right and there is no CoreData modification to be done 
            },
            onClose: onDismiss)
        .alert("Save \(recipeOfTheDayGenerationSpec.recipeGenerationTimeFrame.displayString.uppercased())?", isPresented: alertShowingOverwriteRecipe, actions: {
            Button("Save") {
                if let recipeToOverwriteDailyRecipeWith {
                    saveRecipe(recipe: recipeToOverwriteDailyRecipeWith)
                }
                onDismiss()
            }
            Button("Cancel", role: .cancel) {
                withAnimation {
                    let _ = recipeSwipeCardsViewModel.undo()
                }
            }
        }) {
            Text("This will overwrite your current \(recipeOfTheDayGenerationSpec.recipeGenerationTimeFrame.displayString.lowercased())")
        }
    }
    
    func saveOrLoadSaveAlert(recipe: Recipe) {
        // Right now it is always overwriting a recipe so always show the alert
        recipeToOverwriteDailyRecipeWith = recipe
    }
    
    func saveRecipe(recipe: Recipe) {
        Task {
            // Delete or save and update current recipe of the day for time frame
            let existingRecipesForTimeFrame = dailyRecipes.filter({ $0.dailyRecipe_timeFrameID == recipeOfTheDayGenerationSpec.recipeGenerationTimeFrame.rawValue })
            for existingRecipeForTimeFrame in existingRecipesForTimeFrame {
                await recipeOfTheDayGenerator.deleteOrSaveAndUpdateRecipe(existingRecipeForTimeFrame, in: viewContext)
            }
            
            // Set to recipe of the day for the time frame
            do {
                try await RecipeCDClient.updateRecipe(recipe, dailyRecipe_isDailyRecipe: true, in: viewContext)
            } catch {
                // TODO: Handle Errors
                print("Error updating recipe dailyRecipe_isDailyRecipe in RecipeOfTheDayContainer, continuing... \(error)")
            }
            do {
                try await RecipeCDClient.updateRecipe(recipe, dailyRecipe_timeFrameID: recipeOfTheDayGenerationSpec.recipeGenerationTimeFrame.rawValue, in: viewContext)
            } catch {
                // TODO: Handle Errors
                print("Error updating recipe dailyRecipe_timeFrameID in RecipeOfTheDayContainer, continuing... \(error)")
            }
        }
    }
}

//#Preview {
//    RecipeOfTheDayGenerationSwipeView()
//}


RecipeSwipeCardRecipeDisplayView.swift
//
//  RecipeSwipeCardRecipeDisplayView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/7/24.
//

import SwiftUI

struct RecipeSwipeCardRecipeDisplayView: View {
    
//    @ObservedObject var recipe: Recipe
    let imageURL: URL?
    let name: String?
    let summary: String?
    let size: CGSize
    
    var body: some View {
//        if let uiImage {
            if let imageURL {
                AsyncImage(url: imageURL) { phase in
                    switch phase {
                    case .empty:
                        ProgressView()
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(width: size.width, height: size.width)
                            .aspectRatio(contentMode: .fill)
                    case .failure(let error):
                        ProgressView()
                    }
                }
//            }
//            Image(uiImage: uiImage)
//                .resizable()
//                .aspectRatio(contentMode: .fill)
//                .frame(width: size.width, height: size.width)
//                .aspectRatio(contentMode: .fill)
        } else {
            VStack {
                ProgressView()
            }
            .frame(width: size.width, height: size.width)
            .background(Colors.background.opacity(0.6))
        }
        
        VStack(alignment: .leading) {
            Text(name ?? "")
                .font(.heavy, 17.0)
//            .padding(.horizontal)
            
            Text(summary ?? "")
                .font(.body, 14.0)
            //            .padding(.horizontal)
        }
        .padding()
//        .frame(width: size.width)
        .frame(maxWidth: .infinity)
        .background(Colors.foreground)
    }
}

#Preview {
    
    RecipeSwipeCardRecipeDisplayView(
//        recipe: try! CDClient.mainManagedObjectContext.fetch(Recipe.fetchRequest()).first!,
        imageURL: nil,
        name: "name",
        summary: "summary",
        size: CGSize(width: 250.0, height: 250.0)
    )
    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
    
}


RecipeGenerationSwipeView.swift
//
//  RecipeOfTheDayGenerationSwipeView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/7/24.
//

import SwiftUI

struct RecipeGenerationSwipeView: View {
    
    @ObservedObject var recipeGenerator: RecipeGenerator
    @ObservedObject var recipeSwipeCardsViewModel: RecipeSwipeCardsView.Model
    @ObservedObject var recipeGenerationSpec: RecipeGenerationSpec
    let onSwipe: (_ recipe: Recipe, _ swipeDirection: RecipeSwipeCardView.SwipeDirection) -> Void
    let onDetailViewSave: (Recipe) -> Void
    let onUndo: (_ recipe: Recipe, _ previousSwipeDirection: RecipeSwipeCardView.SwipeDirection) -> Void
    let onClose: () -> Void
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @EnvironmentObject private var premiumUpdater: PremiumUpdater
    
    @State private var isShowingAllPantryItems: Bool = false
    @State private var isShowingEntry: Bool = false
    
    private var maxAutoGenerate: Int {
        (premiumUpdater.isPremium ? Constants.Generation.premiumAutomaticRecipeGenerationLimit : Constants.Generation.freeAutomaticRecipeGenerationLimit)
        +
        2
    }
    
    private var allPantryItems: [PantryItem]? {
        do {
            return try viewContext.performAndWait { try viewContext.fetch(PantryItem.fetchRequest()) }
        } catch {
            // TODO: Handle Errors
            print("Error fetching pantry items in RecipeGenerationSwipeView... \(error)")
            return nil
        }
    }
    
    private var parsedInput: String {
        // TODO: Should I add anything else to the input string if selectedPantryItems is not empty?
        // Create parsedInput starting with input
        var parsedInput = recipeGenerationSpec.input
        
        // If selectedPantryItems is not empty add generationAdditionalOptions additional string and selectedPantryItems separated by commas
        if !recipeGenerationSpec.pantryItems.isEmpty {
            parsedInput += recipeGenerationSpec.generationAdditionalOptions == .boostCreativity ? "
Ingredients: " : (recipeGenerationSpec.generationAdditionalOptions == .useOnlyGivenIngredients ? "
Select From: " : "
Choose from Ingredients: ")
            parsedInput += "

"
        }
        
        // If pantryItems is empty or generationAdditionalOptions is useAllGivenIngredients add all pantry items, otherwise add pantry items
        if recipeGenerationSpec.pantryItems.isEmpty {
            do {
                if let allPantryItems,
                   !allPantryItems.isEmpty {
                    parsedInput += allPantryItems.shuffled().compactMap({$0.name}).joined(separator: ", ")
                } else {
                    // Append demo text TODO: Make sure this cannot be shown unless user enters ingredients, or handle in a better way
                    parsedInput += "<No ingredients, the user is demoing the recipe creation ability.> Imagine there are common ingredients included here."
                }
            } catch {
                // TODO: Handle Errors
                print("Error getting all pantry items for parsedInput in RecipeGenerationSwipeView... \(error)")
            }
        } else {
            parsedInput += recipeGenerationSpec.pantryItems.shuffled().compactMap({$0.name}).joined(separator: ", ") // TODO: Should there be anything else if the name cannot be unwrapped? Since that is the only attribute besides category it's most likely always going to be filled, right, or at least it's expected behaviour to be filled, so it's probably fine to just compactmap filtering with just the name
        }
        
        return parsedInput
    }
    
    private var parsedInputDifferentThanNewRecipes: String {
        let allCards = recipeSwipeCardsViewModel.swipedCards + recipeSwipeCardsViewModel.unswipedCards
        return parsedInput + (allCards.count > 0 ? "
DIFFERENT THAN RECIPE: " + allCards.compactMap({$0.name != nil && $0.summary != nil ? "\($0.name!), \($0.summary!)" : nil}).joined(separator: "
AND DIFFERENT THAN: ") : "")
    }
    
    private var parsedModifiers: String? {
        // Right now if selectedSuggestions is empty nil, otherwise just the selectedSuggestions separated by commas
        recipeGenerationSpec.suggestions.isEmpty ? nil : recipeGenerationSpec.suggestions.joined(separator: ", ")
    }
    
    private var isLoadingRecipe: Bool {
        recipeGenerator.isCreating || recipeGenerator.isGeneratingBingImage
    }
    
    var body: some View {
        VStack {
            RecipeSwipeView(
//                recipeGenerator: recipeGenerator,
                recipeSwipeCardsViewModel: recipeSwipeCardsViewModel,
                isLoading: isLoadingRecipe,
                onSwipe: onSwipe,
                onDetailViewSave: onDetailViewSave,
                onClose: onClose)
            
            Text("swipe right to save")
                .font(.body, 14)
                .foregroundStyle(Colors.foregroundText)
                .opacity(0.6)
            
            HStack {
                Button(action: {
                    withAnimation {
                        if let lastSwipedCard = recipeSwipeCardsViewModel.undo() {
                            if let recipe = lastSwipedCard.recipe { // TODO: Research and analyze use cases to see if this is a good way to handle this
                                onUndo(recipe, lastSwipedCard.swipeDirection)
                            }
                        }
                    }
                }) {
                    Image(systemName: "arrow.uturn.backward")
                        .padding()
                        .foregroundStyle(Color(.systemBlue))
                        .background(Colors.foreground)
                        .clipShape(Circle())
                        .font(.body, 24.0)
                }
                .disabled(recipeSwipeCardsViewModel.swipedCards.isEmpty)
                .opacity(recipeSwipeCardsViewModel.swipedCards.isEmpty ? 0.2 : 1.0)
                Button(action: {
                    if let topCard = recipeSwipeCardsViewModel.unswipedCards.reversed().first,
                       let recipe = topCard.recipe {
                        recipeSwipeCardsViewModel.updateTopCardSwipeDirection(.left)
                        recipeSwipeCardsViewModel.removeTopCard()
                        onSwipe(recipe, .left)
                    }
                }) {
                    Image(systemName: "xmark")
                        .padding()
                        .foregroundStyle(Color(.systemRed))
                        .background(Colors.foreground)
                        .clipShape(Circle())
                        .font(.body, 40.0)
                }
                
                Button(action: {
                    if let topCard = recipeSwipeCardsViewModel.unswipedCards.reversed().first,
                       let recipe = topCard.recipe {
                        recipeSwipeCardsViewModel.updateTopCardSwipeDirection(.right)
                        recipeSwipeCardsViewModel.removeTopCard()
                        onSwipe(recipe, .right)
                    }
                }) {
                    Image(systemName: "checkmark")
                        .padding()
                        .foregroundStyle(Color(.systemGreen))
                        .background(Colors.foreground)
                        .clipShape(Circle())
                        .font(.body, 40.0)
                }
                Button(action: {
                    isShowingAllPantryItems = true
                }) {
                    Image(systemName: "list.bullet")
                        .padding()
                        .foregroundStyle(Color(.systemYellow))
                        .background(Colors.foreground)
                        .clipShape(Circle())
                        .font(.body, 24.0)
                }
            }
            
            Button(action: {
                isShowingEntry = true
            }) {
                // TODO: Entry Mini View
                HStack {
                    Spacer()
                    
                    VStack {
                        if !recipeGenerationSpec.pantryItems.isEmpty {
                            ScrollView(.horizontal, showsIndicators: false) {
                                HStack {
                                    ForEach(recipeGenerationSpec.pantryItems) { pantryItem in
                                        if let name = pantryItem.name {
                                            Text(name)
                                                .font(.custom(Constants.FontName.body, size: 12.0))
                                                .padding(.horizontal, 4)
                                                .padding(.vertical, 2)
                                                .background(Colors.background)
                                                .clipShape(Capsule())
                                        }
                                    }
                                }
                            }
                        } else {
                            if allPantryItems == nil || allPantryItems!.isEmpty {
                                Text("Using Demo Ingredients")
                                    .font(.heavy, 12)
                            } else {
                                Text("Using all ingredients")
                                    .font(.custom(Constants.FontName.heavy, size: 12.0))
                            }
                        }
                        
                        Group {
                            if recipeGenerationSpec.input.isEmpty {
                                Text("*Tap to Add Prompt*")
                                    .opacity(0.6)
                            } else {
                                Text(recipeGenerationSpec.input)
                            }
                        }
                        .font(.custom(Constants.FontName.body, size: 14.0))
                        
                        if recipeGenerationSpec.suggestions.count > 0 {
                            Text(recipeGenerationSpec.suggestions.joined(separator: ", "))
                                .font(.custom(Constants.FontName.heavy, size: 10.0))
                        }
                    }
                    
                    Spacer()
                    
                    Image(systemName: "chevron.up")
                }
                .padding()
                .foregroundStyle(Colors.foregroundText)
                .frame(maxWidth: .infinity)
                .background(Colors.foreground)
                .clipShape(RoundedRectangle(cornerRadius: 14.0))
                .padding(.horizontal)
            }
        }
        .background(Colors.background)
        .sheet(isPresented: $isShowingEntry) {
            NavigationStack {
                VStack {
                    EntryView(
                        generateMessage: "Tap a suggestion or ingredients to create.",
                        selectedPantryItems: $recipeGenerationSpec.pantryItems,
                        generationAdditionalOptions: $recipeGenerationSpec.generationAdditionalOptions,
                        selectedSuggestions: $recipeGenerationSpec.suggestions,
                        showsTitle: false,
                        onDismiss: { isShowingEntry = false })
                    SheetView(
                        recipeGenerator: RecipeGenerator(),
                        selectedPantryItems: $recipeGenerationSpec.pantryItems,
                        inputFieldText: $recipeGenerationSpec.input,
                        isShowingEntryView: $isShowingEntry,
                        selectedSuggestions: $recipeGenerationSpec.suggestions,
                        showsCraftText: true,
                        textFieldPlaceholders: ["Enter Prompt..."],
                        onGenerate: {
                            // Reset swipe cards view model to clear recipe models
                            recipeSwipeCardsViewModel.reset()
                            isShowingEntry = false
                        })
                    .padding(.horizontal)
                }
                .background(Colors.background)
            }
        }
        .fullScreenCover(isPresented: $isShowingAllPantryItems) {
            NavigationStack {
                PantryView(
                    selectedItems: $recipeGenerationSpec.pantryItems,
                    showsEditButton: true,
                    onDismiss: {
                        isShowingAllPantryItems = false
                    })
                .background(Colors.background)
            }
        }
        .onReceive(recipeSwipeCardsViewModel.$unswipedCards) { newValue in
            if newValue.count < maxAutoGenerate {
                // Request generation
                Task {
                    // Generate
                    do {
                        try await generateNext()
                    } catch {
                        // TODO: Handle errors
                        print("Could not generate next recipe in RecipeOfTheDayGenerationSwipeView... \(error)")
                    }
                }
            }
        }
    }
    
    func generateNext() async throws {
        // If recipeID can be unwrapped from creating a recipe with recipeGenerator, get recipe ingredients preview, update remaining, and generateNext
        let recipe = try await recipeGenerator.create(
            ingredients: parsedInputDifferentThanNewRecipes,
            modifiers: parsedModifiers,
            expandIngredientsMagnitude: recipeGenerationSpec.generationAdditionalOptions.rawValue, // TODO: This should also be some string value on the server instead of expandIngredientsMagnitude as the advanced options could have more functionality this way :)
            in: viewContext)
        
//        // Set isLoadingRecipe to false and generate next if it is auto generating
//        if /*recipeGenerator.createdRecipes.count*/ recipeSwipeCardsViewModel.unswipedCards.count < maxAutoGenerate {
//            try await generateNext()
//        }
        
        // Generate bing image
        try await recipeGenerator.generateBingImage(
            recipe: recipe,
            in: viewContext)
        
        // Add to unswiped cards
        withAnimation {
            self.recipeSwipeCardsViewModel.unswipedCards.append(RecipeSwipeCardView.Model(
                recipe: recipe,
                imageURL: recipe.imageAppGroupLocation == nil ? nil : AppGroupLoader(appGroupIdentifier: Constants.Additional.appGroupID).fileURL(for: recipe.imageAppGroupLocation!),
                name: recipe.name,
                summary: recipe.summary))
        }
        
//        if let imageAppGroupLocation = recipe.imageAppGroupLocation {
//            recipeSwipeCardsViewModel.unswipedCards[.imageURL = AppGroupLoader(appGroupIdentifier: Constants.Additional.appGroupID).fileURL(for: imageAppGroupLocation)//recipeSwipeCardsViewModel.unswipedCards[i].recipe?.imageFromAppData
//        }
        
        // Update model with image TODO: Check this
//        for i in 0..<recipeSwipeCardsViewModel.unswipedCards.count {
//            if recipeSwipeCardsViewModel.unswipedCards[i].imageURL == nil {
//                if let recipe = recipeSwipeCardsViewModel.unswipedCards[i].recipe,
//                   let imageAppGroupLocation = recipe.imageAppGroupLocation {
//                    recipeSwipeCardsViewModel.unswipedCards[i].imageURL = AppGroupLoader(appGroupIdentifier: Constants.Additional.appGroupID).fileURL(for: imageAppGroupLocation)//recipeSwipeCardsViewModel.unswipedCards[i].recipe?.imageFromAppData
//                }
//            }
//        }
    }
    
}

#Preview {
    RecipeGenerationSwipeView(
        recipeGenerator: RecipeGenerator(),
        recipeSwipeCardsViewModel: RecipeSwipeCardsView.Model(cards: []),
        recipeGenerationSpec: RecipeGenerationSpec(
            pantryItems: [],
            suggestions: [],
            input: "",
            generationAdditionalOptions: .normal),
        onSwipe: { recipe, direction in
            
        },
        onDetailViewSave: { recipe in
            
        },
        onUndo: { recipe, previousSwipeDirection in
            
        },
        onClose: {
            
        })
    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
    .environmentObject(PremiumUpdater())
    .environmentObject(ProductUpdater())
    .environmentObject(RemainingUpdater())
    .environmentObject(ScreenIdleTimerUpdater())
}


RecipeSwipableCardView.swift
//
//  RecipeSwipableCardView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/12/24.
//

import SwiftUI

struct RecipeSwipableCardView: View {
    
    let model: RecipeSwipeCardView.Model
    let size: CGSize
//    let isTopCard: Bool
//    let isSecondCard: Bool
    let onTap: () -> Void
    let onSwipe: (_ swipeDirection: RecipeSwipeCardView.SwipeDirection) -> Void
    let onSwipeComplete: () -> Void
    
    private let swipeThreshold: CGFloat = 100.0
    private let rotationFactor: Double = 35.0
    
    @State private var dragState = CGSize.zero
    @State private var cardRotation: Double = 0
    
    var body: some View {
        RecipeSwipeCardView(
            model: model,
            size: size)
//            isTopCard: isTopCard,
//            isSecondCard: isSecondCard)
        .shadow(color: getShadowColor(), radius: 10, x: 0, y: 3)
        .offset(x: dragState.width)
        .rotationEffect(.degrees(Double(dragState.width) / rotationFactor))
        .onTapGesture {
            onTap()
        }
        .gesture(
            DragGesture()
                .onChanged { gesture in
                    self.dragState = gesture.translation
                    self.cardRotation = Double(gesture.translation.width) / rotationFactor
                }
                .onEnded { _ in
                    if abs(self.dragState.width) > swipeThreshold {
                        let swipeDirection: RecipeSwipeCardView.SwipeDirection = self.dragState.width > 0 ? .right : .left
//                        model.updateTopCardSwipeDirection(swipeDirection) Moved to parent
                        
                        // Call onSwipe
                        onSwipe(swipeDirection)
                        
                        withAnimation(.easeOut(duration: 0.5)) {
                            self.dragState.width = self.dragState.width > 0 ? 1000 : -1000
                        }
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
//                            self.model.removeTopCard() Moved to parent
                            self.dragState = .zero
                            onSwipeComplete()
                        }
                    } else {
                        withAnimation(.spring()) {
                            self.dragState = .zero
                            self.cardRotation = 0
                        }
                    }
                }
        )
        .animation(.easeInOut, value: dragState)
    }
    
    private func getShadowColor() -> Color {
        if dragState.width > 0 {
            return Color.green.opacity(0.5)
        } else if dragState.width < 0 {
            return Color.red.opacity(0.5)
        } else {
            return Color.gray.opacity(0.2)
        }
    }
    
}

//#Preview {
//    
//    RecipeSwipableCardView()
//
//}


RecipeSwipeCardView.swift
//
//  RecipeSwipeCardView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/7/24.
//

import SwiftUI

struct RecipeSwipeCardView: View {
    
    class Model: ObservableObject, Identifiable {
        
        let id = UUID()
        
        let recipe: Recipe?
//        @Published var uiImage: UIImage?
        @Published var imageURL: URL?
        var name: String?
        var summary: String?
        var swipeDirection: RecipeSwipeCardView.SwipeDirection = .none
        
        init(recipe: Recipe?, imageURL: URL?, name: String?, summary: String?) {
            self.recipe = recipe
            self.imageURL = imageURL
            self.name = name
            self.summary = summary
        }
        
    }
    
    enum SwipeDirection {
        case left, right, none
    }
    
    @ObservedObject var model: Model
    var size: CGSize
//    var dragOffset: CGSize
//    var isTopCard: Bool
//    var isSecondCard: Bool
    
    var body: some View {
        VStack(alignment: .leading) {
//            if let recipe = model.recipe {
                RecipeSwipeCardRecipeDisplayView(
                    imageURL: model.imageURL,
//                    recipe: recipe,
//                    cachedImage: model.cachedImage,
//                    uiImage: model.uiImage,
                    name: model.name,
                    summary: model.summary,
                    size: size)
//            } else {
//                Text("Loading")
//                ProgressView()
//            }
        }
        .background(Colors.foreground)
        .cornerRadius(15)
    }
    
}

#Preview {
    
    let recipe = try! CDClient.mainManagedObjectContext.fetch(Recipe.fetchRequest()).first!
    
    return GeometryReader { geometry in
        RecipeSwipeCardView(
            model: RecipeSwipeCardView.Model(
                recipe: recipe,
                imageURL: AppGroupLoader(appGroupIdentifier: Constants.Additional.appGroupID).fileURL(for: recipe.imageAppGroupLocation!),
                name: recipe.name,
                summary: recipe.summary),
            size: geometry.size
        )
    }
    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
    
}


RecipeGenerationSwipeContainer.swift
//
//  RecipeGenerationSwipeContainer.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/11/24.
//

import SwiftUI

struct RecipeGenerationSwipeContainer: View {
    
    @ObservedObject var recipeGenerationSpec: RecipeGenerationSpec
    let onSwipe: (_ recipe: Recipe, _ swipeDirection: RecipeSwipeCardView.SwipeDirection) -> Void
    let onDetailViewSave: (Recipe) -> Void
    let onUndo: (_ recipe: Recipe, _ previousSwipeDirection: RecipeSwipeCardView.SwipeDirection) -> Void
    let onClose: () -> Void
    
    @StateObject var recipeGenerator: RecipeGenerator = RecipeGenerator()
    
    @StateObject var recipeSwipeCardsViewModel: RecipeSwipeCardsView.Model = RecipeSwipeCardsView.Model(cards: [])
    
    var body: some View {
        RecipeGenerationSwipeView(
            recipeGenerator: recipeGenerator,
            recipeSwipeCardsViewModel: recipeSwipeCardsViewModel,
            recipeGenerationSpec: recipeGenerationSpec,
            onSwipe: onSwipe,
            onDetailViewSave: onDetailViewSave,
            onUndo: onUndo,
            onClose: onClose)
    }
}

//#Preview {
//    
//    RecipeGenerationSwipeContainer()
//    
//}


RecipeSwipeCardsView.swift
//
//  RecipeSwipeCardsView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/7/24.
//
// https://www.reddit.com/r/SwiftUI/comments/1fux4ai/tinderlike_swipeable_cards_in_swiftui_tutorial/?rdt=48146
// https://medium.com/@jaredcassoutt/creating-tinder-like-swipeable-cards-in-swiftui-193fab1427b8

import SwiftUI

struct RecipeSwipeCardsView: View {
    
//    let recipes: [Recipe]
//    
//    var body: some View {
//        VStack {
//            ZStack {
//                ForEach(recipes) { recipe in
//                    RecipeSwipeCardView(recipe: recipe)
//                        .background(Colors.background)
//                        .clipShape(RoundedRectangle(cornerRadius: 14.0))
//                        .padding()
//                }
//            }
//        }
//    }
    
    class Model: ObservableObject {
        private var originalCards: [RecipeSwipeCardView.Model]
        @Published var unswipedCards: [RecipeSwipeCardView.Model]
        @Published var swipedCards: [RecipeSwipeCardView.Model]
        
        init(cards: [RecipeSwipeCardView.Model]) {
            self.originalCards = cards
            self.unswipedCards = cards
            self.swipedCards = []
        }
        
        func removeTopCard() {
            if !unswipedCards.isEmpty {
                guard let card = unswipedCards.first else { return }
                unswipedCards.removeFirst()
                swipedCards.append(card)
            }
        }
        
        func updateTopCardSwipeDirection(_ direction: RecipeSwipeCardView.SwipeDirection) {
            if !unswipedCards.isEmpty {
                unswipedCards[0].swipeDirection = direction
            }
        }
        
        func undo() -> RecipeSwipeCardView.Model? {
            if let lastSwipedCard = swipedCards.popLast() {
                unswipedCards.insert(lastSwipedCard, at: 0)
                return lastSwipedCard
            }
            
            return nil
        }
        
        func reset() {
            unswipedCards = originalCards
            swipedCards = []
        }
    }
    
    @ObservedObject var model: Model
    let onTap: (_ card: RecipeSwipeCardView.Model) -> Void
    let onSwipe: (_ card: RecipeSwipeCardView.Model, _ swipeDirection: RecipeSwipeCardView.SwipeDirection) -> Void
    let onSwipeComplete: () -> Void
//    let onUndo: (_ card: RecipeSwipeCardView.Model) -> Void
    let onClose: () -> Void
//    let action: (Model) -> Void
    
    var body: some View {
//        let _ = Self._printChanges()
        VStack {
            GeometryReader { geometry in
                if model.unswipedCards.isEmpty {
                    emptyCardsView
                        .frame(width: geometry.size.width, height: geometry.size.height)
                } else if model.unswipedCards.isEmpty {
                    swipingCompletionView
                        .frame(width: geometry.size.width, height: geometry.size.height)
                } else {
                    ZStack {
                        Colors.background.ignoresSafeArea()
                        
                        ForEach(model.unswipedCards.reversed()) { card in
//                        ForEach(Array(model.unswipedCards.enumerated()).reversed(), id: \.offset) { index, card in
//                            let isTop = card === model.unswipedCards.first
//                            let isSecond = card === model.unswipedCards.dropFirst().first
                            RecipeSwipableCardView(
                                model: card,
                                size: geometry.size,
                                onTap: {
                                    // Call onTap closure with card
                                    onTap(card)
                                },
                                onSwipe: { swipeDirection in
//                                    // Update top card swipe direction TODO: This can be handled better
//                                    model.updateTopCardSwipeDirection(swipeDirection)
                                    // Update card swipe direction
                                    card.swipeDirection = swipeDirection
                                    
                                    // Call onSwipe closure with card and swipe direction
                                    onSwipe(card, swipeDirection)
                                },
                                onSwipeComplete: {
                                    // Remove top card TODO: This can be handled better
                                    model.removeTopCard()
                                    
                                    // Call onSwipeComplete closure
                                    onSwipeComplete()
                                })
//                            .rotationEffect(.degrees(index == 0 ? 0 : (index == 1 ? 5 : -5)))
//                            .offset(y: 10 * CGFloat(model.unswipedCards.count - index))
                        }
                    }
//                    .padding()
                }
            }
            .padding()
        }
    }
    
    var emptyCardsView: some View {
        VStack {
            Text("No Cards")
                .font(.title)
                .padding(.bottom, 20)
                .foregroundStyle(.gray)
        }
    }
    
    var swipingCompletionView: some View {
        VStack {
            Text("Finished Swiping")
                .font(.title)
                .padding(.bottom, 20)
            
            // TODO: Make this button more customizable and have it call onFinishAction
            Button(action: {
                onClose()
            }) {
                Text("Close")
                    .font(.headline)
                    .frame(width: 200, height: 50)
                    .background(Color.accentColor)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
        }
    }
}

#Preview {
    
//    @Namespace var namespace
    
    let cards = (try! CDClient.mainManagedObjectContext.fetch(Recipe.fetchRequest())).map({ RecipeSwipeCardView.Model(
        recipe: $0,
        imageURL: AppGroupLoader(appGroupIdentifier: Constants.Additional.appGroupID).fileURL(for: $0.imageAppGroupLocation!),
        name: $0.name,
        summary: $0.summary
    ) })
    
    return RecipeSwipeCardsView(
        model: RecipeSwipeCardsView.Model(
            cards: cards),
        onTap: { card in
            
        },
        onSwipe: { card, swipeDirection in
            
        },
        onSwipeComplete: {
            
        },
//        onUndo: { card in
//            
//        },
        onClose: {
            
        })
        .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
    
}


ConfigurableRecipeSwipeCardsView.swift
////
////  ConfigurableRecipeSwipeCardsView.swift
////  ChefApp-SwiftUI
////
////  Created by Alex Coundouriotis on 12/11/24.
////
//
//import SwiftUI
//
//struct ConfigurableRecipeSwipeCardsView: View {
//    
//    @ObservedObject private var model: RecipeSwipeCardsView.Model
//    let onTap: (_ card: RecipeSwipeCardView.Model) -> Void
//    let onSwipe: (_ card: RecipeSwipeCardView.Model, _ swipeDirection: RecipeSwipeCardView.SwipeDirection) -> Void
//    let onSwipeComplete: () -> Void
////    let onUndo: (_ card: RecipeSwipeCardView.Model) -> Void
//    let onClose: () -> Void
//    
//    var body: some View {
//        RecipeSwipeCardsView(
//            model: model,
//            onTap: onTap,
//            onSwipe: onSwipe,
//            onSwipeComplete: onSwipeComplete,
////            onUndo: onUndo,
//            onClose: onClose)
//    }
//}
//
//#Preview {
//    ConfigurableRecipeSwipeCardsView()
//}


RecipeSwipeView.swift
//
//  RecipeSwipeView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/7/24.
//

import SwiftUI

struct RecipeSwipeView: View {
    
//    let recipeSwipeCardsViewModel: RecipeSwipeCardsView.Model
//    @ObservedObject var recipeGenerator: RecipeGenerator
    @ObservedObject var recipeSwipeCardsViewModel: RecipeSwipeCardsView.Model// = RecipeSwipeCardsView.Model(cards: [])
    let isLoading: Bool
    let onSwipe: (_ recipe: Recipe, _ swipeDirection: RecipeSwipeCardView.SwipeDirection) -> Void
    let onDetailViewSave: (Recipe) -> Void
//    let onUndo: (_ recipe: Recipe, _ previousSwipeDirection: RecipeSwipeCardView.SwipeDirection) -> Void
    let onClose: () -> Void
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @EnvironmentObject private var premiumUpdater: PremiumUpdater
    
//    @Namespace private var namespace
    
    
    @State private var presentingRecipe: Recipe?
    
    @State private var isShowingUltraView: Bool = false
    
    @State private var swipedCardsIterator: Int = 0 // This is for the tap animation
    
//    var imageAnimationID: String { "recipeImage\(swipedCardsIterator)" }
//    var nameAnimationID: String { "recipeName\(swipedCardsIterator)" }
//    var summaryAnimationID: String { "recipeSummary\(swipedCardsIterator)" }
    
//    private var isLoading: Bool {
//        recipeGenerator.isCreating
//    }
    
    var body: some View {
        Group {
            if !(recipeSwipeCardsViewModel.unswipedCards.isEmpty && isLoading) {
                RecipeSwipeCardsView(
                    model: recipeSwipeCardsViewModel,
                    onTap: { card in
                        withAnimation {
                            self.presentingRecipe = card.recipe
                        }
                    },
                    onSwipe: { card, direction in
                        // Call onSwipe if recipe can be unwrapped
                        if let recipe = card.recipe {
                            onSwipe(recipe, direction)
                        }
                    },
                    onSwipeComplete: {
                        // Increment swipedCardsIterator
                        DispatchQueue.main.async {
                            self.swipedCardsIterator += 1
                        }
                    },
                    onClose: onClose)
            } else {
                VStack {
                    VStack {
                        Text("Loading Recipes")
                            .font(.heavy, 20.0)
                        ProgressView()
                        
                        if !premiumUpdater.isPremium {
                            Text("Upgrade for Faster Queue")
                                .font(.heavy, 14.0)
                            Button(action: { isShowingUltraView = true }) {
                                Text("Upgrade")
                                    .appButtonStyle()
                            }
                        }
                    }
                    .frame(maxHeight: .infinity)
                }
            }
        }
        .frame(maxWidth: .infinity)
        .background(Colors.background)
        .ultraViewPopover(isPresented: $isShowingUltraView)
        .saveRecipePopup(
            recipe: $presentingRecipe,
            didSaveRecipe: { recipe in
                onDetailViewSave(recipe)
                recipeSwipeCardsViewModel.removeTopCard()
            })
    }
    
}

#Preview {
    
    let cards = (try! CDClient.mainManagedObjectContext.fetch(Recipe.fetchRequest())).map({ RecipeSwipeCardView.Model(
        recipe: $0,
        imageURL: AppGroupLoader(appGroupIdentifier: Constants.Additional.appGroupID).fileURL(for: $0.imageAppGroupLocation!),
        name: $0.name,
        summary: $0.summary
    ) })
    
    @State var recipeGenerator = RecipeGenerator()
    
    return RecipeSwipeView(
//        recipeSwipeCardsViewModel: RecipeSwipeCardsView.Model(cards: cards),
//        recipeGenerator: recipeGenerator,
        recipeSwipeCardsViewModel: RecipeSwipeCardsView.Model(cards: cards),
        isLoading: false,
        onSwipe: { recipe, swipeDirection in
            
        },
        onDetailViewSave: { recipe in
            
        },
//        onUndo: { recipe, previousSwipeDirection in
//            
//        },
        onClose: {
            
        })
    .task {
        try! await recipeGenerator.create(ingredients: "", modifiers: "", expandIngredientsMagnitude: 0, in: CDClient.mainManagedObjectContext)
        try! await recipeGenerator.create(ingredients: "", modifiers: "", expandIngredientsMagnitude: 0, in: CDClient.mainManagedObjectContext)
        try! await recipeGenerator.create(ingredients: "", modifiers: "", expandIngredientsMagnitude: 0, in: CDClient.mainManagedObjectContext)
        try! await recipeGenerator.create(ingredients: "", modifiers: "", expandIngredientsMagnitude: 0, in: CDClient.mainManagedObjectContext)
        try! await recipeGenerator.create(ingredients: "", modifiers: "", expandIngredientsMagnitude: 0, in: CDClient.mainManagedObjectContext)
    }
    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
    .environmentObject(PremiumUpdater())
    .environmentObject(ProductUpdater())
    .environmentObject(RemainingUpdater())
    .environmentObject(ScreenIdleTimerUpdater())
    
}


RecipeSaveGenerationSwipeContainer.swift
//
//  RecipeSaveGenerationSwipeContainer.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/12/24.
//

import SwiftUI

struct RecipeSaveGenerationSwipeContainer: View {
    
    let recipeGenerationSpec: RecipeGenerationSpec
    let onClose: () -> Void
    
    @Environment(\.requestReview) private var requestReview
    @Environment(\.managedObjectContext) private var viewContext
    
    @EnvironmentObject private var constantsUpdater: ConstantsUpdater
    @EnvironmentObject private var premiumUpdater: PremiumUpdater
    
    @StateObject private var adOrReviewCoordinator = AdOrReviewCoordinator()
    
    var body: some View {
        RecipeGenerationSwipeContainer(
//                    recipeGenerator: recipeGenerator,
            recipeGenerationSpec: recipeGenerationSpec,
            onSwipe: { recipe, swipeDirection in
                if swipeDirection == .right {
                    // Save to Recipes
                    Task {
                        do {
                            try await RecipeCDClient.updateRecipe(recipe, saved: true, in: viewContext)
                        } catch {
                            // TODO: Handle Errors
                            print("Error updating recipe in MainView... \(error)")
                        }
                    }
                    
                    // Show ad or review if premium
                    Task {
                        await adOrReviewCoordinator.showWithCooldown(isPremium: premiumUpdater.isPremium)
                    }
                }
            },
            onDetailViewSave: { recipe in
                // Save to Recipes
                Task {
                    do {
                        try await RecipeCDClient.updateRecipe(recipe, saved: true, in: viewContext)
                    } catch {
                        // TODO: Handle Errors
                        print("Error updating recipe in MainView... \(error)")
                    }
                }
                
                // Show ad or review if premium
                Task {
                    await adOrReviewCoordinator.showWithCooldown(isPremium: premiumUpdater.isPremium)
                }
            },
            onUndo: { recipe, previousSwipeDirection in
                if previousSwipeDirection == .right {
                    // Remove from saved if saved
                    Task {
                        do {
                            try await RecipeCDClient.updateRecipe(recipe, saved: false, in: viewContext)
                        } catch {
                            // TODO: Handle Errors
                            print("Error updating recipe in MainnView... \(error)")
                        }
                    }
                }
            },
            onClose: onClose)
        // Interstitial to be shown on generate
        .interstitialInBackground(
            interstitialID: Keys.GAD.Interstitial.mainContainerGenerate,
            disabled: premiumUpdater.isPremium,
            isPresented: $adOrReviewCoordinator.isShowingInterstitial)
        // Show ad on appear if not premium
        .task {
            // Show ad or review immediately if premium and not fewer than one launch
            if constantsUpdater.launchCount >= 2 {
                await adOrReviewCoordinator.showAdImmediately(isPremium: premiumUpdater.isPremium)
            }
        }
        // Show review on change of requestedReview
        .onReceive(adOrReviewCoordinator.$requestedReview) { newValue in
            if newValue {
                requestReview()
            }
        }
    }
}

//#Preview {
//
//    RecipeSaveGenerationSwipeContainer()
//    
//}


RecipeImagePickerView.swift
//
//  RecipeImagePickerView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/26/24.
//

import SwiftUI

struct RecipeImagePickerView: View {
    
    let recipe: Recipe
    let onClose: () -> Void
    
    @Environment(\.managedObjectContext) private var viewContext
    
    var body: some View {
        ImagePickerView(
            query: recipe.name ?? "",
            onClose: onClose,
            onSelectImageURL: { imageURL in
                Task {
                    // Get and update image
                    let urlRequest = URLRequest(url: imageURL)
                    let image: UIImage
                    
                    do {
                        // Do request
                        let (data, response) = try await URLSession.shared.data(for: urlRequest)
                        
                        // Try to parse data into image and if successful, add to image array
                        if let unwrappedImage = UIImage(data: data) {
                            image = unwrappedImage
                        } else {
                            // TODO: Handle Errors
                            print("Could not unwrap selected image in RecipeImagePickerView!")
                            return
                        }
                    } catch {
                        // TODO: Handle Errors
                        print("Error getting response when getting images from Bing search response in ImagePickerView: \(error)")
                        return
                    }
                    
                    // Ensure authToken
                    let authToken: String
                    do {
                        authToken = try await AuthHelper.ensure()
                    } catch {
                        // TODO: Handle Errors
                        print("Error ensuring authToken in RecipeImagePickerView... \(error)")
                        return
                    }
                    
                    try await RecipeCDClient.updateRecipe(recipe, uiImage: image, in: viewContext)
                    
                    // Save image URL to server
                    do {
                        try await ChefAppNetworkPersistenceManager.saveRecipeImageURL(
                            authToken: authToken,
                            recipe: recipe,
                            in: viewContext)
                    } catch {
                        // TODO: Handle Errors
                        print("Error saving recipe image URL to server RecipeGenerator, continuing... \(error)")
                    }
                }
                onClose()
            })
    }
    
}

extension View {
    
    func recipeImagePickerPopup(isPresented: Binding<Bool>, recipe: Recipe) -> some View {
        self
            .clearFullScreenCover(isPresented: isPresented) {
                RecipeImagePickerView(
                    recipe: recipe,
                    onClose: {
                        isPresented.wrappedValue = false
                    })
            }
    }
    
    func recipeImagePickerPopup(recipe: Binding<Recipe?>) -> some View {
        var isPresented: Binding<Bool> {
            Binding(
                get: {
                    recipe.wrappedValue != nil
                },
                set: { value in
                    if !value {
                        recipe.wrappedValue = nil
                    }
                })
        }
        
        return self
            .clearFullScreenCover(isPresented: isPresented) {
                if let recipeWrappedValue = recipe.wrappedValue {
                    RecipeImagePickerView(
                        recipe: recipeWrappedValue,
                        onClose: {
                            isPresented.wrappedValue = false
                        })
                }
            }
    }
    
}

//#Preview {
//    
//    RecipeImagePickerView()
//    
//}


RecipeOfTheDayContainer.swift
//
//  RecipeOfTheDayContainer.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/29/24.
//

import SwiftUI

struct RecipeOfTheDayContainer: View {
    
    let onSelect: (_ recipe: Recipe) -> Void
    let onOpenAddToPantry: () -> Void
    
    // How should this work? It should check for a Recipe that is dailyRecipe and when it was created, and if it is within the day show it and if it is before the day delete it and if there is not a dailyRecipe with creation date within the timeframe generate a new one
    // This loads breakfast, lunch, dinner if not there that day. It auto-scrolls to the current timeframe once loaded or if they are alrady loaded
    
    private let width: CGFloat = 300.0
    private let height: CGFloat = 280.0
    
    struct RecipeOfTheDayGenerationSpec: Identifiable {
        let id = UUID()
        
        var recipeGenerationSpec: RecipeGenerationSpec
        var recipeGenerationTimeFrame: RecipeOfTheDayView.TimeFrames
    }
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \PantryItem.updateDate, ascending: false)],
        animation: .default)
    private var pantryItems: FetchedResults<PantryItem>
    
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Recipe.creationDate, ascending: false)],
        predicate: NSPredicate(format: "%K = %d", #keyPath(Recipe.dailyRecipe_isDailyRecipe), true),
        animation: .default)
    private var dailyRecipes: FetchedResults<Recipe>
    
    @StateObject private var recipeOfTheDayGenerator = RecipeOfTheDayGenerator()
    
    @State private var isLoadingPreGeneration: Bool = false
    
    @State private var recipeOfTheDayGenerationSpec: RecipeOfTheDayGenerationSpec?
    
    private var sortedDailyRecipes: [Recipe] {
        dailyRecipes.sorted(by: {
            guard let type1String = $0.dailyRecipe_timeFrameID,
                  let type2String = $1.dailyRecipe_timeFrameID,
                  let type1 = RecipeOfTheDayView.TimeFrames(rawValue: type1String),
                  let type2 = RecipeOfTheDayView.TimeFrames(rawValue: type2String) else {
                return false
            }
            return type1.sortOrder < type2.sortOrder
        })
    }
    
    var body: some View {
        Group {
            let paddingAmount: CGFloat = 16
            if pantryItems.count == 0 {
                Button(action: onOpenAddToPantry) {
                    VStack {
                        Text("Daily Recipe")
                            .font(.custom(Constants.FontName.heavy, size: 24.0))
                        Text("Get daily recipes from your ingredients.")
                            .font(.custom(Constants.FontName.body, size: 17.0))
                        HStack {
                            Image(systemName: "plus")
                                .font(.custom(Constants.FontName.body, size: 20.0))
                            Text("Add to Pantry")
                                .font(.custom(Constants.FontName.heavy, size: 20.0))
                        }
                        .foregroundStyle(Colors.elementBackground)
                        .padding(.top)
                    }
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Colors.foreground.opacity(0.6))
                    .clipShape(RoundedRectangle(cornerRadius: 14.0))
                    .padding(.horizontal)
                }
                .foregroundStyle(Colors.foregroundText)
            } else {
                ScrollViewReader { proxy in
                    Group {
                        if #available(iOS 17.0, *) {
                            SingleAxisGeometryReader(axis: .horizontal) { geometry in
                                ScrollView(.horizontal, showsIndicators: false) {
                                    HStack {
                                        ForEach(sortedDailyRecipes.indices, id: \.self) { index in
                                            let recipe = sortedDailyRecipes[index]
                                            if let dailyRecipeTimeFrameID = recipe.dailyRecipe_timeFrameID,
                                               let dailyRecipeTimeFrame = RecipeOfTheDayView.TimeFrames(rawValue: dailyRecipeTimeFrameID) {
                                                recipeCard(
                                                    recipe: recipe,
                                                    timeFrame: dailyRecipeTimeFrame)
                                                .padding()
                                                .frame(width: geometry.magnitude > paddingAmount * 2 ? geometry.magnitude - paddingAmount * 2 : 0, height: height)
                                                .background(Colors.foreground)
                                                .clipShape(RoundedRectangle(cornerRadius: 14.0))
                                                .scrollTargetLayout()
                                                .tag(index)
                                                //                                    .containerRelativeFrame(.horizontal)
                                                
                                            }
                                        }
                                        
                                        if recipeOfTheDayGenerator.isLoading {
                                            loadingCard
                                                .frame(width: geometry.magnitude > paddingAmount * 2 ? geometry.magnitude - paddingAmount * 2 : 0, height: height)
                                                .background(Colors.foreground)
                                                .clipShape(RoundedRectangle(cornerRadius: 14.0))
                                                .scrollTargetLayout()
                                                .tag(3)
                                            //                                    .containerRelativeFrame(.horizontal)
                                        }
                                    }
                                }
                                .scrollTargetBehavior(.paging)
                                .safeAreaPadding(.horizontal, paddingAmount)
                            }
                        } else {
                            SingleAxisGeometryReader(axis: .horizontal) { geometry in
                                ScrollView(.horizontal, showsIndicators: false) {
                                    HStack {
                                        ForEach(sortedDailyRecipes.indices, id: \.self) { index in
                                            let recipe = sortedDailyRecipes[index]
                                            if let dailyRecipeTimeFrameID = recipe.dailyRecipe_timeFrameID,
                                               let dailyRecipeTimeFrame = RecipeOfTheDayView.TimeFrames(rawValue: dailyRecipeTimeFrameID) {
                                                recipeCard(
                                                    recipe: recipe,
                                                    timeFrame: dailyRecipeTimeFrame)
                                                .padding()
                                                .frame(width: geometry.magnitude > paddingAmount * 2 ? geometry.magnitude - paddingAmount * 2 : 0, height: height)
                                                .background(Colors.foreground)
                                                .clipShape(RoundedRectangle(cornerRadius: 14.0))
                                                .tag(index)
                                                //                                    .padding(paddingAmount / 4)
                                            }
                                        }
                                        
                                        if recipeOfTheDayGenerator.isLoading {
                                            loadingCard
                                                .padding()
                                                .frame(width: geometry.magnitude > paddingAmount * 2 ? geometry.magnitude - paddingAmount * 2 : 0, height: height)
                                                .background(Colors.foreground)
                                                .clipShape(RoundedRectangle(cornerRadius: 14.0))
                                                .tag(3)
                                            //                                    .padding(paddingAmount / 4)
                                        }
                                    }
                                    .padding(.horizontal, paddingAmount)
                                }
                            }
                        }
                    }
                    .task {
                        // Ensure there are pantry items, otherwise return
                        guard pantryItems.count > 0 else {
                            return
                        }
                        
                        // Process daily recipes
                        await recipeOfTheDayGenerator.processDailyRecipes(
                            dailyRecipes: dailyRecipes,
                            pantryItems: pantryItems,
                            in: viewContext)
                        
                        // Scroll to card for current timeFrame
                        if let currentTimeFrame = RecipeOfTheDayView.TimeFrames.timeFrame(for: Date()) {
                            if dailyRecipes.count > currentTimeFrame.sortOrder {
                                await MainActor.run {
                                    withAnimation(.bouncy(duration: 0.5)) {
                                        proxy.scrollTo(currentTimeFrame.sortOrder)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        .fullScreenCover(item: $recipeOfTheDayGenerationSpec) { value in
            NavigationStack {
                RecipeOfTheDayGenerationSwipeView(
                    recipeOfTheDayGenerationSpec: value,
                    dailyRecipes: dailyRecipes,
                    onDismiss: { self.recipeOfTheDayGenerationSpec = nil })
                .toolbar {
                    LogoToolbarItem(foregroundColor: Colors.elementBackground)
                    
                    ToolbarItem(placement: .topBarTrailing) {
                        Button(action: {
                            recipeOfTheDayGenerationSpec = nil
                        }) {
                            Text("Close")
                                .font(.heavy, 17.0)
                                .foregroundStyle(Colors.elementBackground)
                        }
                    }
                }
            }
        }
    }
    
    private var loadingCard: some View {
        VStack {
            Text("Loading \(RecipeOfTheDayView.TimeFrames.timeFrame(for: Date())?.displayString ?? "Daily Recipe")...")
                .font(.custom(Constants.FontName.heavy, size: 24.0))
            ProgressView()
        }
    }
    
    private func recipeCard(recipe: Recipe, timeFrame: RecipeOfTheDayView.TimeFrames) -> some View {
        Button(action: {
            onSelect(recipe)
        }) {
            RecipeOfTheDayView(
                recipe: recipe,
                timeFrame: timeFrame,
                onReload: {
//                    Task {
//                        await recipeOfTheDayGenerator.reloadDailyRecipe(dailyRecipes: dailyRecipes, pantryItems: pantryItems, recipe: recipe, timeFrame: timeFrame, in: viewContext)
//                    }
                    
                    recipeOfTheDayGenerationSpec = RecipeOfTheDayGenerationSpec(
                        recipeGenerationSpec: RecipeGenerationSpec(
                            pantryItems: pantryItems.sorted(by: {$0.name ?? "" < $1.name ?? ""}),
                            suggestions: [],
                            input: "Select from this list and create a delicious \(timeFrame.displayString).",
                            generationAdditionalOptions: .normal),
                        recipeGenerationTimeFrame: timeFrame)
                })
        }
        .foregroundStyle(Colors.foregroundText)
    }
    
}

#Preview {
    
    RecipeOfTheDayContainer(
        onSelect: { recipe in
        
        },
        onOpenAddToPantry: {
            
        })
    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
    .frame(maxHeight: .infinity)
    .background(Colors.background)
    
}


RecipeView.swift
//
//  RecipeView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/20/23.
//

import CoreData
import Foundation
import SwiftUI

struct RecipeView: View {
    
    @ObservedObject var recipeGenerator: RecipeGenerator
    @ObservedObject var recipe: Recipe
    @State var showsCloseButton: Bool = true
//    var namespace: Namespace.ID? = nil
//    var imageAnimationID: String? = nil
//    var nameAnimationID: String? = nil
//    var summaryAnimationID: String? = nil
    let onDismiss: () -> Void
    
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @EnvironmentObject private var premiumUpdater: PremiumUpdater
    @EnvironmentObject private var remainingUpdater: RemainingUpdater
    @EnvironmentObject private var screenIdleTimerUpdater: ScreenIdleTimerUpdater
    
    @StateObject private var tikTokSearchGenerator = TikTokSearchGenerator()
    
    @State private var editingIngredient: RecipeMeasuredIngredient?
    
    //    @State private var isDisplayingCapReachedCard: Bool = false
    
    @State private var isDisplayingRelatedVideos: Bool = false
    
    @State private var isEditingTitle: Bool = false
    @State private var isEditingIngredients: Bool = false
    
    @State private var isShowingRecipeImagePicker: Bool = false
    @State private var isShowingUltraView: Bool = false
    
    @State private var tikTokSearchResponse: TikTokSearchResponse?
    
    @State private var expandedPercentage: CGFloat = 1.0
    @State private var scrollTopOffsetSpacerMinLength: CGFloat = 0.0
    @State private var ingredientsScrollOffset: CGPoint = .zero
    
    @State private var alertShowingAllItemsMarkedForDeletion: Bool = false
    
    @State private var cardColor: Color = Colors.foreground
    
    var shouldDisplayCapReachedCard: Bool {
        !premiumUpdater.isPremium && (recipe.measuredIngredients == nil || recipe.measuredIngredients!.count == 0) && (recipe.directions == nil || recipe.directions!.count == 0) && !recipeGenerator.isCreating && !recipeGenerator.isFinalizing
    }
    
    var measurementAndIngredientOrServingsHasEdits: Bool {
        (recipe.measuredIngredients?.allObjects as? [RecipeMeasuredIngredient])?.contains(where: {
            ($0.nameAndAmountModified != nil && $0.nameAndAmountModified != $0.nameAndAmount) || $0.markedForDeletion
        }) ?? false
        ||
        recipe.estimatedServingsModified != 0 && recipe.estimatedServings != recipe.estimatedServingsModified
    }
    
    var editableEstimatedServings: Binding<Int> {
        Binding(
            get: {
                return Int(recipe.estimatedServingsModified == 0 ? recipe.estimatedServings : recipe.estimatedServingsModified)
            },
            set: { value in
                viewContext.performAndWait {
                    recipe.estimatedServingsModified = Int16(value)
                    
                    do {
                        try viewContext.save()
                    } catch {
                        // TODO: Handle Errors
                        print("Error saving viewContext in RecipeView... \(error)")
                    }
                }
            }
        )
    }
    
    var isShowingIngredientEditorView: Binding<Bool> {
        Binding(
            get: {
                editingIngredient != nil
            },
            set: { newValue in
                if !newValue {
                    self.editingIngredient = nil
                }
            })
    }
    
    
    var body: some View {
        ZStack {
//            let _ = Self._printChanges()
            VStack(spacing: 0.0) {
                //                OffsetObservingScrollView(offset: $ingredientsScrollOffset) {
                ScrollView {
                    Spacer()
                    
                    //                    Spacer(minLength: scrollTopOffsetSpacerMinLength)
                    
                    topCard
                    
                    if recipe.dailyRecipe_isDailyRecipe {
                        dailyRecipeSaveCard
                    }
                    
                    relatedVideosCard
                    
                    VStack {
                        if recipeGenerator.isFinalizing {
                            loadingCard
                        } else if shouldDisplayCapReachedCard {
                            CapReachedCard()
                        } else {
                            ingredients
                            
                            directions
                        }
                        
                    }
                    .padding()
                }
            }
            
            VStack {
                if showsCloseButton {
                    header
                }
                
                Spacer()
            }
        }
        .background(Colors.background)
        .clearFullScreenCover(isPresented: isShowingIngredientEditorView) {
            ZStack {
                if let editingIngredient = editingIngredient {
                    Color.clear
                        .background(Material.thin)
                    ZStack {
                        RecipeIngredientEditorView(
                            measuredIngredient: editingIngredient,
                            isShowing: isShowingIngredientEditorView)
                        .padding()
                        .background(Material.regular)
                        .clipShape(RoundedRectangle(cornerRadius: 28.0))
                        .padding()
                        .animation(.easeInOut, value: editingIngredient)
                    }
                    .transition(.move(edge: .bottom))
                }
            }
        }
        .recipeTitleEditorPopup(isPresented: $isEditingTitle, recipe: recipe)
        .recipeImagePickerPopup(isPresented: $isShowingRecipeImagePicker, recipe: recipe)
        .ultraViewPopover(isPresented: $isShowingUltraView)
        .alert("No Ingredients", isPresented: $alertShowingAllItemsMarkedForDeletion, actions: {
            Button("Close", role: .cancel, action: {
                
            })
        }) {
            Text("All ingredients are marked for deletion. Please ensure there is at least one ingredient before updating directions.")
        }
        .onAppear {
            screenIdleTimerUpdater.keepScreenOn = true
        }
        .task {
            await finishUpdatingRecipeIfNeeded()
        }
        .task {
            // Generate bing image if recipe imageData is nil
            if recipe.imageFromAppData == nil {
                await generateBingImage()
            }
            
            // TODO: Also add an option for AI image!
        }
        .onDisappear {
            screenIdleTimerUpdater.keepScreenOn = false
        }
        
    }
    
    var header: some View {
        ZStack {
            HStack {
                Spacer()
                
                VStack {
                    Button(action: {
                        HapticHelper.doLightHaptic()
                        
                        withAnimation {
                            onDismiss()
                        }
                    }) {
                        Text(Image(systemName: "xmark"))
                            .shadow(color: Colors.elementText, radius: 1)
                            .font(.custom(Constants.FontName.black, size: 34.0))
                            .foregroundStyle(Colors.elementBackground)
                            .padding()
                        
                    }
                    Spacer()
                }
            }
        }
        .frame(height: 100)
    }
    
    var topCard: some View {
        VStack {
            HStack {
                Spacer()
                
                // Top card
                if let name = recipe.name, let summary = recipe.summary {
                    // All necessary components in top card are loaded, so show top card
                    // Top image
                    VStack {
                        if let image = recipe.imageFromAppData {
                            Button(action: {
                                isShowingRecipeImagePicker = true
                            }) {
                                Image(uiImage: image) // TODO: Resize and set image here and stuff
                                    .resizable()
                                    .aspectRatio(contentMode: .fit)
                                    .clipShape(RoundedRectangle(cornerRadius: 28.0))
                                    .frame(height: 180.0)
                            }
                        }
                        
                        // Name
                        Text(name)
                            .font(.custom(Constants.FontName.black, size: 24.0))
                            .multilineTextAlignment(.center)
                            .contextMenu {
                                Button("Edit", systemImage: "square.and.pencil") {
                                    isEditingTitle = true
                                }
                            }
                        
                        // Summary
                        Text(summary)
                            .font(.custom(Constants.FontName.body, size: 14.0))
                            .multilineTextAlignment(.center)
                        
                        shareRecipeCard
                        
                        // Calories and Total Time
                        HStack {
                            Spacer()
                            
                            if recipe.estimatedTotalCalories > 0 {
                                // Calories
                                HStack {
                                    Text("Calories:")
                                        .font(.custom(Constants.FontName.black, size: 14.0))
                                        .foregroundStyle(Colors.foregroundText)
                                    
                                    Text("\(recipe.estimatedTotalCalories)")
                                        .font(.custom(Constants.FontName.black, size: 14.0))
                                        .foregroundStyle(Colors.foregroundText)
                                }
                                
                                Spacer()
                            }
                            
                            if recipe.estimatedTotalMinutes > 0 {
                                // Total Time
                                HStack {
                                    Text("Total Time:")
                                        .font(.custom(Constants.FontName.black, size: 14.0))
                                        .foregroundStyle(Colors.foregroundText)
                                    
                                    Text("\(recipe.estimatedTotalMinutes)m")
                                        .font(.custom(Constants.FontName.black, size: 14.0))
                                        .foregroundStyle(Colors.foregroundText)
                                }
                                
                                Spacer()
                            }
                            
                            HStack {
                                Button(action: {
                                    HapticHelper.doLightHaptic()
                                    Task {
                                        let authToken: String
                                        do {
                                            authToken = try await AuthHelper.ensure()
                                        } catch {
                                            // TODO: Handle Errors
                                            print("Error ensuring authToken in RecipeView... \(error)")
                                            return
                                        }
                                        
                                        // TODO: This logic needs to be fixed in the client code here and in other ChefApp apps, if the user switches from like to dislike it needs to both remove one from dislike and add one to like and the other way too
                                        do {
                                            try await ChefAppNetworkService.addOrRemoveLikeOrDislike(request: AddOrRemoveLikeOrDislikeRequest(
                                                authToken: authToken,
                                                recipeID: Int(recipe.recipeID),
                                                shouldAdd: RecipeLikeState(rawValue: Int(recipe.likeState)) != .like, // Add like if not like, otherwise remove
                                                isLike: true))
                                        } catch {
                                            // TODO: Handle Errors
                                            print("Error adding or removing dislike from Recipe on server in RecipeView... \(error)")
                                        }
                                        
                                        do {
                                            try await RecipeCDClient.updateRecipe(recipe, likeState: RecipeLikeState(rawValue: Int(recipe.likeState)) == .like ? .none : .like, in: viewContext)
                                        } catch {
                                            // TODO: Handle Errors
                                            print("Error updating Recipe likeState in RecipeView... \(error)")
                                        }
                                    }
                                }) {
                                    Image(systemName: RecipeLikeState(rawValue: Int(recipe.likeState)) == .like ? "hand.thumbsup.fill" : "hand.thumbsup")
                                        .foregroundStyle(RecipeLikeState(rawValue: Int(recipe.likeState)) == .like ? Colors.elementBackground : Colors.foregroundText)
                                }
                                
                                Button(action: {
                                    HapticHelper.doLightHaptic()
                                    Task {
                                        let authToken: String
                                        do {
                                            authToken = try await AuthHelper.ensure()
                                        } catch {
                                            // TODO: Handle Errors
                                            print("Error ensuring authToken in RecipeView... \(error)")
                                            return
                                        }
                                        
                                        do {
                                            try await ChefAppNetworkService.addOrRemoveLikeOrDislike(request: AddOrRemoveLikeOrDislikeRequest(
                                                authToken: authToken,
                                                recipeID: Int(recipe.recipeID),
                                                shouldAdd: RecipeLikeState(rawValue: Int(recipe.likeState)) != .dislike, // Add dislike if not dislike, otherwise remove
                                                isLike: false))
                                        } catch {
                                            // TODO: Handle Errors
                                            print("Error adding or removing dislike from Recipe on server in RecipeView... \(error)")
                                        }
                                        
                                        do {
                                            try await RecipeCDClient.updateRecipe(recipe, likeState: RecipeLikeState(rawValue: Int(recipe.likeState)) == .dislike ? .none : .dislike, in: viewContext)
                                        } catch {
                                            // TODO: Handle Errors
                                            print("Error updating Recipe likeState in RecipeView... \(error)")
                                        }
                                    }
                                }) {
                                    Image(systemName: RecipeLikeState(rawValue: Int(recipe.likeState)) == .dislike ? "hand.thumbsdown.fill" : "hand.thumbsdown")
                                        .foregroundStyle(RecipeLikeState(rawValue: Int(recipe.likeState)) == .dislike ? Colors.elementBackground : Colors.foregroundText)
                                }
                            }
                            .padding(.trailing)
                        }
                        .padding(.top, 8)
                        
                    }
                } else {
                    // No components in top card are loaded, so show loading
                    VStack {
                        Spacer()
                        Text("Crafting Recipe...")
                            .font(.custom(Constants.FontName.black, size: 32.0))
                        ProgressView()
                            .progressViewStyle(.circular)
                            .controlSize(.large)
                            .tint(Colors.elementBackground)
                        Spacer()
                    }
                }
                
                Spacer()
            }
            Divider()
                .foregroundStyle(Colors.elementBackground)
        }
    }
    
    var shareRecipeCard: some View {
        VStack(spacing: 0.0) {
            if let url = RecipeShareURLMaker.getShareURL(recipeID: Int(recipe.recipeID)) {
                HStack {
                    ShareLink(item: url) {
                        HStack {
                            Text("Share Recipe")
                                .font(.heavy, 17.0)
                            Image(systemName: "square.and.arrow.up")
                                .font(.body, 17.0)
                        }
                        .foregroundStyle(Colors.elementBackground)
                        .padding(.vertical, 8)
                        .padding(.horizontal)
                        .background(Colors.foreground)
                        .clipShape(RoundedRectangle(cornerRadius: 14.0))
                    }
                }
                .padding(.horizontal)
            }
        }
    }
    
    var relatedVideosCard: some View {
        VStack(spacing: 0.0) {
            if let name = recipe.name,
               let summary = recipe.summary {
                Button(action: { withAnimation(.bouncy(duration: 0.5)) { isDisplayingRelatedVideos.toggle() } }) {
                    HStack {
                        Text("Related Videos")
                            .font(.heavy, 17.0)
                        Spacer()
                        Image(systemName: isDisplayingRelatedVideos ? "chevron.up" : "chevron.down")
                            .font(.body, 17.0)
                    }
                    .padding(.horizontal)
                }
                .foregroundStyle(Colors.foregroundText)
                .padding(.bottom, 8)
                
                if isDisplayingRelatedVideos {
                    TikTokSearchCardsContainer(
                        query: name + " " + summary,
                        height: 200.0,
                        maxCardWidth: 150.0,
                        tikTokSearchGenerator: tikTokSearchGenerator,
                        tikTokSearchResponse: $tikTokSearchResponse)
                    .frame(maxWidth: .infinity)
                    .padding(.bottom, 8)
                }
                
                Divider()
            }
        }
    }
    
    var dailyRecipeSaveCard: some View {
        VStack {
            HStack {
                VStack(alignment: .leading) {
                    Text(recipe.saved ? "Un-save daily recipe?" : "Save daily recipe?")
                        .font(.custom(Constants.FontName.heavy, size: 17.0))
                    Text(recipe.saved ? "Recipe is currently saved." : "Recipe will be deleted tomorrow.")
                        .font(.custom(Constants.FontName.body, size: 12.0))
                }
                
                Spacer()
                
                Button(action: {
                    // Save or unsave daily recipe
                    Task {
                        do {
                            try await RecipeCDClient.updateRecipe(recipe, saved: !recipe.saved, in: viewContext)
                        } catch {
                            // TODO: Handle Errors
                            print("Error updating recipe dailyRecipe_isSavedToRecipes in RecipeOfTheDayView... \(error)")
                        }
                    }
                }) {
                    HStack(spacing: 6.0) {
                        Text(Image(systemName: recipe.saved ? "star.fill" : "star"))
                            .font(.body, 17.0)
                        Text(recipe.saved ? "Un-Save" : "Save")
                            .font(.custom(Constants.FontName.heavy, size: 14.0))
                    }
                        .foregroundStyle(recipe.saved ? Colors.elementBackground : Colors.elementText)
                        .padding(.horizontal)
                        .padding(.vertical, 8)
                        .background(
                            ZStack {
                                if recipe.saved {
                                    RoundedRectangle(cornerRadius: 14.0)
                                        .stroke(Colors.elementBackground, lineWidth: 2)
                                } else {
                                    RoundedRectangle(cornerRadius: 14.0)
                                        .fill(Colors.elementBackground)
                                }
                            }
                        )
                }
            }
            .padding(.horizontal)
            
            Divider()
                .foregroundStyle(Colors.elementBackground)
        }
    }
    
    var loadingCard: some View {
        ZStack {
            HStack {
                Spacer()
                VStack {
                    Spacer()
                    Text("Creating Ingredients & Directions...")
                        .font(.custom(Constants.FontName.bodyOblique, size: 17.0))
                    ProgressView()
                        .foregroundStyle(Colors.foregroundText)
                    Spacer()
                }
                Spacer()
            }
        }
        .padding()
        .background(cardColor)
        .clipShape(RoundedRectangle(cornerRadius: 24.0))
        
    }
    
    var ingredients: some View {
        ZStack {
            // Measured Ingredients
            if let measuredIngredients = recipe.measuredIngredients?.allObjects as? [RecipeMeasuredIngredient], measuredIngredients.count > 0 {
                VStack {
                    ZStack(alignment: .top) {
                        // Insert Ingredient Button
                        HStack {
                            Spacer()
                            
                            Button(action: {
                                HapticHelper.doLightHaptic()
                                
                                withAnimation(.bouncy) {
                                    isEditingIngredients.toggle()
                                }
                            }) {
                                Text(isEditingIngredients ? Image(systemName: "checkmark") : Image(systemName: "square.and.pencil"))
                                    .font(.custom(Constants.FontName.body, size: 20.0))
                                    .foregroundStyle(isEditingIngredients ? Colors.elementText : Colors.elementBackground)
                                    .frame(width: 48.0, height: 48.0)
                                    .background(isEditingIngredients ? Colors.elementBackground : Colors.background)
                                    .clipShape(RoundedRectangle(cornerRadius: 14.0))
                            }
                        }
                        
                        // Edit Servings Picker
                        HStack {
                            VStack(spacing: 2.0) {
                                Text("Servings:")
                                    .font(.custom(Constants.FontName.body, size: 12.0))
                                    .foregroundStyle(Colors.foregroundText)
                                
                                Menu {
                                    Picker(
                                        selection: editableEstimatedServings,
                                        content: {
                                            ForEach(1..<100) { i in
                                                Text("\(i)")
                                                    .font(.custom(Constants.FontName.body, size: 14.0))
                                                    .tag(i)
                                            }
                                        },
                                        label: {
                                            
                                        })
                                } label: {
                                    HStack {
                                        Text("\(editableEstimatedServings.wrappedValue)")
                                            .font(.custom(Constants.FontName.body, size: 14.0))
                                        
                                        Image(systemName: "chevron.up.chevron.down")
                                            .imageScale(.medium)
                                        
                                        Spacer()
                                    }
                                    .padding([.leading, .trailing])
                                }
                                .menuOrder(.fixed)
                                .menuIndicator(.visible)
                                .foregroundStyle(Colors.elementBackground)
                                .tint(Colors.elementBackground)
                            }
                            .frame(width: 70.0, height: 48.0)
                            .background(Colors.background)
                            .clipShape(RoundedRectangle(cornerRadius: 14.0))
                            .fixedSize(horizontal: true, vertical: false)
                            
                            Spacer()
                        }
                        
                        // Ingredients Title
                        HStack {
                            Text("Ingredients")
                                .font(.custom(Constants.FontName.black, size: 20.0))
                                .foregroundStyle(Colors.foregroundText)
                        }
                        .padding(.top, 8)
                        .padding(.bottom, 1)
                    }
                    
                    Spacer(minLength: 16.0)
                    
                    VStack(spacing: isEditingIngredients ? 8.0 : 2.0) {
                        ForEach(measuredIngredients) { measuredIngredient in
                            //                        var isEditingIngredient: Binding<Bool> {
                            //                            Binding(
                            //                                get: {
                            //                                    editingIngredient != nil
                            //                                },
                            //                                set: { newValue in
                            //                                    if !newValue {
                            //                                        editingIngredient = nil
                            //                                    }
                            //                                })
                            //                        }
                            HStack {
                                RecipeEditableIngredientView(
                                    measuredIngredient: measuredIngredient,
                                    isExpanded: $isEditingIngredients,
                                    isDisabled: $recipeGenerator.isRegeneratingDirections,
                                    onEdit: {
                                        editingIngredient = measuredIngredient
                                    })
                                Spacer()
                            }
                        }
                    }
                    //                    .padding([.leading, .trailing])
                    
                    // Add Ingredient Button
                    if isEditingIngredients {
                        Button(action: {
                            HapticHelper.doLightHaptic()
                            
                            insertAndEditNewIngredient()
                        }) {
                            HStack {
                                Spacer()
                                Text("\(Image(systemName: "plus")) Add Ingredient")
                                    .font(.custom(Constants.FontName.heavy, size: 17.0))
                                    .foregroundStyle(Colors.elementBackground)
                                Spacer()
                            }
                            .padding(8)
                            .background(Colors.background)
                            .clipShape(RoundedRectangle(cornerRadius: 24.0))
                        }
                        .animation(.bouncy, value: isEditingIngredients)
                    }
                    
                    // Regenerate Directions Button
                    HStack {
                        if measurementAndIngredientOrServingsHasEdits {
                            Button(action: {
                                HapticHelper.doMediumHaptic()
                                
                                Task {
                                    do {
                                        try await resolveIngredientsAndRegenerateDirections()
                                        
                                        HapticHelper.doSuccessHaptic()
                                    } catch {
                                        // TODO: Handle Errors
                                        print("Error resolving ingredinets and regenerating directions in RecipeView... \(error)")
                                    }
                                }
                            }) {
                                ZStack {
                                    if recipeGenerator.isRegeneratingDirections {
                                        HStack {
                                            Spacer()
                                            ProgressView()
                                                .tint(Colors.elementText)
                                                .padding(.trailing)
                                        }
                                    }
                                    
                                    HStack {
                                        Spacer()
                                        Text("Update Instructions...")
                                            .font(.custom(Constants.FontName.heavy, size: 17.0))
                                            .foregroundStyle(Colors.elementText)
                                        Spacer()
                                    }
                                }
                            }
                            .padding(8)
                            .background(Colors.elementBackground)
                            .clipShape(RoundedRectangle(cornerRadius: 24.0))
                            .opacity(recipeGenerator.isRegeneratingDirections ? 0.4 : 1.0)
                            .disabled(recipeGenerator.isRegeneratingDirections)
                            .padding(.top, 8)
                        }
                    }
                }
                .padding()
                .background(cardColor)
                .clipShape(RoundedRectangle(cornerRadius: 24.0))
            } else {
                // No measured ingredients are loaded, so show loading
                VStack {
                    Spacer()
                    Text("Loading Ingredients & Instructions ...")
                        .font(.custom(Constants.FontName.black, size: 32.0))
                    ProgressView()
                        .progressViewStyle(.circular)
                        .controlSize(.large)
                        .tint(Colors.elementBackground)
                    Spacer()
                }
            }
        }
        .onChange(of: ingredientsScrollOffset, perform: { offset in
            //updateExpandedPercentage(offset: offset)
            //            updateScrollTopSpacerMinLength(offset: offset)
        })
    }
    
    var directions: some View {
        VStack {
            // Directions
            if let unsortedDirections = (recipe.directions?.allObjects as? [RecipeDirection]), unsortedDirections.count > 0 {
                let directions = unsortedDirections.sorted(by: {$0.index < $1.index})
                ForEach(directions) { direction in
                    if let string = direction.string {
                        HStack {
                            Text("\(direction.index + 1)")
                                .font(.custom(Constants.FontName.black, size: 24.0))
                                .padding(.trailing, 8)
                            Text(LocalizedStringKey(string))
                                .font(.custom(Constants.FontName.body, size: 14.0))
                                .multilineTextAlignment(.leading)
                            Spacer()
                        }
                        .padding()
                        .background(cardColor)
                        .clipShape(RoundedRectangle(cornerRadius: 24.0))
                    }
                }
            } else {
                if !recipeGenerator.isFinalizing {
                    Button(action: {
                        HapticHelper.doLightHaptic()
                        
                        Task {
                            await finishUpdatingRecipeIfNeeded()
                            
                            HapticHelper.doSuccessHaptic()
                        }
                    }) {
                        Text("Finish Generating...")
                            .font(.custom(Constants.FontName.heavy, size: 24.0))
                            .tint(Colors.elementBackground)
                            .background(Material.regular)
                    }
                }
            }
            
            Spacer(minLength: 240.0)
        }
    }
    
    func finishUpdatingRecipeIfNeeded() async {
        // TODO: Maybe generate image here?
        // If no measuredIngredients or directions, finalize and update remaining
        if recipe.measuredIngredients == nil || recipe.measuredIngredients!.count == 0 || recipe.directions == nil || recipe.directions!.count == 0 {
            // Finalize recipe
            do {
                try await recipeGenerator.finalize(recipe: recipe, additionalInput: "In the recipe's instructions but NOT measured ingredients, you may use **text** for bold (amounts and ingredients and emphesis) and *text* for italic (sparingly if at all), and other formats with LocalizedStringKey Swift 5.5+.", in: viewContext)
            } catch NetworkingError.capReachedError {
                //                isDisplayingCapReachedCard //- This is handled by shouldDisplayCapReachedCard
            } catch {
                // TODO: Handle errors
                print("Error finalizing recipe in RecipeView... \(error)")
            }
            
            // Update remaining
            do {
                let authToken = try await AuthHelper.ensure()
                
                do {
                    try await remainingUpdater.update(authToken: authToken)
                } catch {
                    // TODO: Handle Errors
                    print("Error updating remaining in RecipeView... \(error)")
                }
            } catch {
                // TODO: Handle Errors
                print("Error ensuring authToken in RecipeView... \(error)")
            }
        }
    }
    
    func generateBingImage() async {
        /* Bing Image */
        do {
            try await recipeGenerator.generateBingImage(recipe: recipe, in: viewContext)
        } catch {
            // TODO: Handle Errors
            print("Error generating bing image in RecipeView... \(error)")
        }
    }
    
    func insertAndEditNewIngredient() {
        // TODO: Is this good enough or does this need a better implementation lol
        let measuredIngredient: RecipeMeasuredIngredient
        do {
            measuredIngredient = try viewContext.performAndWait {
                let measuredIngredient = RecipeMeasuredIngredient(context: viewContext)
                
                measuredIngredient.recipe = recipe
                
                try viewContext.save()
                
                return measuredIngredient
            }
        } catch {
            // TODO: Handle Errors
            print("Error inserting ingredient in RecipeView... \(error)")
            return
        }
        
        editingIngredient = measuredIngredient
    }
    
    func resolveIngredientsAndRegenerateDirections() async throws {
        // Ensure all ingredients arent marekd for deletion, otherwise set showing alert to true and return TODO: Is this a good place and implementation for this?
        guard let measuredIngredients = (recipe.measuredIngredients?.allObjects as? [RecipeMeasuredIngredient]), measuredIngredients.contains(where: {!$0.markedForDeletion}) else {
            alertShowingAllItemsMarkedForDeletion = true
            return
        }
        
        // Regenerate directions and resolve updated ingredients
        try await recipeGenerator.regenerateDirectionsAndResolveUpdatedIngredients(for: recipe, additionalInput: "In the recipe's instructions but NOT measured ingredients, you may use **text** for bold (amounts and ingredients and emphesis) and *text* for italic (sparingly if at all), and other formats with LocalizedStringKey Swift 5.5+.", in: viewContext)
    }
    
    func updateExpandedPercentage(offset: CGPoint) {
        let maxOffset: CGFloat = 100.0
        
        if offset.y > maxOffset {
            expandedPercentage = 0.0
        } else if offset.y <= 0 {
            expandedPercentage = 1.0
        } else {
            expandedPercentage = 1 - offset.y / maxOffset
        }
    }
    
    //    func updateScrollTopSpacerMinLength(offset: CGPoint) {
    //        if expandedPercentage >= 1.0 {
    //            scrollTopOffsetSpacerMinLength = 0.0
    //        } else if expandedPercentage > 0.0 {
    //            scrollTopOffsetSpacerMinLength = offset.y
    //        }
    //    }
    
    
}


#Preview {
    
    let viewContext = CDClient.mainManagedObjectContext
    
    var recipe = Recipe(entity: Recipe.entity(), insertInto: viewContext)
    recipe.input = "Recipe input"
    recipe.name = "Sparkling Mint Vodka"
    recipe.summary = "A refreshing and minty cocktail with a hint of vodka and a sparkling twist!"
    recipe.estimatedTotalCalories = 100
    recipe.estimatedTotalMinutes = 60
    recipe.imageData = UIImage(named: "AppIconNoBackground")?.pngData()
    recipe.recipeID = 0
    
    recipe.dailyRecipe_isDailyRecipe = true
    recipe.dailyRecipe_timeFrameID = RecipeOfTheDayView.TimeFrames.lunch.rawValue
//    recipe.dailyRecipe_isSavedToRecipes = false
    
    var recipeMeasuredIngredient1 = RecipeMeasuredIngredient(entity: RecipeMeasuredIngredient.entity(), insertInto: viewContext)
    recipeMeasuredIngredient1.nameAndAmount = "ingredient and measurement"
    recipeMeasuredIngredient1.recipe = recipe
    
    var recipeMeasuredIngredient2 = RecipeMeasuredIngredient(entity: RecipeMeasuredIngredient.entity(), insertInto: viewContext)
    recipeMeasuredIngredient2.nameAndAmount = "another ingredient 2 1/4 cup"
    recipeMeasuredIngredient2.recipe = recipe
    
    var recipeMeasuredIngredient3 = RecipeMeasuredIngredient(entity: RecipeMeasuredIngredient.entity(), insertInto: viewContext)
    recipeMeasuredIngredient3.nameAndAmount = "3 3/5 cup wow another ingredient"
    recipeMeasuredIngredient3.recipe = recipe
    
    var recipeDirection1 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
    recipeDirection1.index = 1
    recipeDirection1.string = "First direction"
    recipeDirection1.recipe = recipe
    
    var recipeDirection2 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
    recipeDirection2.index = 2
    recipeDirection2.string = "Second direction"
    recipeDirection2.recipe = recipe
    
    var recipeDirection3 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
    recipeDirection3.index = 3
    recipeDirection3.string = "Third direction"
    recipeDirection3.recipe = recipe
    
    var recipeDirection4 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
    recipeDirection4.index = 4
    recipeDirection4.string = "Fourth direction"
    recipeDirection4.recipe = recipe
    
    var recipeDirection5 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
    recipeDirection5.index = 5
    recipeDirection5.string = "fifth direction"
    recipeDirection5.recipe = recipe
    
    var recipeDirection6 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
    recipeDirection6.index = 6
    recipeDirection6.string = "Sixth direction"
    recipeDirection6.recipe = recipe
    
    var recipeDirection7 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
    recipeDirection7.index = 7
    recipeDirection7.string = "Seventh direction"
    recipeDirection7.recipe = recipe
    
    var recipeDirection8 = RecipeDirection(entity: RecipeDirection.entity(), insertInto: viewContext)
    recipeDirection8.index = 8
    recipeDirection8.string = "Eigth direction"
    recipeDirection8.recipe = recipe
    
    try! viewContext.save()
    
    return RecipeView(
        recipeGenerator: RecipeGenerator(),
        recipe: recipe,
        onDismiss: {
            
        })
    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
    .environmentObject(PremiumUpdater())
    .environmentObject(ProductUpdater())
    .environmentObject(RemainingUpdater())
    .background(Colors.background)
}


RecipeGenerator.swift
//
//  RecipeGenerator.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/25/23.
//

import CoreData
import Foundation
import SwiftUI

class RecipeGenerator: ObservableObject {
    
//    @Published var createdRecipes: [Recipe] = []
    @Published var isCapReached: Bool = false
    @Published var isCreating: Bool = false
    @Published var isFinalizing: Bool = false
    @Published var isGeneratingTags: Bool = false
    @Published var isGeneratingBingImage: Bool = false
    @Published var isRegeneratingDirections: Bool = false
    @Published var isGeneratingIngredientsPreview: Bool = false
    
    func create(ingredients: String, modifiers: String?, expandIngredientsMagnitude: Int, in viewContext: NSManagedObjectContext) async throws -> Recipe {
        try await create(
            ingredients: ingredients,
            modifiers: modifiers,
            expandIngredientsMagnitude: expandIngredientsMagnitude,
            dailyRecipe_isDailyRecipe: false,
            dailyRecipe_timeFrameID: nil,
            in: viewContext)
    }
    
    func create(ingredients: String, modifiers: String?, expandIngredientsMagnitude: Int, dailyRecipe_isDailyRecipe: Bool, dailyRecipe_timeFrameID: String?, in viewContext: NSManagedObjectContext) async throws -> Recipe {
        // Set isCreating to false once this method completes
        defer {
            DispatchQueue.main.async {
                self.isCreating = false
            }
        }
        
        // Set isCreating to true and isCapReached to false
        await MainActor.run {
            self.isCreating = true
            self.isCapReached = false
        }
        
        // Get authToken with AuthHelper ensure
        let authToken: String
        do {
            authToken = try await AuthHelper.ensure()
        } catch {
            // TODO: Handle errors
            print("Error ensuring authToken when creating Recipe in RecipeGenerator... \(error)")
            throw GenerationError.auth
        }
        
        // Create and save and return recipe
        do {
            return try await ChefAppNetworkPersistenceManager.createSaveRecipe(
                authToken: authToken,
                ingredients: ingredients,
                modifiers: modifiers,
                expandIngredientsMagnitude: expandIngredientsMagnitude,
                dailyRecipe_isDailyRecipe: dailyRecipe_isDailyRecipe,
                dailyRecipe_timeFrameID: dailyRecipe_timeFrameID,
                in: viewContext)
        } catch NetworkingError.capReachedError {
            await MainActor.run {
                isCapReached = true
            }
            
            throw NetworkingError.capReachedError
        }
    }
    
    func finalize(recipe: Recipe, additionalInput: String?, in viewContext: NSManagedObjectContext) async throws {
//        // Ensure is not finalizing, otherwise return
//        guard !isFinalizing else {
//            return
//        }
        
        // Set isFinalizing to false once this method completes
        defer {
            DispatchQueue.main.async {
                self.isFinalizing = false
            }
        }
        
        // Set isFinalizing to true and isCapReached to false
        DispatchQueue.main.async {
            self.isFinalizing = true
            self.isCapReached = false
        }
        
        // Get authToken with AuthHelper ensure
        let authToken: String
        do {
            authToken = try await AuthHelper.ensure()
        } catch {
            // TODO: Handle errors
            print("Error ensuring authToken when finalizing Recipe in RecipeGenerator... \(error)")
            return
        }
        
        // Finalize and save recipe
        try await ChefAppNetworkPersistenceManager.finalizeUpdateRecipe(
            authToken: authToken,
            recipe: recipe,
            additionalInput: additionalInput,
            in: viewContext)
    }
    
    func generateTags(recipe: Recipe, in viewContext: NSManagedObjectContext) async throws {
//        // Ensure is not generating tags, otherwise return
//        guard !isGeneratingTags else {
//            return
//        }
        
        // Set isGeneratingTags to false once this method completes
        defer {
            DispatchQueue.main.async {
                self.isGeneratingTags = false
            }
        }
        
        // Set isGeneratingTags to true
        DispatchQueue.main.async {
            self.isGeneratingTags = true
        }
        
        // Get authToken with AuthHelper ensure
        let authToken: String
        do {
            authToken = try await AuthHelper.ensure()
        } catch {
            // TODO: Handle errors
            print("Error ensuring authToken when finalizing Recipe in RecipeGenerator... \(error)")
            return
        }
        
        // Generate and save tags
        try await ChefAppNetworkPersistenceManager.generateSaveTags(
            authToken: authToken,
            recipe: recipe,
            in: viewContext)
    }
    
    func generateBingImage(recipe: Recipe, in viewContext: NSManagedObjectContext) async throws {
//        // Ensure is not generating Bing image, otherwise return
//        guard !isGeneratingBingImage else {
//            return
//        }
        
        // Set isGeneratingBingImage to false once this method completes
        defer {
            DispatchQueue.main.async {
                self.isGeneratingBingImage = false
            }
        }
        
        // Set isGeneratingBingImage to true
        DispatchQueue.main.async {
            self.isGeneratingBingImage = true
        }
        
        // Get authToken with AuthHelper ensure
        let authToken: String
        do {
            authToken = try await AuthHelper.ensure()
        } catch {
            // TODO: Handle errors
            print("Error ensuring authToken when finalizing Recipe in RecipeGenerator... \(error)")
            return
        }
        
        // Generate save first bing image
        try await ChefAppNetworkPersistenceManager.generateSaveFirstBingImage(
            recipe: recipe,
            in: viewContext)
        
        // Save image URL to server
        do {
            try await ChefAppNetworkPersistenceManager.saveRecipeImageURL(
                authToken: authToken,
                recipe: recipe,
                in: viewContext)
        } catch {
            // TODO: Handle Errors
            print("Error saving recipe image URL to server RecipeGenerator, continuing... \(error)")
        }
    }
    
    func regenerateDirectionsAndResolveUpdatedIngredients(for recipe: Recipe, additionalInput: String, in managedContext: NSManagedObjectContext) async throws {
//        // Ensure is not regenerating already, otherwise return
//        guard !isRegeneratingDirections else {
//            return
//        }
        
        // Set isRegeneratingDirections to false once this method completes
        defer {
            DispatchQueue.main.async {
                self.isRegeneratingDirections = false
            }
        }
        
        // Set isRegeneratingDirections to true
        DispatchQueue.main.async {
            self.isRegeneratingDirections = true
        }
        
        // Get authToken with AuthHelper ensure
        let authToken: String
        do {
            authToken = try await AuthHelper.ensure()
        } catch {
            // TODO: Handle errors
            print("Error ensuring authToken when regenerating directions in RecipeGenerator... \(error)")
            return
        }
        
        // Get and save regenerated directions
        try await ChefAppNetworkPersistenceManager.regenerateSaveMeasuredIngredientsAndDirectionsAndResolveUpdatedIngredients(authToken: authToken, recipe: recipe, additionalInput: additionalInput, in: managedContext)
    }
    
//    func getRecipeIngredientsPreview(RecipeID: Int64) async throws {
//        // Ensure is not generating Recipe ingredients preview already, otherwise return
//        guard !isGeneratingIngredientsPreview else {
//            return
//        }
//        
//        // Set isGeneratingIngredientsPreview to false once this method completes
//        defer {
//            DispatchQueue.main.async {
//                self.isGeneratingIngredientsPreview = false
//            }
//        }
//        
//        // Set isGeneratingIngredientsPreview to true
//        DispatchQueue.main.async {
//            self.isGeneratingIngredientsPreview = true
//        }
//        
//        // Get authToken with AuthHelper ensure
//        let authToken: String
//        do {
//            authToken = try await AuthHelper.ensure()
//        } catch {
//            // TODO: Handle errors
//            print("Error ensuring authToken when getting Recipe ingredients preview in RecipeGenerator... \(error)")
//            return
//        }
//        
//        // Get permanent Recipe object id
//        let RecipeObjectID = try await RecipeCDClient.getRecipePermanentID(RecipeID: RecipeID)
//        
//        // Get and save Recipe ingredients preview
//        try await ChefAppNetworkPersistenceManager.getSaveRecipeIngredientsPreview(
//            authToken: authToken,
//            RecipeID: Int(RecipeID),
//            to: RecipeObjectID)
//    }
    
//    func updateGlass(RecipeID: Int64) async throws {
//        // Ensure is not generating glass already, otherwise return
//        guard !isUpdatingGlass else {
//            return
//        }
//        
//        // Set isUpdatingGlass to false once this method completes
//        defer {
//            DispatchQueue.main.async {
//                self.isUpdatingGlass = false
//            }
//        }
//        
//        // Set isUpdatingGlass to true
//        DispatchQueue.main.async {
//            self.isUpdatingGlass = true
//        }
//        
//        // Get authToken with AuthHelper ensure
//        let authToken: String
//        do {
//            authToken = try await AuthHelper.ensure()
//        } catch {
//            // TODO: Handle errors
//            print("Error ensuring authToken when updating glass in RecipeGenerator... \(error)")
//            return
//        }
//        
//        // Get permanent Recipe object id
//        let RecipeObjectID = try await RecipeCDClient.getRecipePermanentID(RecipeID: RecipeID)
//        
//        // Get and save glass color
//        try await BarbackNetworkPersistenceManager.getSaveGlassColor(
//            authToken: authToken,
//            RecipeID: Int(RecipeID),
//            to: RecipeObjectID)
//        
//        // Get and save glass
//        try await BarbackNetworkPersistenceManager.getSaveGlass(
//            authToken: authToken,
//            RecipeID: Int(RecipeID),
//            to: RecipeObjectID)
//    }
    
}


ImagePickerView.swift
//
//  ImagePickerView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/26/24.
//

import SwiftUI

struct ImagePickerView: View {
    
    // TODO: Ability to add image from camera roll
    
    let query: String
    let onClose: () -> Void
    let onSelectImageURL: (URL) -> Void
    
    @State private var imageURLs: [URL] = [] // TODO: Cache images? Should this even be done? What if the next pages are not all of the images and for some reason they go back to the previous ones?
    
    @State private var searchOffset: Int = 0
    
    var body: some View {
        VStack {
            Text("Select Image")
                .font(.custom(Constants.FontName.heavy, size: 20.0))
            
            VStack {
                HStack {
                    imageOrProgressView(forImageAtIndex: 0)
                    imageOrProgressView(forImageAtIndex: 1)
                }
                HStack {
                    imageOrProgressView(forImageAtIndex: 2)
                    imageOrProgressView(forImageAtIndex: 3)
                }
            }
            
            HStack {
                Button(action: {
                    imageURLs = []
                    searchOffset -= 1
                    Task {
                        await fetchNextFourImages()
                    }
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                        Text("Back")
                    }
                    .font(.custom(Constants.FontName.heavy, size: 17.0))
                    .foregroundStyle(Colors.elementText)
                    .padding(.vertical, 8)
                    .padding(.horizontal)
                    .background(Colors.elementBackground)
                    .clipShape(RoundedRectangle(cornerRadius: 14.0))
                }
                .disabled(searchOffset == 0)
                .opacity(searchOffset == 0 ? 0.2 : 1.0)
                
                VStack {
                    Text("Page")
                        .font(.custom(Constants.FontName.body, size: 12.0))
                    Text("\(searchOffset + 1)")
                        .font(.custom(Constants.FontName.heavy, size: 14.0))
                }
                .padding(.horizontal)
                
                Button(action: {
                    imageURLs = []
                    searchOffset += 1
                    Task {
                        await fetchNextFourImages()
                    }
                }) {
                    HStack {
                        Text("Next")
                        Image(systemName: "chevron.right")
                    }
                    .font(.custom(Constants.FontName.heavy, size: 17.0))
                    .foregroundStyle(Colors.elementText)
                    .padding(.vertical, 8)
                    .padding(.horizontal)
                    .background(Colors.elementBackground)
                    .clipShape(RoundedRectangle(cornerRadius: 14.0))
                }
            }
        }
        .overlay(alignment: .topTrailing) {
            Button(action: { onClose() }) {
                Image(systemName: "xmark")
                    .font(.custom(Constants.FontName.heavy, size: 20.0))
                    .foregroundStyle(Colors.elementBackground)
            }
        }
        .padding()
        .background(Colors.background)
        .clipShape(RoundedRectangle(cornerRadius: 14.0))
        .task {
            await fetchNextFourImages()
        }
    }
    
    func fetchNextFourImages() async {
        do {
            let (imageURLs, totalCountMaybe) = try await BingSearchClient.getImages(
                query: query,
                count: 4,
                offset: searchOffset * 4)
            
//            var images: [UIImage] = []
//            for imageURL in imageURLs {
//                let urlRequest = URLRequest(url: imageURL)
//                
//                do {
//                    // Do request
//                    let (data, response) = try await URLSession.shared.data(for: urlRequest)
//                    
//                    // Try to parse data into image and if successful, add to image array
//                    if let image = UIImage(data: data) {
//                        images.append(image)
//                    }
//                } catch {
//                    print("Error getting response when getting images from Bing search response in ImagePickerView: \(error)")
//                }
//            }
            
            self.imageURLs = imageURLs
        } catch {
            // TODO: Handle Errors
            print("Error getting Bing images in ImagePickerView... \(error)")
        }
    }
    
    func imageOrProgressView(forImageAtIndex index: Int) -> some View {
        ZStack {
            if let imageURL = imageURLs[safe: index] {
                Button(action: { onSelectImageURL(imageURL) }) {
                    AsyncImage(url: imageURL) { phase in
                        switch phase {
                        case .empty:
                            ProgressView()
                        case .success(let image):
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                        case .failure(let error):
                            // TODO: Implement better error view for AsyncImage
                            ZStack {
                                Color.elementText
                                Image(systemName: "photo")
                                    .foregroundStyle(Colors.elementBackground)
                            }
                        @unknown default:
                            // TODO: Implement better unknown default view for AsyncImage
                            ZStack {
                                Color.elementText
                                Image(systemName: "photo")
                                    .foregroundStyle(Colors.elementBackground)
                            }
                        }
                    }
                }
            } else {
                ProgressView()
            }
        }
        .frame(width: 150.0, height: 150.0)
        .background(Colors.foreground)
        .clipShape(RoundedRectangle(cornerRadius: 14.0))
    }
    
}

#Preview {
    
    @StateObject var constantsUpdater = ConstantsUpdater()
    
    ImagePickerView(
        query: "Pizza and pasta",
        onClose: {
            
        },
        onSelectImageURL: { imageURL in
            
        }
    )
    .environmentObject(constantsUpdater)
    .task {
        try! await constantsUpdater.update()
    }
    
}


RecipeTitleEditorView.swift
//
//  RecipeTitleEditorView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/3/24.
//

import SwiftUI

struct RecipeTitleEditorView: View {
    
    let recipe: Recipe
    @Binding var isPresented: Bool
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @State private var recipeTitleEditor_newTitle = ""
    
    var body: some View {
        VStack(alignment: .leading) {
            Text("Edit Title")
                .font(.heavy, 20.0)
            TextField(recipe.name ?? "Title...", text: $recipeTitleEditor_newTitle)
                .font(.body, 17.0)
                .padding(.vertical, 8)
                .padding(.horizontal)
                .frame(maxWidth: .infinity)
                .background(Colors.foreground)
                .clipShape(RoundedRectangle(cornerRadius: 14.0))
                .padding(.horizontal)
            if let name = recipe.name {
                Text("Original Title: \(name)")
                    .font(.body, 14.0)
                    .opacity(0.6)
            }
            
            HStack {
                Button(action: {
                    isPresented = false
                }) {
                    Text("Cancel")
                        .frame(maxWidth: .infinity)
                        .appButtonStyle(foregroundColor: Colors.elementBackground, backgroundColor: Colors.elementText)
                }
                
                Button(action: {
                    if !recipeTitleEditor_newTitle.isEmpty {
                        Task {
                            do {
                                try await RecipeCDClient.updateRecipe(recipe, name: recipeTitleEditor_newTitle, in: viewContext)
                            } catch {
                                // TODO: Handle Errors
                                print("Error updating recipe title in RecipeView... \(error)")
                            }
                        }
                    }
                    isPresented = false
                }) {
                    Text("Save")
                        .frame(maxWidth: .infinity)
                        .appButtonStyle()
                }
            }
        }
        .padding()
        .background(Colors.background)
        .clipShape(RoundedRectangle(cornerRadius: 14.0))
        .padding()
    }
    
}

extension View {
    
    func recipeTitleEditorPopup(isPresented: Binding<Bool>, recipe: Recipe) -> some View {
        self
            .clearFullScreenCover(isPresented: isPresented) {
                RecipeTitleEditorView(
                    recipe: recipe,
                    isPresented: isPresented)
            }
    }
    
}

//#Preview {
//    
//    RecipeTitleEditorView()
//    
//}


RecipeEditableIngredientView.swift
//
//  RecipeEditableIngredientView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/2/23.
//

import SwiftUI

struct RecipeEditableIngredientView: View {
    
    @State var measuredIngredient: RecipeMeasuredIngredient
//    @Binding var expandedPercentage: CGFloat
    @Binding var isExpanded: Bool
    @Binding var isDisabled: Bool
    var onEdit: () -> Void
    
    @Environment(\.managedObjectContext) private var viewContext
    
    private let lowerBound = 0.25
    private let upperBound = 0.75
    
    @State private var parsedMeasuredIngredient: MeasurementIngredientParser.ParsedMeasurementIngredient?
    
    init(measuredIngredient: RecipeMeasuredIngredient, isExpanded: Binding<Bool>, isDisabled: Binding<Bool>, onEdit: @escaping () -> Void) {
        self._measuredIngredient = State(initialValue: measuredIngredient)
        self._isExpanded = isExpanded
        self._isDisabled = isDisabled
        self.onEdit = onEdit
        self._parsedMeasuredIngredient = State(initialValue: MeasurementIngredientParser.parseFirstMeasurement(from: measuredIngredient.nameAndAmountModified ?? measuredIngredient.nameAndAmount ?? "", leastToGreatestPossibleFractionValues: MeasuredIngredientPickerView.defaultMinToMaxFractionStrings))
    }
    
//    private var isDisabledByScrolling: Bool {
//        expandedPercentage < upperBound
//    }
    
    private var backgroundFillColor: Color {
        if measuredIngredient.markedForDeletion {
            return Color(uiColor: .systemRed)
        }
        if measuredIngredient.nameAndAmountModified != nil, measuredIngredient.nameAndAmountModified != measuredIngredient.nameAndAmount {
            return Color(uiColor: .systemYellow)
        }
        return Colors.background
    }
    
//    private var buttonFillOpacity: CGFloat {
//        guard !isDisabled else {
//            return lowerBound
//        }
//        if expandedPercentage >= upperBound {
//            return 1.0
//        } else if expandedPercentage <= lowerBound {
//            return 0.0
//        } else {
//            return (expandedPercentage - lowerBound) * (1.0 / (upperBound - lowerBound))
//        }
//    }
    
//    private var textOpacity: CGFloat {
//        max(buttonFillOpacity, 0.5)
//    }
    
    var body: some View {
        ZStack {
//            let _ = Self._printChanges()
            Button(action: {
                HapticHelper.doLightHaptic()
                
                onEdit()
            }) {
                HStack(spacing: 6.0) {
                    Text(Image(systemName: "circle.fill"))
                        .font(.body, 2.0)
                        .foregroundStyle(Colors.foregroundText)
                    if let parsedMeasuredIngredient = parsedMeasuredIngredient {
                        if let amount = parsedMeasuredIngredient.amount {
                            Text(amount)
                                .font(.custom(Constants.FontName.heavy, size: 14.0))
                                .foregroundStyle(Colors.foregroundText)
                        }
                        if let fraction = parsedMeasuredIngredient.fraction {
                            Text(fraction)
                                .font(.custom(Constants.FontName.heavy, size: 14.0))
                                .foregroundStyle(Colors.foregroundText)
                        }
                        Text(parsedMeasuredIngredient.abbreviatedMeasurementArray[parsedMeasuredIngredient.abbreviatedMeasurementIndex].abbreviation)
                            .font(.custom(Constants.FontName.heavy, size: 14.0))
                            .foregroundStyle(Colors.foregroundText)
                        Text(parsedMeasuredIngredient.ingredient)
                            .font(.custom(Constants.FontName.body, size: 14.0))
                            .foregroundStyle(Colors.foregroundText)
                            .multilineTextAlignment(.leading)
                    } else {
                        Text(LocalizedStringKey(measuredIngredient.nameAndAmountModified ?? measuredIngredient.nameAndAmount ?? ""))
                            .font(.custom(Constants.FontName.body, size: 14.0))
                            .foregroundStyle(Colors.foregroundText)
                            .multilineTextAlignment(.leading)
                    }
                }
//                .opacity(isExpanded ? 1.0 : 0.5)
                .padding(.vertical, isExpanded ? 6.0 : 0.0)
                .padding(.horizontal)
                .background(
                    RoundedRectangle(cornerRadius: 28.0)
                        .fill(backgroundFillColor)
                        .opacity(isExpanded ? 1.0 : 0.0)
                )
            }
            .disabled(isDisabled || !isExpanded)
        }
        .onChange(of: measuredIngredient.nameAndAmount) { _ in
            parsedMeasuredIngredient = MeasurementIngredientParser.parseFirstMeasurement(from: measuredIngredient.nameAndAmountModified ?? measuredIngredient.nameAndAmount ?? "", leastToGreatestPossibleFractionValues: MeasuredIngredientPickerView.defaultMinToMaxFractionStrings)
        }
        .onChange(of: measuredIngredient.nameAndAmountModified) { _ in
            parsedMeasuredIngredient = MeasurementIngredientParser.parseFirstMeasurement(from: measuredIngredient.nameAndAmountModified ?? measuredIngredient.nameAndAmount ?? "", leastToGreatestPossibleFractionValues: MeasuredIngredientPickerView.defaultMinToMaxFractionStrings)
        }
    }
    
}

@available(iOS 17.0, *)
#Preview(traits: .sizeThatFitsLayout) {
    let context = CDClient.mainManagedObjectContext
    
    let measuredIngredient = RecipeMeasuredIngredient(context: context)
    measuredIngredient.nameAndAmount = "Name and Amount"
    
    try! context.save()
    
    return RecipeEditableIngredientView(
        measuredIngredient: measuredIngredient,
        isExpanded: .constant(true),
        isDisabled: .constant(false),
        onEdit: {
            
        }
    )
    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
//        .environmentObject(PremiumUpdater())
//      .environmentObject(ProductUpdater())
//          .environmentObject(RemainingUpdater())
}


RecipeOfTheDayView.swift
//
//  RecipeOfTheDayView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/29/24.
//

import SwiftUI

struct RecipeOfTheDayView: View {
    
    @ObservedObject var recipe: Recipe
    let timeFrame: TimeFrames
    let onReload: () -> Void
    
    enum TimeFrames: String, CaseIterable {
        case breakfast  =   "breakfast"
        case lunch      =   "lunch"
        case dinner     =   "dinner"
        
        // Used for display
        var displayString: String {
            switch self {
            case .breakfast: "Breakfast"
            case .lunch: "Lunch"
            case .dinner: "Dinner"
            }
        }
        
        // Used for sorting
        var sortOrder: Int {
            switch self {
            case .breakfast: 0
            case .lunch: 1
            case .dinner: 2
            }
        }
        
        private var hourRange: (start: Int, end: Int) {
            switch self {
            case .breakfast:
                return (start: 0, end: 10)     // 6:00 AM to 10:00 AM
            case .lunch:
                return (start: 10, end: 14)    // 11:00 AM to 2:00 PM
            case .dinner:
                return (start: 18, end: 24)    // 6:00 PM to 9:00 PM
            }
        }
        
        /// Checks if the current time is within the time range of the enum case
        func isTimeWithin(date: Date) -> Bool {
            let calendar = Calendar.current
            
            // Extract the current hour and minute
            let components = calendar.dateComponents([.hour], from: date)
            guard let hour = components.hour else {
                return false
            }
            
            // Convert current time to minutes since midnight
            let currentHours = hour
            
            // Get the start and end minutes for the time frame
            let range = self.hourRange
            
            return currentHours >= range.start && currentHours <= range.end
        }
        
        /// Returns the current time frame based on the current time
        static func timeFrame(for date: Date) -> TimeFrames? {
            let frames: [TimeFrames] = TimeFrames.allCases
            for frame in frames {
                if frame.isTimeWithin(date: date) {
                    return frame
                }
            }
            return nil
        }
    }
    
    @Environment(\.managedObjectContext) private var viewContext
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0.0) {
            HStack {
                // Timeframe
                Text(timeFrame.displayString)
                    .font(.custom(Constants.FontName.heavy, size: 24.0))
                
                Spacer()
            }
            .padding(.bottom, 12)
            
            Group {
                if let image = recipe.imageFromAppData {
                    Image(uiImage: image) // TODO: Fix image size and modifiers
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                } else {
                    ZStack {
                        Colors.background
                        ProgressView()
                            .tint(Colors.foregroundText)
                    }
                }
            }
            .clipShape(RoundedRectangle(cornerRadius: 14.0))
            .frame(height: 100.0)
            .padding(.bottom, 12)
            
            HStack(alignment: .top) {
                Text(recipe.name ?? "*No Title*")
                    .font(.custom(Constants.FontName.black, size: 17.0))
                    .multilineTextAlignment(.leading)
                Spacer()
//                    if let date = recipe.creationDate {
//                        Text(NiceDateFormatter.dateFormatter.string(from: date))
//                            .font(.custom(Constants.FontName.body, size: 12.0))
//                    }
            }
            
            if let summary = recipe.summary {
                HStack {
                    Text(summary)
                        .lineLimit(nil)
                        .fixedSize(horizontal: false, vertical: true)
                        .font(.custom(Constants.FontName.body, size: 14.0))
                        .multilineTextAlignment(.leading)
                    Spacer()
                }
            }
            
            Spacer()
            
            Text("View Recipe")
                .font(.custom(Constants.FontName.heavy, size: 17.0))
                .foregroundStyle(Colors.elementBackground)
                .frame(maxWidth: .infinity)
        }
        .overlay(alignment: .topTrailing) {
            VStack(spacing: 16.0) {
                // Add recipe button
                Button(action: {
                    Task {
                        do {
                            try await RecipeCDClient.updateRecipe(recipe, saved: !recipe.saved, in: viewContext)
                        } catch {
                            // TODO: Handle Errors
                            print("Error updating recipe dailyRecipe_isSavedToRecipes in RecipeOfTheDayView... \(error)")
                        }
                    }
                }) {
                    VStack {
                        Text(Image(systemName: recipe.saved ? "star.fill" : "star"))
                            .font(.body, 17.0)
                        Text(recipe.saved ? "Saved" : "Save")
                            .font(.heavy, 12.0)
                    }
//                    .padding(.vertical, 8)
//                    .padding(.horizontal)
                }
                .foregroundStyle(recipe.saved ? Colors.elementBackground : Colors.elementBackground)
                
                // Reload recipe button
                Button(action: onReload) {
                    VStack {
                        Text(Image(systemName: "square.stack"))
                            .font(.body, 17.0)
                        Text("Browse")
                            .font(.heavy, 12.0)
                    }
//                    .padding(.vertical, 8)
//                    .padding(.horizontal)
                }
                .foregroundStyle(Colors.elementBackground)
                
                // Share recipe button
                if let url = RecipeShareURLMaker.getShareURL(recipeID: Int(recipe.recipeID)) {
                    ShareLink(item: url) {
                        HStack {
                            VStack {
                                Text(Image(systemName: "square.and.arrow.up"))
                                    .font(.body, 17.0)
                                Text("Share")
                                    .font(.heavy, 12.0)
                            }
                        }
//                        .padding(.vertical, 8)
//                        .padding(.horizontal)
                    }
                    .foregroundStyle(Colors.elementBackground)
                }
            }
        }
    }
    
}

#Preview {
    
    RecipeOfTheDayView(
        recipe: try! CDClient.mainManagedObjectContext.fetch(Recipe.fetchRequest()).first!,
        timeFrame: .breakfast,
        onReload: {
            
        })
    .frame(height: 450.0)
    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
    
}


GADInterstitialViewControllerRepresentable.swift
//
//  GADBlankAdContainerViewController.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/17/23.
//

import GoogleMobileAds
import SwiftUI

class GADInterstitialCoordinator: NSObject, GADFullScreenContentDelegate {
    
    let interstitialID: String
    
    
    private var interstitial: GADInterstitialAd?
    
    init(interstitialID: String) {
        self.interstitialID = interstitialID
    }
    
    func loadAd() {
        GADInterstitialAd.load(
            withAdUnitID: interstitialID, request: GADRequest()
        ) { ad, error in
            self.interstitial = ad
            self.interstitial?.fullScreenContentDelegate = self
        }
    }
    
    func adDidDismissFullScreenContent(_ ad: GADFullScreenPresentingAd) {
        interstitial = nil
//        loadAd()
    }
    
    func ad(_ ad: GADFullScreenPresentingAd, didFailToPresentFullScreenContentWithError error: Error) {
        print(error)
    }
    
    func showAd(from viewController: UIViewController) {
        guard let interstitial = interstitial else {
//            loadAd()
            print("Ad wasn't ready")
            return
        }
        
        interstitial.present(fromRootViewController: viewController)
    }
}



GADBlankAdContainerViewController.swift
//
//  GADBlankAdContainerViewController.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 10/30/23.
//

import Foundation
import SwiftUI
import UIKit

struct GADBlankAdContainerViewController: UIViewControllerRepresentable {
    
    let viewController = UIViewController()
    
    func makeUIViewController(context: Context) -> some UIViewController {
        return viewController
    }
    
    func updateUIViewController(_ uiViewController: UIViewControllerType, context: Context) {}
}


GADBannerViewRepresentable.swift
////
////  GADBannerViewRepresentable.swift
////  Barback
////
////  Created by Alex Coundouriotis on 10/17/23.
////
//
//import GoogleMobileAds
//import SwiftUI
//
//private struct GADBannerViewRepresentable: UIViewControllerRepresentable {
//    @State private var viewWidth: CGFloat = .zero
//    private let bannerView = GADBannerView()
//    
//    func makeUIViewController(context: Context) -> some UIViewController {
//        let bannerViewController = BannerViewController()
//        bannerView.adUnitID = adUnitID
//        bannerView.rootViewController = bannerViewController
//        bannerView.delegate = context.coordinator
//        bannerView.translatesAutoresizingMaskIntoConstraints = false
//        bannerViewController.view.addSubview(bannerView)
//        // Constrain GADBannerView to the bottom of the view.
//        NSLayoutConstraint.activate([
//            bannerView.bottomAnchor.constraint(
//                equalTo: bannerViewController.view.safeAreaLayoutGuide.bottomAnchor),
//            bannerView.centerXAnchor.constraint(equalTo: bannerViewController.view.centerXAnchor),
//        ])
//        bannerViewController.delegate = context.coordinator
//        
//        return bannerViewController
//    }
//    
//    func updateUIViewController(_ uiViewController: UIViewControllerType, context: Context) {
//        guard viewWidth != .zero else { return }
//        
//        bannerView.adSize = GADCurrentOrientationAnchoredAdaptiveBannerAdSizeWithWidth(viewWidth)
//        bannerView.load(GADRequest())
//    }
//    
//    func makeCoordinator() -> Coordinator {
//        Coordinator(self)
//    }
//    
//    fileprivate class Coordinator: NSObject, BannerViewControllerWidthDelegate, GADBannerViewDelegate
//    {
//        let parent: GADBannerViewRepresentable
//        
//        init(_ parent: GADBannerViewRepresentable) {
//            self.parent = parent
//        }
//        
//        // MARK: - BannerViewControllerWidthDelegate methods
//        
//        func bannerViewController(
//            _ bannerViewController: BannerViewController, didUpdate width: CGFloat
//        ) {
//            parent.viewWidth = width
//        }
//        
//        // MARK: - GADBannerViewDelegate methods
//        
//        func bannerViewDidReceiveAd(_ bannerView: GADBannerView) {
//            print("DID RECEIVE AD")
//        }
//        
//        func bannerView(_ bannerView: GADBannerView, didFailToReceiveAdWithError error: Error) {
//            print("DID NOT RECEIVE AD: \(error.localizedDescription)")
//        }
//    }
//}
//
//protocol BannerViewControllerWidthDelegate: AnyObject {
//    func bannerViewController(_ bannerViewController: BannerViewController, didUpdate width: CGFloat)
//}
//
//class BannerViewController: UIViewController {
//    
//    weak var delegate: BannerViewControllerWidthDelegate?
//    
//    override func viewDidAppear(_ animated: Bool) {
//        super.viewDidAppear(animated)
//        
//        delegate?.bannerViewController(self, didUpdate: view.frame.inset(by: view.safeAreaInsets).size.width)
//    }
//    
//    override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
//        coordinator.animate { _ in
//            // do nothing
//        } completion: { _ in
//            self.delegate?.bannerViewController(self, didUpdate: self.view.frame.inset(by: self.view.safeAreaInsets).size.width)
//        }
//    }
//}


InterstitialView.swift
//
//  InterstitialView.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 10/31/23.
//

import SwiftUI

struct InterstitialView: View {
    
    var interstitialID: String
    var disabled: Bool
    @Binding var isPresented: Bool
    
    
//    init(interstitialID: String, disabled: Binding<Bool>, isPresented: Binding<Bool>) {
//        self._disabled = disabled
//        self._isPresented = isPresented
////        self.gadInterstitialCoodrinator = GADInterstitialCoordinator(interstitialID: interstitialID)
//    }
    
    @State private var gadInterstitialCoodrinator: GADInterstitialCoordinator?// = GADInterstitialCoordinator(interstitialID: interstitialID)
    @State private var gadInterstitialViewControllerRepresentable: GADBlankAdContainerViewController = GADBlankAdContainerViewController()
    
    var body: some View {
        ZStack {
            Color.clear
                .onAppear {
                    gadInterstitialCoodrinator = GADInterstitialCoordinator(interstitialID: interstitialID)
                    
                    if !disabled {
                        gadInterstitialCoodrinator?.loadAd()
                    }
                }
                .onChange(of: disabled, perform: { newValue in
                    if !newValue {
                        gadInterstitialCoodrinator?.loadAd()
                    }
                })
                .background(
                    gadInterstitialViewControllerRepresentable
                        .frame(width: .zero, height: .zero)
                )
                .onChange(of: isPresented, perform: { newValue in
                    if newValue && !disabled {
                        gadInterstitialCoodrinator?.showAd(from: gadInterstitialViewControllerRepresentable.viewController)
                    }
                    
                    isPresented = false
                    
//                    manager.loadAd()
                })
        }
        .frame(width: .zero, height: .zero)
//        ZStack {
//            
//        }
//        .interstitial(
//            disabled: $disabled,
//            isPresented: $isPresented,
//            manager: gadInterstitialCoodrinator,
//            adViewControllerRepresentable: gadInterstitialViewControllerRepresentable)
    }
    
}

extension View {
    
    func interstitialInBackground(interstitialID: String, disabled: Bool, isPresented: Binding<Bool>) -> some View {
        self
            .background(
                InterstitialView(
                    interstitialID: interstitialID,
                    disabled: disabled,
                    isPresented: isPresented)
            )
    }
    
}

//#Preview {
//    
//    struct ContentView: View {
//        
//        @State var isPresented: Bool = false
//        
//        var body: some View {
//            InterstitialView(
//                interstitialID: Keys.Ads.Interstitial.debug,
//                disabled: .constant(false),
//                isPresented: $isPresented)
//            .onAppear {
//                DispatchQueue.main.asyncAfter(deadline: .now() + 5.0, execute: {
//                    isPresented = true
//                })
//            }
//        }
//        
//    }
////    DispatchQueue.main.asyncAfter(deadline: .now() + 5.0, execute: {
////        isPresented = true
////    })
//    
//    return ContentView()
//}


View+KeyboardDismissingTextFieldToolbar.swift
//
//  View+KeyboardDismissingTextFieldToolbar.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/13/23.
//

import Foundation
import SwiftUI

extension View {
    
    func keyboardDismissingTextFieldToolbar(_ dismissButtonText: String, color: Color) -> some View {
        self
            .toolbar {
                ToolbarItemGroup(placement: .keyboard) {
                    Spacer()
                    
                    Button(action: {
                        KeyboardDismisser.dismiss()
                    }) {
                        Text(dismissButtonText)
                            .font(.custom(Constants.FontName.heavy, size: 17.0))
                            .foregroundStyle(color)
                    }
                }
            }
    }
    
}


AppButtonStyle.swift
//
//  AppButtonStyle.swift
//  SocialBackup
//
//  Created by Alex Coundouriotis on 10/11/24.
//

import SwiftUI

struct AppButtonStyle: ViewModifier {
    
    var foregroundColor: Color
    var backgroundColor: Color
    
    func body(content: Content) -> some View {
        content
            .font(.custom(Constants.FontName.heavy, size: 17.0))
            .foregroundStyle(foregroundColor)
            .padding()
            .background(backgroundColor)
            .clipShape(RoundedRectangle(cornerRadius: 14.0))
    }
    
}

extension View {
    
    public func appButtonStyle(foregroundColor: Color? = nil, backgroundColor: Color? = nil) -> some View {
        self
            .font(.custom(Constants.FontName.heavy, size: 17.0))
            .foregroundStyle(foregroundColor ?? Colors.elementText)
            .padding()
            .background(backgroundColor ?? Colors.elementBackground)
            .clipShape(Capsule())
    }
    
    public func miniButtonStyle(foregroundColor: Color? = nil, backgroundColor: Color? = nil) -> some View {
        self
            .font(.custom(Constants.FontName.heavy, size: 12.0))
            .foregroundStyle(foregroundColor ?? Colors.elementBackground)
            .padding(8)
            .background(backgroundColor ?? Colors.elementText)
            .clipShape(RoundedRectangle(cornerRadius: 14.0))
    }
    
//    public func tabButtonStyle(isSelected: Bool, namespace: Namespace) -> some View {
//        self
//            .font(.custom(Constants.FontName.body, size: isSelected ? 40.0 : 30.0))
//            .foregroundStyle(isSelected ? Colors.elementTextColor : Colors.elementBackgroundColor)
//            .background(
//                Group {
//                    if isSelected {
//                        Circle()
//                            .fill(Colors.elementBackgroundColor)
//                            .frame(width: 40.0)
//                            .matchedGeometryEffect(id: "activeCircle", in: namespace.wrappedValue)
//                    } else {
//                        Circle()
//                            .fill(Colors.elementTextColor)
//                            .frame(width: 20.0)
//                    }
//                })
//    }
    
}


PlaceholderTextEditor.swift
////
////  PlaceholderTextEditor.swift
////  Barback
////
////  Created by Alex Coundouriotis on 9/19/23.
////
//
//import Foundation
//import SwiftUI
//
//struct PlaceholderTextEditor: View {
//
//    let placeholder: String
//
//    let standardTextColor: Color = .accentColor
//    let placeholderTextColor: Color
//
//    @State public var text: String
//    @FocusState private var isEditing: Bool
//
//    init(placeholder: String, placeholderTextColor: Color) {
//        self.placeholder = placeholder
//        self.placeholderTextColor = placeholderTextColor
//
//        text = self.placeholder
//    }
//
//    var body: some View {
//        HStack {
//            TextField("Tap", text: $text, axis: .vertical)
//                .foregroundColor((text == placeholder && !isEditing) ? placeholderTextColor : standardTextColor)
//                .onTapGesture {
//                    if text == placeholder {
//                        text = ""
//                    }
//                }
//                .textFieldStyle(.roundedBorder)
//
//            TextField("", text: $text) {
//
//            }
//        }
//    }
//
//}
//
//
//struct PlaceholderTextEditor_PreviewProvider: PreviewProvider {
//    static var previews: some View {
//        PlaceholderTextEditor(placeholder: "asdf", placeholderTextColor: .gray)
//    }
//}


PremiumUpdater.swift
//
//  PremiumUpdater.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/7/23.
//

import Foundation
import SwiftUI

class PremiumUpdater: ObservableObject {
    
    @Published var isPremium: Bool = persistentIsPremium
    
    
    private static var persistentIsPremium: Bool {
        get {
#if DEBUG
            false
#else
            UserDefaults.standard.bool(forKey: Constants.UserDefaults.storedIsPremium)
#endif
        }
        set {
            UserDefaults.standard.set(newValue, forKey: Constants.UserDefaults.storedIsPremium)
        }
    }
    
    func registerTransaction(authToken: String, transactionID: UInt64) async throws {
        // Get isPremiumResponse from server with authToken and transactionID
        let isPremiumResponse = try await TransactionHTTPSConnector.registerTransaction(
            authToken: authToken,
            transactionID: transactionID)
        
        // Update with isPremium value
        update(isPremium: isPremiumResponse.body.isPremium)
    }
    
    func update(authToken: String) async throws {
        // Create authRequest
        let authRequest = AuthRequest(authToken: authToken)
        
        // Get isPremiumResponse from server
        let isPremiumResponse = try await ChefAppNetworkService.getIsPremium(request: authRequest)
        
        // Update with isPremium value
        update(isPremium: isPremiumResponse.body.isPremium)
    }
    
    private func update(isPremium: Bool) {
        // Set persistentIsPremium to isPremium and self.isPremium to persistentIsPremium
        PremiumUpdater.persistentIsPremium = isPremium
        
        DispatchQueue.main.async {
            self.isPremium = PremiumUpdater.persistentIsPremium
        }
    }
    
}


SillyCropView.swift
//
//  SillyCropView.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 2/1/23.
//

import UIKit

class SillyCropView: UIView {
    
    let borderWidth = 2.0
    let circleSize = 20
    
    let topView = RoundedView()
    
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }
    
    override func draw(_ rect: CGRect) {
        
        
//        let topLeftPath = UIBezierPath(ovalIn: )
//        let topRightPath = UIBezierPath(ovalIn: CGRect(x: Int(rect.maxX) + circleSize / 2, y: Int(rect.minY) - circleSize / 2, width: circleSize, height: circleSize))
//        let bottomLeftPath = UIBezierPath(ovalIn: CGRect(x: Int(rect.minX) - circleSize / 2, y: Int(rect.maxY) + circleSize / 2, width: circleSize, height: circleSize))
//        let bottomRightPath = UIBezierPath(ovalIn: CGRect(x: Int(rect.maxX) + circleSize / 2, y: Int(rect.maxY) + circleSize / 2, width: circleSize, height: circleSize))
//
//        let topLeftShapeLayer = CAShapeLayer()
//        let topRightShapeLayer = CAShapeLayer()
//        let bottomLeftShapeLayer = CAShapeLayer()
//        let bottomRightShapeLayer = CAShapeLayer()
//
//        topLeftShapeLayer.path = topLeftPath.cgPath
//        topRightShapeLayer.path = topRightPath.cgPath
//        bottomLeftShapeLayer.path = bottomLeftPath.cgPath
//        bottomRightShapeLayer.path = bottomRightPath.cgPath
//
//        topLeftShapeLayer.fillColor = Colors.aiChatTextColor.cgColor
//        topRightShapeLayer.fillColor = Colors.aiChatTextColor.cgColor
//        bottomLeftShapeLayer.fillColor = Colors.aiChatTextColor.cgColor
//        bottomRightShapeLayer.fillColor = Colors.aiChatTextColor.cgColor
//
//        topLeftShapeLayer.lineWidth = 3
//        topRightShapeLayer.lineWidth = 3
//        bottomLeftShapeLayer.lineWidth = 3
//        bottomRightShapeLayer.lineWidth = 3
//
//        topLeftShapeLayer.strokeColor = Colors.aiChatTextColor.cgColor
//        topRightShapeLayer.strokeColor = Colors.aiChatTextColor.cgColor
//        bottomLeftShapeLayer.strokeColor = Colors.aiChatTextColor.cgColor
//        bottomRightShapeLayer.strokeColor = Colors.aiChatTextColor.cgColor
//
//        layer.addSublayer(topLeftShapeLayer)
//        layer.addSublayer(topRightShapeLayer)
//        layer.addSublayer(bottomLeftShapeLayer)
//        layer.addSublayer(bottomRightShapeLayer)
        
        layer.borderWidth = borderWidth
        layer.borderColor = UIColor.darkGray.cgColor
    }
}


RoundedView.swift
//
//  RoundedView.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 1/9/23.
//

import UIKit

class RoundedView: UIView {
    
    @IBInspectable open var borderWidth: CGFloat = Constants.UI.borderWidth
    @IBInspectable open var borderColor: UIColor = UIColor(Colors.elementBackground)
    @IBInspectable open var cornerRadius: CGFloat = Constants.UI.cornerRadius
    
    override func draw(_ rect: CGRect) {
        layer.cornerRadius = cornerRadius
        layer.borderWidth = borderWidth
        layer.borderColor = borderColor.cgColor
        layer.masksToBounds = true
    }
}


RoundedButton.swift
//
//  RoundedButton.swift
//  ChitChat
//
//  Created by Alex Coundouriotis on 1/9/23.
//

import UIKit

class RoundedButton: UIButton {
        
    @IBInspectable open var hasArrow: Bool = false {
        didSet {
            if hasArrow {
                buttonArrowImageView = UIImageView()
//                buttonArrowImageView.image = UIImage.gifImageWithName("arrowGif")
                buttonArrowImageView.image = UIImage(systemName: "arrow.forward")
                buttonArrowImageView.tintColor = titleColor(for: state)
                buttonArrowImageView.alpha = 1.0
                
                addSubview(buttonArrowImageView)
            }
        }
    }
    
    @IBInspectable open var hasActivityView: Bool = false {
        didSet {
            if hasActivityView {
                activityView = UIActivityIndicatorView()
                activityView.style = .medium
                activityView.color = tintColor
                activityView.hidesWhenStopped = true
                activityView.stopAnimating()
                addSubview(activityView)
            }
        }
    }
    
    @IBInspectable open var hasCheckmark: Bool = false {
        didSet {
            if hasCheckmark {
                checkmark = UIImageView()
                checkmark.image = UIImage(systemName: "checkmark.circle")
                                
                addSubview(checkmark)
            }
        }
    }
    
    @IBInspectable open var filled: Bool = false
    @IBInspectable open var bigFont: Bool = false
    @IBInspectable open var borderWidth: CGFloat = Constants.UI.borderWidth
    @IBInspectable open var borderColor: UIColor = UIColor(Colors.elementBackground)

    @IBInspectable open var color: UIColor = UIColor(Colors.elementBackground) {
        didSet {
            buttonArrowImageView.tintColor = color
            activityView.color = color
            tintColor = color
        }
    }
    
    var buttonArrowImageView = UIImageView()
    var activityView = UIActivityIndicatorView()
    var checkmark = UIImageView()
    
    /* For arrow and activity view */
    let activityAccessoryWidth = 24.0
    let activityAccessoryHeight = 24.0
    
    let arrowAccessoryWidth = 30.0
    let arrowAccessoryHeight = 24.0
    
    let accessoryInset = 24.0
    
    
    // Only override draw() if you perform custom drawing.
    // An empty implementation adversely affects performance during animation.
    override func draw(_ rect: CGRect) {
        tintColor = color
        
        self.layer.cornerRadius = Constants.UI.cornerRadius
        self.layer.borderWidth = borderWidth
        self.layer.borderColor = borderColor.cgColor
        self.layer.masksToBounds = true
        self.clipsToBounds = true
        
        self.titleLabel?.numberOfLines = 1
//        if filled {
//            //TODO: - Make sure that the bottom button is separate from filled, maybe add a new IBInspectable?
//
//            self.tintColor = UIConstants.background
//            self.layer.borderColor = UIConstants.border.cgColor
//            self.layer.backgroundColor = UIConstants.border.cgColor
//            self.setTitleColor(UIConstants.textColor, for: .disabled)
//            self.setTitleColor(UIConstants.background, for: .normal)
//        } else {
//            self.tintColor = UIConstants.textColor
//            self.layer.borderColor = UIConstants.border.cgColor
//            self.setTitleColor(UIConstants.background, for: .normal)
//            self.setTitleColor(UIConstants.background, for: .selected)
//        }
        
        if bigFont {
            let font = UIFont(name: Constants.FontName.black, size: 25.0)
            self.setAttributedTitle(NSAttributedString(string: self.titleLabel?.text ?? "", attributes: [.font: font!]), for: .normal)
        }
        
        if hasActivityView {
            activityView.frame = CGRect(x: frame.size.width - (activityAccessoryWidth / 2) - accessoryInset, y: (frame.size.height - activityAccessoryHeight) / 2, width: activityAccessoryWidth, height: activityAccessoryHeight)
        }
        
        if hasArrow {
            buttonArrowImageView.frame = CGRect(x: frame.size.width - (arrowAccessoryWidth / 2) - accessoryInset, y: (frame.size.height - arrowAccessoryHeight) / 2, width: arrowAccessoryWidth, height: arrowAccessoryHeight)
            
            buttonArrowImageView.tintColor = titleColor(for: state)
        }
        
        if hasCheckmark {
            let height = frame.size.height - 24
            checkmark.frame = CGRect(x: 24 / 2, y: 24 / 2, width: height, height: height)
        }
            
        self.addTarget(self, action: #selector(self.bounce(sender:)), for: .touchDown)
        self.addTarget(self, action: #selector(self.bounce(sender:)), for: .touchDragInside)
        self.addTarget(self, action: #selector(self.bounceRelease(sender:)), for: .touchCancel)
        self.addTarget(self, action: #selector(self.bounceRelease(sender:)), for: .touchDragOutside)
        self.addTarget(self, action: #selector(self.bounceRelease(sender:)), for: .touchUpInside)
    }
    
    @objc private func bounce(sender: UIButton) {
        // Do haptic
        HapticHelper.doLightHaptic()
        
        // Animate button bounce
        UIView.animate(withDuration: 0.15, delay: 0, usingSpringWithDamping: 0.2, initialSpringVelocity: 0.5, options: .curveEaseIn, animations: {
            sender.transform = CGAffineTransform(scaleX: 0.92, y: 0.92)
        }) { (_) in
            
        }
    }
    
    @objc private func bounceRelease(sender: UIButton) {
        // Animate button unbounce
        UIView.animate(withDuration: 0.4, delay: 0, usingSpringWithDamping: 0.4, initialSpringVelocity: 2, options: .curveEaseIn, animations: {
            sender.transform = CGAffineTransform(scaleX: 1, y: 1)
        }, completion: nil)
    }
    
    func startAnimatingActivityView() {
        // Check if there is an arrow and if so hide it until stopAnimatingActivityView is called
        DispatchQueue.main.async {
            if self.hasArrow {
                UIView.animate(withDuration: 0.4, animations: {
                    self.buttonArrowImageView.alpha = 0.0
                }, completion: { boolean in
                    UIView.animate(withDuration: 0.4, animations: {
                        self.activityView.startAnimating()
                    })
                })
            } else {
                self.activityView.startAnimating()
            }
        }
        
    }
    
    func stopAnimatingActivityView() {
        // Check if there is an arrow and if so unhide it
        DispatchQueue.main.async {
            if self.hasArrow {
                UIView.animate(withDuration: 0.4, animations: {
                    self.activityView.stopAnimating()
                }, completion: { boolean in
                    UIView.animate(withDuration: 0.4, animations: {
                        self.buttonArrowImageView.alpha = 1.0
                    })
                })
            } else {
                self.activityView.stopAnimating()
            }
        }
    }
}



RemainingUpdater.swift
//
//  RemainingUpdater.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/7/23.
//

import Foundation

class RemainingUpdater: ObservableObject {
    
    @Published var remaining: Int? = persistentRemaining
    
    
    private static var persistentRemaining: Int {
        get {
            UserDefaults.standard.integer(forKey: Constants.UserDefaults.storedRecipesRemaining)
        }
        set {
            UserDefaults.standard.set(newValue, forKey: Constants.UserDefaults.storedRecipesRemaining)
        }
    }
    
    func set(recipesRemaining: Int) {
        RemainingUpdater.persistentRemaining = recipesRemaining
        
        DispatchQueue.main.async {
            self.remaining = recipesRemaining
        }
    }
    
    func update(authToken: String) async throws {
        // Build authRequest
        let authRequest = AuthRequest(authToken: authToken)
        
        // Do request
        let remainingResponse = try await ChefAppNetworkService.getRemaining(request: authRequest)
        
        // Set persistentRemaining to response remainingDrinks
        set(recipesRemaining: remainingResponse.body.remaining)
    }
    
}


LogoToolbarItem.swift
//
//  LogoToolbarItem.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/11/23.
//

import SwiftUI

struct LogoToolbarItem: ToolbarContent {
    
    @State var foregroundColor: Color = Colors.elementText
    
    var body: some ToolbarContent {
        ToolbarItem(placement: .principal) {
            Image(Constants.ImageName.navBarLogoImage)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(width: 140.0)
                .foregroundStyle(foregroundColor)
        }
    }
    
}

#Preview {
    ZStack {
        
    }
    .toolbar {
        LogoToolbarItem()
    }
}


UltraToolbarItem.swift
//
//  UltraToolbarItem.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/11/23.
//

import SwiftUI

struct UltraToolbarItem: ToolbarContent {
    
    @State var trailingPadding: CGFloat = -8
    let color: Color
        
    var body: some ToolbarContent {
        ToolbarItem(placement: .topBarTrailing) {
            UltraButton(
                color: color,
                sparkleDiameter: 19.0,
                fontSize: 14.0,
                cornerRadius: 8.0,
                horizontalSpacing: 2.0,
                innerPadding: 4.0)
//                lineWidth: 1.5)
                .padding(.trailing, trailingPadding)
        }
    }
    
}

#Preview {
    
    ZStack {
        
    }
    .toolbar {
        UltraToolbarItem(color: Colors.elementBackground)
    }
    
}


KeyboardResponder.swift
//
//  KeyboardResponder.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/20/23.
//

import Foundation
import SwiftUI

final class KeyboardResponder: ObservableObject {
    private var notificationCenter: NotificationCenter
    @Published private(set) var currentHeight: CGFloat = 0

    init(center: NotificationCenter = .default) {
        notificationCenter = center
        notificationCenter.addObserver(self, selector: #selector(keyboardWillShow(notification:)), name: UIResponder.keyboardWillShowNotification, object: nil)
        notificationCenter.addObserver(self, selector: #selector(keyboardWillHide(notification:)), name: UIResponder.keyboardWillHideNotification, object: nil)
    }

    deinit {
        notificationCenter.removeObserver(self)
    }
    
    @objc func keyboardWillShow(notification: Notification) {
        if let keyboardSize = (notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue {
            // TODO: Did this bc I got this error - Publishing changes from within view updates is not allowed, this will cause undefined behavior.
            DispatchQueue.main.async {
                self.currentHeight = keyboardSize.height
            }
        }
    }

    @objc func keyboardWillHide(notification: Notification) {
        // TODO: Did this bc I got this error - Publishing changes from within view updates is not allowed, this will cause undefined behavior.
        DispatchQueue.main.async {
            self.currentHeight = 0
        }
    }
}


ColorUpdater.swift
////
////  ColorUpdater.swift
////  Barback
////
////  Created by Alex Coundouriotis on 10/5/23.
////
//
//import Foundation
//import SwiftUI
//
//class ColorUpdater: ObservableObject {
//    
//    @Published var elementColor: Color
//    @Published var totalColor: Color
//    @Published var mostRecentColor: Color
//    @Published var shortPeriodColor: Color
//    @Published var mediumPeriodColor: Color
//    @Published var longPeriodColor: Color
//    
//    var elementColorOverrideSettingState: ElementColorOverrideSettingState {
//        get {
//            // Get from persistent element color override setting state
//            ColorUpdater.persistentElementColorOverrideSettingState
//        }
//        set {
//            // Set persistentElementColorOverrideSettingState to newValue and update element color
//            ColorUpdater.persistentElementColorOverrideSettingState = newValue
//            
//            updateElementColor()
//        }
//    }
//    
//    private static var persistentElementColor: Color {
//        switch ColorUpdater.persistentElementColorOverrideSettingState {
//        case .auto:
//            ColorUpdater.getColorFromUserDefaults(userDefaultsSuffix: ColorUpdater.autoElementColorUserDefaultsSuffix)
//        case .red:
//            ColorUpdater.elementColors.mostlyRed
//        case .green:
//            ColorUpdater.elementColors.mostlyGreen
//        case .blue:
//            ColorUpdater.elementColors.mostlyBlue
//        }
//    }
//    
//    private static var persistentTotalColor: Color {
//        ColorUpdater.getColorFromUserDefaults(userDefaultsSuffix: totalColorUserDefaultsSuffix)
//    }
//    
//    private static var persistentMostRecentColor: Color {
//        ColorUpdater.getColorFromUserDefaults(userDefaultsSuffix: mostRecentColorUserDefaultsSuffix)
//    }
//    
//    private static var persistentShortPeriodColor: Color {
//        ColorUpdater.getColorFromUserDefaults(userDefaultsSuffix: shortPeriodColorUserDefaultsSuffix)
//    }
//    
//    private static var persistentMediumPeriodColor: Color {
//        ColorUpdater.getColorFromUserDefaults(userDefaultsSuffix: mediumPeriodColorUserDefaultsSuffix)
//    }
//    
//    private static var persistentLongPeriodColor: Color {
//        ColorUpdater.getColorFromUserDefaults(userDefaultsSuffix: longPeriodColorUserDefaultsSuffix)
//    }
//    
//    private static var persistentElementColorOverrideSettingState: ElementColorOverrideSettingState {
//        get {
//            // Get from userDeafults, using auto as default if either the string is nil or ElementColorOverrideSettingState is nil
//            ElementColorOverrideSettingState(rawValue: UserDefaults.standard.string(forKey: Constants.UserDefaults.elementColorOverrideSettingState) ?? ElementColorOverrideSettingState.auto.rawValue) ?? ElementColorOverrideSettingState.auto
//        }
//        set {
//            // Set userDefaults with rawValue of newValue
//            UserDefaults.standard.set(newValue.rawValue, forKey: Constants.UserDefaults.elementColorOverrideSettingState)
//        }
//    }
//    
//    private static let autoElementColorUserDefaultsSuffix = "AutoElementColor"
//    private static let totalColorUserDefaultsSuffix = ""
//    private static let mostRecentColorUserDefaultsSuffix = "MostRecent"
//    private static let shortPeriodColorUserDefaultsSuffix = "ShortPeriod"
//    private static let mediumPeriodColorUserDefaultsSuffix = "MediumPeriod"
//    private static let longPeriodColorUserDefaultsSuffix = "LongPeriod"
//    
//    private static let mostRecentDrinksAgo = 1
//    private static let shortPeriodDrinksAgo = 3
//    private static let mediumPeriodDrinksAgo = 7
//    private static let longPeriodDrinksAgo = 14
//    
//    private static let elementColors = (
//        mostlyRed: Color(Constants.Color.mostlyRed),
//        mostlyGreen: Color(Constants.Color.mostlyGreen),
//        mostlyBlue: Color(Constants.Color.mostlyBlue)
//    )
//    
//    enum ElementColorOverrideSettingState: String, CaseIterable {
//        case auto
//        case red
//        case green
//        case blue
//    }
//    
//    private var totalCount: Float {
//        UserDefaults.standard.float(forKey: Constants.UserDefaults.totalColorValues)
//    }
//    
//    private var totalRed: Float {
//        UserDefaults.standard.float(forKey: Constants.UserDefaults.totalRedValues)
//    }
//    
//    private var totalGreen: Float {
//        UserDefaults.standard.float(forKey: Constants.UserDefaults.totalGreenValues)
//    }
//    
//    private var totalBlue: Float {
//        UserDefaults.standard.float(forKey: Constants.UserDefaults.totalBlueValues)
//    }
//    
//    init() {
//        elementColor = ColorUpdater.persistentElementColor
//        totalColor = ColorUpdater.persistentTotalColor
//        mostRecentColor = ColorUpdater.persistentMostRecentColor
//        shortPeriodColor = ColorUpdater.persistentShortPeriodColor
//        mediumPeriodColor = ColorUpdater.persistentMediumPeriodColor
//        longPeriodColor = ColorUpdater.persistentLongPeriodColor
//    }
//    
//    func update() async throws {
//        var totalCount: Int = 0
//        var totalRed: Float = 0
//        var totalGreen: Float = 0
//        var totalBlue: Float = 0
//        var periodCount: Int = 0
//        var periodRed: Float = 0
//        var periodGreen: Float = 0
//        var periodBlue: Float = 0
//        
//        let fetchRequest = GlassGradientColor.fetchRequest()
//        fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \GlassGradientColor.drink?.updateDate, ascending: false)]
//        fetchRequest.predicate = NSPredicate(format: "%K = %d", #keyPath(GlassGradientColor.drink.saved), true)
//        
//        let fetchResults = try CDClient.mainManagedObjectContext.fetch(fetchRequest)
//        
//        for gradientColor in fetchResults {
//            
//            if let hexadecimal = gradientColor.hexadecimal, let color = Color(hex: hexadecimal), let components = color.cgColor?.components, components.count > 3 {
//                totalCount += 1
//                totalRed += Float(components[0])
//                totalGreen += Float(components[1])
//                totalBlue += Float(components[2])
//                
//                periodCount += 1
//                periodRed += Float(components[0])
//                periodGreen += Float(components[1])
//                periodBlue += Float(components[2])
//            }
//            
//            func resetPeriods() {
////                periodCount = 0
////                periodRed = 0
////                periodGreen = 0
////                periodBlue = 0
//            }
//            
//            if totalCount <= ColorUpdater.longPeriodDrinksAgo {
//                if totalCount <= ColorUpdater.mediumPeriodDrinksAgo {
//                    if totalCount <= ColorUpdater.shortPeriodDrinksAgo {
//                        if totalCount <= ColorUpdater.mostRecentDrinksAgo {
//                            ColorUpdater.saveColorsToUserDefaults(count: periodCount, red: periodRed, green: periodGreen, blue: periodBlue, suffix: ColorUpdater.mostRecentColorUserDefaultsSuffix)
//                            
//                            DispatchQueue.main.async {
//                                self.mostRecentColor = ColorUpdater.persistentMostRecentColor
//                            }
//                        }
//                        
//                        ColorUpdater.saveColorsToUserDefaults(count: periodCount, red: periodRed, green: periodGreen, blue: periodBlue, suffix: ColorUpdater.shortPeriodColorUserDefaultsSuffix)
//                        
//                        DispatchQueue.main.async {
//                            self.shortPeriodColor = ColorUpdater.persistentShortPeriodColor
//                        }
//                    }
//                    
//                    ColorUpdater.saveColorsToUserDefaults(count: periodCount, red: periodRed, green: periodGreen, blue: periodBlue, suffix: ColorUpdater.mediumPeriodColorUserDefaultsSuffix)
//                    
//                    DispatchQueue.main.async {
//                        self.mediumPeriodColor = ColorUpdater.persistentMediumPeriodColor
//                    }
//                }
//                
//                ColorUpdater.saveColorsToUserDefaults(count: periodCount, red: periodRed, green: periodGreen, blue: periodBlue, suffix: ColorUpdater.longPeriodColorUserDefaultsSuffix)
//                
//                DispatchQueue.main.async {
//                    self.longPeriodColor = ColorUpdater.persistentLongPeriodColor
//                }
//            }
//            
////            switch totalCount {
////            case mostRecentDrinksAgo:
////                saveColorsToUserDefaults(count: periodCount, red: periodRed, green: periodGreen, blue: periodBlue, suffix: mostRecentColorUserDefaultsSuffix)
////                resetPeriods()
////            case shortPeriodDrinksAgo:
////                saveColorsToUserDefaults(count: periodCount, red: periodRed, green: periodGreen, blue: periodBlue, suffix: shortPeriodColorUserDefaultsSuffix)
////                resetPeriods()
////            case mediumPeriodDrinksAgo:
////                saveColorsToUserDefaults(count: periodCount, red: periodRed, green: periodGreen, blue: periodBlue, suffix: mediumPeriodColorUserDefaultsSuffix)
////                resetPeriods()
////            case longPeriodDrinksAgo:
////                saveColorsToUserDefaults(count: periodCount, red: periodRed, green: periodGreen, blue: periodBlue, suffix: longPeriodColorUserDefaultsSuffix)
////                resetPeriods()
////            default:
////                continue
////            }
//        }
//        
//        ColorUpdater.saveColorsToUserDefaults(count: totalCount, red: totalRed, green: totalGreen, blue: totalBlue, suffix: ColorUpdater.totalColorUserDefaultsSuffix)
//        
//        DispatchQueue.main.async {
//            self.totalColor = ColorUpdater.persistentTotalColor
//        }
//        
//        // Save auto element color
//        ColorUpdater.parseSaveElementColor(red: totalRed, green: totalGreen, blue: totalBlue, suffix: ColorUpdater.autoElementColorUserDefaultsSuffix)
//        
//        print("about to update element color")
//        print(totalRed)
//        print(totalGreen)
//        print(totalBlue)
//        
//        // Update element color
//        updateElementColor()
//    }
//    
//    private static func getCount(userDefaultsSuffix: String) -> Int {
//        UserDefaults.standard.integer(forKey: Constants.UserDefaults.totalColorValues + userDefaultsSuffix)
//    }
//    
//    private static func getTotalRed(userDefaultsSuffix: String) -> Float {
//        UserDefaults.standard.float(forKey: Constants.UserDefaults.totalRedValues + userDefaultsSuffix)
//    }
//    
//    private static func getTotalGreen(userDefaultsSuffix: String) -> Float {
//        UserDefaults.standard.float(forKey: Constants.UserDefaults.totalGreenValues + userDefaultsSuffix)
//    }
//    
//    private static func getTotalBlue(userDefaultsSuffix: String) -> Float {
//        UserDefaults.standard.float(forKey: Constants.UserDefaults.totalBlueValues + userDefaultsSuffix)
//    }
//    
//    private static func getAveragedRed(userDefaultsSuffix: String) -> Float {
//        ColorUpdater.getTotalRed(userDefaultsSuffix: userDefaultsSuffix) / Float(ColorUpdater.getCount(userDefaultsSuffix: userDefaultsSuffix))
//    }
//    
//    private static func getAveragedGreen(userDefaultsSuffix: String) -> Float {
//        ColorUpdater.getTotalGreen(userDefaultsSuffix: userDefaultsSuffix) / Float(ColorUpdater.getCount(userDefaultsSuffix: userDefaultsSuffix))
//    }
//    
//    private static func getAveragedBlue(userDefaultsSuffix: String) -> Float {
//        ColorUpdater.getTotalBlue(userDefaultsSuffix: userDefaultsSuffix) / Float(ColorUpdater.getCount(userDefaultsSuffix: userDefaultsSuffix))
//    }
//    
//    private static func getColorFromUserDefaults(userDefaultsSuffix: String) -> Color {
//        Color(cgColor: CGColor(
//            red: CGFloat(ColorUpdater.getAveragedRed(userDefaultsSuffix: userDefaultsSuffix)),
//            green: CGFloat(ColorUpdater.getAveragedGreen(userDefaultsSuffix: userDefaultsSuffix)),
//            blue: CGFloat(ColorUpdater.getAveragedBlue(userDefaultsSuffix: userDefaultsSuffix)),
//            alpha: 1.0))
//    }
//    
//    private static func saveColorsToUserDefaults(count: Int, red: Float, green: Float, blue: Float, suffix: String) {
//        UserDefaults.standard.set(count, forKey: Constants.UserDefaults.totalColorValues + suffix)
//        UserDefaults.standard.set(red, forKey: Constants.UserDefaults.totalRedValues + suffix)
//        UserDefaults.standard.set(green, forKey: Constants.UserDefaults.totalGreenValues + suffix)
//        UserDefaults.standard.set(blue, forKey: Constants.UserDefaults.totalBlueValues + suffix)
//    }
//    
//    private static func parseSaveElementColor(red: Float, green: Float, blue: Float, suffix: String) {
//        // Update the element color based on the highest color value in the view, mostlyBlue for mostly blue and so on
//        if blue > green && blue > red {
//            saveColor(color: ColorUpdater.elementColors.mostlyBlue, suffix: suffix)
//        } else if green > red && green > blue {
//            saveColor(color: ColorUpdater.elementColors.mostlyGreen, suffix: suffix)
//        } else if red > blue && red > green {
//            saveColor(color: ColorUpdater.elementColors.mostlyRed, suffix: suffix)
//        } else {
//            saveColor(color: .orange, suffix: suffix)
//        }
//    }
//    
//    private static func saveColor(color: Color, suffix: String) {
//        // Save to User Defaults
//        if let components = UIColor(color).cgColor.components, components.count >= 3 {
//            let red = components[0]
//            let green = components[1]
//            let blue = components[2]
//            
//            self.saveColorsToUserDefaults(
//                count: 1,
//                red: Float(red),
//                green: Float(green),
//                blue: Float(blue),
//                suffix: ColorUpdater.autoElementColorUserDefaultsSuffix)
//            
//            print("Here")
//            print(red)
//            print(green)
//            print(blue)
//        }
//    }
//    
//    private func updateElementColor() {
//        DispatchQueue.main.async {
//            self.elementColor = ColorUpdater.persistentElementColor
//            
//            print("what")
//            print("e0: \(String(describing: self.elementColor.cgColor?.components![0]))")
//            print("e1: \(String(describing: self.elementColor.cgColor?.components![1]))")
//            print("e2: \(String(describing: self.elementColor.cgColor?.components![2]))")
//            
////            let appearance = UINavigationBarAppearance()
////            appearance.backgroundColor = UIColor(self.elementColor)
////            
////            UINavigationBar.appearance().standardAppearance = appearance
////            UINavigationBar.appearance().scrollEdgeAppearance = appearance
//        }
//    }
//    
//}


MeasuredIngredientPickerView.swift
//
//  MeasuredIngredientPickerView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 6/22/24.
//

import SwiftUI

struct MeasuredIngredientPickerView: View {
    
    @Binding var amount: String
    @Binding var fraction: String
    @Binding var abbreviatedMeasurement: AbbreviatedMeasurement
    
    static let defaultMinToMaxFractionStrings: [String] = [
        "",
        "1/8",
        "1/4",
        "1/2",
        "5/8",
        "3/4",
        "7/8"
    ]
    
    var body: some View {
        HStack(spacing: -15.0) {
            Picker("Amount", selection: $amount) {
                ForEach(Array(0...999).map({String($0)}), id: \.self) { amount in
                    Text("\(amount == "0" ? "" : amount)")
                        .font(.custom(Constants.FontName.black, size: 20.0))
                }
            }
            .frame(width: 70)
            .fixedSize(horizontal: false, vertical: true)
            .pickerStyle(.inline)
            
            Picker("Fraction", selection: $fraction) {
                ForEach(MeasuredIngredientPickerView.defaultMinToMaxFractionStrings, id: \.self) { fraction in
                    Text("\(fraction)")
                        .font(.custom(Constants.FontName.black, size: 20.0))
                }
            }
            .frame(width: 70)
            .fixedSize(horizontal: false, vertical: true)
            .pickerStyle(.inline)
            
            Picker("Measurement", selection: $abbreviatedMeasurement) {
                let allMeasurements = [Measurements.blankAbbreviatedMeasurement] + Measurements.allOrderedMeasurements.flatMap({$0})
                ForEach(allMeasurements, id: \.self) { orderedMeasurement in
//                                ForEach(orderedMeasurements, id: \.self) { item in
                    Text(orderedMeasurement.abbreviation)
                        .font(.custom(Constants.FontName.black, size: 20.0))
//                                }
                    
                    
                }
            }
            .frame(width: 70)
            .pickerStyle(.inline)
        }
    }
    
}

#Preview {
    
    MeasuredIngredientPickerView(
        amount: .constant("1"),
        fraction: .constant("1/2"),
        abbreviatedMeasurement: .constant(AbbreviatedMeasurement(abbreviation: "in", alternatives: ["m"]))
    )
    
}


View+TextFieldTickerTint.swift
//
//  View+TextFieldTickerTint.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/13/23.
//

import Foundation
import SwiftUI

extension View {
    
    func textFieldTickerTint(_ color: Color) -> some View {
        self
            .colorMultiply(color) // Added to change ticker color
    }
    
}


View+CapReachedErrorAlert.swift
//
//  View+CapReachedErrorAlert.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/8/23.
//

import Foundation
import SwiftUI

extension View {
    
    func capReachedErrorAlert(isPresented: Binding<Bool>, isShowingUltraView: Binding<Bool>) -> some View {
        self
            .alert("Out of Recipes", isPresented: isPresented, actions: {
                Button("Close", role: .cancel, action: {
                    
                })
                
                Button("Upgrade", role: nil, action: {
                    withAnimation {
                        isShowingUltraView.wrappedValue = true
                    }
                })
            }) {
                switch Int.random(in: 0..<2) {
                case 0:
                    Text("It takes a lot of resources to generate recipes. Please support the developer and upgrade to keep creating. Bon-Apetit'!")
                default:
                    Text("You are out of recipes for today. Please upgrade to continue creating.")
                }
            }
            .onChange(of: isPresented.wrappedValue) { newValue in
                // If newValue is set to true do a warning haptic
                if newValue {
                    HapticHelper.doWarningHaptic()
                }
            }
    }
    
}


View+UltraViewPopover.swift
//
//  View+UltraViewPopover.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/8/23.
//

import Foundation
import SwiftUI

extension View {
    
    func ultraViewPopover(isPresented: Binding<Bool>) -> some View {
        self
            .fullScreenCover(isPresented: isPresented) {
                UltraView(isShowing: isPresented)
            }
    }
    
}


View+Header.swift
//
//  View+Header.swift
//  Barback
//
//  Created by Alex Coundouriotis on 10/8/23.
//

import Foundation
import SwiftUI

extension View {
    
    func chefAppHeader<LeftContent: View, RightContent: View>(titleColor: Color = Colors.foreground, backgroundColor: Color = Colors.secondaryBackground, showsDivider: Bool, @ViewBuilder left: ()->LeftContent, @ViewBuilder right: ()->RightContent) -> some View {
        VStack(spacing: 0.0) {
            ZStack {
                HStack {
                    VStack {
                        Spacer()
                        left()
                    }
                    Spacer()
                }
                
                HStack {
                    Spacer()
                    VStack(spacing: 0.0) {
                        Spacer()
                        Image(Constants.ImageName.navBarLogoImage)
                            .resizable()
                            .renderingMode(.template)
                            .aspectRatio(contentMode: .fit)
                            .foregroundStyle(Colors.navigationItemColor)
                            .frame(width: 140.0)
                            .padding(.bottom, 6)
                        if showsDivider {
                            Divider()
                                .tint(Colors.foregroundText)
                        }
                    }
                    Spacer()
                }
                
                HStack {
                    Spacer()
                    VStack {
                        Spacer()
                        right()
                    }
                }
            }
            .frame(height: 100)
            .background(backgroundColor)
            
            self
        }
    }
    
}


#Preview {
    
    ZStack {
        Colors.background
    }
    .chefAppHeader(
        showsDivider: true,
        left: {
        
    },
        right: {
        
    })
    .ignoresSafeArea()
    
}


BounceableModifier.swift
//
//  Bounceable.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/25/23.
//

import Foundation
import SwiftUI

struct BounceableModifier: ViewModifier {
    
    @State var isDisabled: Bool
    
    
    @State private var isPressed: Bool = false
    
    func body(content: Content) -> some View {
        content
            .scaleEffect(isPressed ? 0.9 : 1.0)
            .opacity(isPressed ? 0.8 : 1.0)
            .onPressReleaseGesture(onPress: {
                // Ensure not disabled, otherwise return
                guard !isDisabled else {
                    return
                }
                
                // Ensure not pressed, otherwise return
                guard !isPressed else {
                    return
                }
                
                // Do light haptic
                HapticHelper.doLightHaptic()
                
                // Set isPressed to true with animation
                withAnimation {
                    isPressed = true
                }
            }, onRelease: {
                // Ensure pressed, otherwise return
                guard isPressed else {
                    return
                }
                
                // Set isPressed to false with animation
                withAnimation {
                    isPressed = false
                }
            }, content: content)
    }
    
}

extension View {
    
    func bounceable(disabled: Bool = false) -> some View {
        modifier(BounceableModifier(isDisabled: disabled))
    }
    
}


OnPressReleaseGestureModifier.swift
//
//  ButtonStateModifier.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/25/23.
//

import Foundation
import SwiftUI

struct OnPressReleaseGestureModifier: ViewModifier {
    
    var onPress: () -> Void
    var onRelease: () -> Void
    
    func body(content: Content) -> some View {
        content
            .simultaneousGesture(DragGesture(minimumDistance: 0.0)
                .onChanged({ dragValue in
                    onPress()
                })
                .onEnded({ dragValue in
                    onRelease()
                }))
    }
    
}

extension View {
    
    public func onPressReleaseGesture<C>(onPress: @escaping ()->Void, onRelease: @escaping ()->Void, content: C) -> some View {
        modifier(OnPressReleaseGestureModifier(onPress: onPress, onRelease: onRelease))
    }
    
}


CardModifier.swift
//
//  CardModifier.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/21/23.
//

import SwiftUI

struct CardModifier: ViewModifier {
    
    var backgroundColor: Color = Colors.foreground
    
    func body(content: Content) -> some View {
        content
            .padding()
            .background(backgroundColor)
            .clipShape(RoundedRectangle(cornerRadius: 14.0))
    }
    
}

extension View {
    
    public func card() -> some View {
        modifier(CardModifier(backgroundColor: .black))
    }
    
}


ContentViewWithCollapsableHeader.swift
// https://gist.github.com/JohnSundell/341f5855f4ede71a7741e99881c74daf

import SwiftUI

/// View that observes its position within a given coordinate space,
/// and assigns that position to the specified Binding.
struct PositionObservingView<Content: View>: View {
    var coordinateSpace: CoordinateSpace
    @Binding var position: CGPoint
    @ViewBuilder var content: () -> Content

    var body: some View {
        content()
            .background(GeometryReader { geometry in
                Color.clear.preference(
                    key: PreferenceKey.self,
                    value: geometry.frame(in: coordinateSpace).origin
                )
            })
            .onPreferenceChange(PreferenceKey.self) { position in
                self.position = position
            }
    }
}

private extension PositionObservingView {
    enum PreferenceKey: SwiftUI.PreferenceKey {
        static var defaultValue: CGPoint { .zero }

        static func reduce(value: inout CGPoint, nextValue: () -> CGPoint) {
            // No-op
        }
    }
}

/// Specialized scroll view that observes its content offset (scroll position)
/// and assigns it to the specified Binding.
struct OffsetObservingScrollView<Content: View>: View {
    var axes: Axis.Set = [.vertical]
    var showsIndicators = true
    @Binding var offset: CGPoint
    @ViewBuilder var content: () -> Content

    private let coordinateSpaceName = UUID()

    var body: some View {
        ScrollView(axes, showsIndicators: showsIndicators) {
            PositionObservingView(
                coordinateSpace: .named(coordinateSpaceName),
                position: Binding(
                    get: { offset },
                    set: { newOffset in
                        offset = CGPoint(
                            x: -newOffset.x,
                            y: -newOffset.y
                        )
                    }
                ),
                content: content
            )
        }
        .coordinateSpace(name: coordinateSpaceName)
    }
}

///// View that renders scrollable content beneath a header that
///// automatically collapses when the user scrolls down.
//struct ContentView<Content: View>: View {
//    var title: String
//    var headerGradient: Gradient
//    @ViewBuilder var content: () -> Content
//
//    private let headerHeight = (collapsed: 50.0, expanded: 150.0)
//    @State private var scrollOffset = CGPoint()
//
//    var body: some View {
//        GeometryReader { geometry in
//            OffsetObservingScrollView(offset: $scrollOffset) {
//                VStack(spacing: 0) {
//                    makeHeaderText(collapsed: false)
//                    content()
//                }
//            }
//            .overlay(alignment: .top) {
//                makeHeaderText(collapsed: true)
//                    .background(alignment: .top) {
//                        headerLinearGradient.ignoresSafeArea()
//                    }
//                    .opacity(collapsedHeaderOpacity)
//            }
//            .background(alignment: .top) {
//                // We attach the expanded header's background to the scroll
//                // view itself, so that we can make it expand into both the
//                // safe area, as well as any negative scroll offset area:
//                headerLinearGradient
//                    .frame(height: max(0, headerHeight.expanded - scrollOffset.y) + geometry.safeAreaInsets.top)
//                    .ignoresSafeArea()
//            }
//        }
//    }
//}
//
//private extension ContentView {
//    var collapsedHeaderOpacity: CGFloat {
//        let minOpacityOffset = headerHeight.expanded / 2
//        let maxOpacityOffset = headerHeight.expanded - headerHeight.collapsed
//
//        guard scrollOffset.y > minOpacityOffset else { return 0 }
//        guard scrollOffset.y < maxOpacityOffset else { return 1 }
//
//        let opacityOffsetRange = maxOpacityOffset - minOpacityOffset
//        return (scrollOffset.y - minOpacityOffset) / opacityOffsetRange
//    }
//
//    var headerLinearGradient: LinearGradient {
//        LinearGradient(
//            gradient: headerGradient,
//            startPoint: .top,
//            endPoint: .bottom
//        )
//    }
//
//    func makeHeaderText(collapsed: Bool) -> some View {
//        Text(title)
//            .font(collapsed ? .body : .title)
//            .lineLimit(1)
//            .padding()
//            .frame(height: collapsed ? headerHeight.collapsed : headerHeight.expanded)
//            .frame(maxWidth: .infinity)
//            .foregroundColor(.white)
//            .accessibilityHeading(.h1)
//            .accessibilityHidden(collapsed)
//    }
//}


PostContainer.swift
//
//  PostContainer.swift
//  SocialBackup
//
//  Created by Alex Coundouriotis on 10/11/24.
//

import AVKit
import SwiftUI

// Custom PreferenceKey to track scroll offset
struct ScrollOffsetPreferenceKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value += nextValue()
    }
}

struct PostContainer: View {
    let tikTokSearchResponseItem: TikTokSearchResponse.Item  // Using Item from TikTokSearchResponse
    let videoLinkHeaders: TikTokSearchResponse.VideoLinkHeaders
    @Binding var isPresented: Bool

    @State private var translation: CGFloat = 0
    @State private var scrollOffset: CGFloat = 0
    @State private var initialDragGestureScrollOffset: CGFloat?

    @State private var isShowingAddToCollection: Bool = false

    @State private var player: AVPlayer?

    var body: some View {
        GeometryReader { geometry in
            ScrollView {
                VStack(spacing: 0.0) {
                    // Reference view to track scroll offset
                    Color.clear
                        .frame(height: 0)
                        .background(
                            GeometryReader { inner in
                                Color.clear.preference(key: ScrollOffsetPreferenceKey.self, value: inner.frame(in: .global).origin.y)
                            }
                        )
                        .overlay(alignment: .topTrailing) {
                            Button(action: { isPresented = false }) {
                                Image(systemName: "xmark")
                                    .font(.body, 17.0)
                                    .foregroundStyle(Colors.elementBackground)
                            }
                        }

                    VStack {
                        // Video Content
                        if let player {
                            VideoPlayer(player: player)
                                .frame(height: geometry.size.height)
                        } else {
                            Text("Unable to load video")
                        }

                        VStack {
                            PostStatsContainer(tikTokSearchResponseItem: tikTokSearchResponseItem)
                            Spacer(minLength: 100.0)
                        }
                        .background(Colors.background)
                    }
                }
            }
            .background(.black)
            .onPreferenceChange(ScrollOffsetPreferenceKey.self) { value in
                // Update scroll offset
                DispatchQueue.main.async {
                    self.scrollOffset = value
                }
            }
            .offset(y: self.translation)
            .simultaneousGesture(
                DragGesture()
                    .onChanged { value in
                        if initialDragGestureScrollOffset == nil {
                            initialDragGestureScrollOffset = scrollOffset
                        }

                        let totalHeight = value.translation.height + (self.initialDragGestureScrollOffset ?? 0.0)
                        if totalHeight > 0 {
                            // Update translation only if dragging down and at top
                            self.translation = totalHeight
                        }
                    }
                    .onEnded { value in
                        initialDragGestureScrollOffset = nil

                        if self.translation > 100 {
                            // Dismiss the view when dragged down sufficiently
                            withAnimation {
                                self.isPresented = false
                            }
                        } else {
                            // Animate back to original position
                            withAnimation {
                                self.translation = 0
                            }
                        }
                    }
            )
        }
        .ignoresSafeArea()
        .onAppear {
            // Prepare player
            if let playURLString = tikTokSearchResponseItem.video?.playAddr,
               let playURL = URL(string: playURLString) {

                // Prepare HTTP headers
                var headers = [String: String]()

                // Get the cookie from the response
                if let cookie = videoLinkHeaders.cookie {
                    headers["Cookie"] = cookie
                }

//                // Optional: Add other headers if required (e.g., "User-Agent", "Referer", etc.)
//                if let referer = videoLinkHeaders.referer {
//                    headers["Referer"] = referer
//                }
//
//                if let origin = videoLinkHeaders.origin {
//                    headers["Origin"] = origin
//                }

                // Create AVURLAsset with custom headers
                let asset = AVURLAsset(url: playURL, options: ["AVURLAssetHTTPHeaderFieldsKey": headers])

                // Create AVPlayerItem
                let playerItem = AVPlayerItem(asset: asset)

                // Create AVPlayer
                self.player = AVPlayer(playerItem: playerItem)

                // Start playing
                self.player?.play()
            }
        }
        .onDisappear {
            self.player?.pause()
        }
        // .addPostToCollectionFullScreenCover(isPresented: $isShowingAddToCollection, post: post) // Adjust or remove as needed
    }
}


TikTokSearchGenerator.swift
//
//  TikTokSearchGenerator.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/3/24.
//

import Foundation

class TikTokSearchGenerator: ObservableObject {
    
    @Published var isLoading: Bool = false
    @Published var nextCursor: String?
    
    func search(authToken: String, category: TikTokSearchRequest.Category, query: String) async throws -> TikTokSearchResponse {
        await MainActor.run { nextCursor = nil }
        
        return try await executeSearch(
            authToken: authToken,
            category: category,
            query: query,
            nextCursor: nil)
    }
    
    func nextPage(authToken: String, category: TikTokSearchRequest.Category, query: String) async throws -> TikTokSearchResponse {
        guard let nextCursor else {
            throw TikTokSearchGeneratorError.nilCursor
        }
        
        return try await executeSearch(
            authToken: authToken,
            category: category,
            query: query,
            nextCursor: nextCursor)
    }
    
    private func executeSearch(authToken: String, category: TikTokSearchRequest.Category, query: String, nextCursor: String?) async throws -> TikTokSearchResponse {
        return try await ChefAppNetworkService.tikTokSearch(
            request: TikTokSearchRequest(
                authToken: authToken,
                category: category,
                query: query,
                nextCursor: nextCursor))
    }
    
}


TikTokSearchCardsContainer.swift
//
//  TikTokSearchCardsContainer.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/3/24.
//

import SwiftUI

struct TikTokSearchCardsContainer: View {
    
    let query: String
    let height: CGFloat
    let maxCardWidth: CGFloat
    @ObservedObject var tikTokSearchGenerator: TikTokSearchGenerator
    @Binding var tikTokSearchResponse: TikTokSearchResponse?
    
//    @StateObject private var tikTokSearchGenerator = TikTokSearchGenerator()
//    
//    @State private var tikTokSearchResponse: TikTokSearchResponse?
    
    var body: some View {
        Group {
            if let tikTokSearchResponse {
                TikTokSearchCardsView(
                    tikTokSearchResponse: tikTokSearchResponse,
                    maxCardWidth: maxCardWidth)
                .frame(height: height)
            } else {
                ProgressView()
            }
        }
        .task {
            // Ensure tikTokSearchResponse is nil, otherwise return
            guard tikTokSearchResponse == nil else {
                return
            }
            
            // Ensure authToken
            let authToken: String
            do {
                authToken = try await AuthHelper.ensure()
            } catch {
                // TODO: Handle Errors
                print("Error ensuring authToken in TikTokSearchCardscontainer... \(error)")
                return
            }
            
            // Get search response
            do {
                tikTokSearchResponse = try await tikTokSearchGenerator.search(
                    authToken: authToken,
                    category: .videos,
                    query: query)
                print("Hi")
            } catch {
                // TODO: Handle Errors
                print("Error getting tikTokSearchResponse in TikTokSearchCardsContainer... \(error)")
            }
        }
    }
    
}

#Preview {
    
    TikTokSearchCardsContainer(
        query: "lilyachty",
        height: 100.0,
        maxCardWidth: 240.0,
        tikTokSearchGenerator: TikTokSearchGenerator(),
        tikTokSearchResponse: .constant(nil))
    
}


TikTokSearchCardView.swift
//
//  TikTokSearchCardView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/3/24.
//

import SwiftUI

struct TikTokSearchCardView: View {
    
    let tikTokSearchResponseItem: TikTokSearchResponse.Item
    let videoLinkHeaders: TikTokSearchResponse.VideoLinkHeaders
    let justVideos: Bool
    
    @State private var isPresentingVideo = false
    
    var body: some View {
        VStack(alignment: .leading) {
            // Video Cover Image
            if let coverURLString = tikTokSearchResponseItem.video?.cover, let coverURL = URL(string: coverURLString) {
                AsyncImage(url: coverURL) { image in
                    image.resizable()
                         .aspectRatio(contentMode: .fit)
                } placeholder: {
                    Color.gray.opacity(0.3)
                }
//                .frame(width: 200, height: 300)
                .clipped()
                .cornerRadius(14)
                .onTapGesture {
                    isPresentingVideo = true
                }
                // Present the full-screen video view
                .fullScreenCover(isPresented: $isPresentingVideo) {
                    PostContainer(
                        tikTokSearchResponseItem: tikTokSearchResponseItem,
                        videoLinkHeaders: videoLinkHeaders,
                        isPresented: $isPresentingVideo)
                }
            } else {
                // Placeholder if no cover image
                Color.gray.opacity(0.3)
//                    .frame(width: 200, height: 300)
                    .cornerRadius(14)
            }
            
            if !justVideos {
                // The rest of the view remains the same...
                // [Description, Author Info, Stats]
                Text(tikTokSearchResponseItem.desc ?? "No Description")
                    .font(.body, 14.0)
                    .lineLimit(2)
                    .padding(.top, 8)
                
                HStack {
                    // Author Avatar
                    if let avatarURLString = tikTokSearchResponseItem.author?.avatarThumb, let avatarURL = URL(string: avatarURLString) {
                        AsyncImage(url: avatarURL) { image in
                            image.resizable()
                                .aspectRatio(contentMode: .fill)
                        } placeholder: {
                            Circle()
                                .fill(Color.gray.opacity(0.3))
                        }
                        .frame(width: 30, height: 30)
                        .clipShape(Circle())
                    } else {
                        Circle()
                            .fill(Color.gray.opacity(0.3))
                            .frame(width: 30, height: 30)
                    }
                    
                    Text(tikTokSearchResponseItem.author?.nickname ?? "Unknown Author")
                        .font(.body, 14.0)
                }
                .padding(.top, 4)
                
                if let playCount = tikTokSearchResponseItem.stats?.playCount {
                    Label("\(playCount)", systemImage: "play.fill")
                        .font(.body, 14.0)
                        .foregroundColor(Colors.foregroundText)
                        .opacity(0.6)
                }
                HStack(spacing: 16) {
                    if let commentCount = tikTokSearchResponseItem.stats?.commentCount {
                        Label("\(commentCount)", systemImage: "message.fill")
                    }
                    if let likeCount = tikTokSearchResponseItem.stats?.diggCount {
                        Label("\(likeCount)", systemImage: "heart.fill")
                    }
                }
                .font(.body, 14.0)
                .foregroundColor(Colors.foregroundText)
                .opacity(0.6)
            }
        }
//        .frame(width: 200)
    }
}


TikTokSearchCardsView.swift
//
//  TikTokSearchCardsView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/3/24.
//

import SwiftUI

struct TikTokSearchCardsView: View {
    
    let tikTokSearchResponse: TikTokSearchResponse  // or TikTokSearchRequest.Root if that's the type
    let maxCardWidth: CGFloat
    let justVideos: Bool = true

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(alignment: .top, spacing: 16) {
                ForEach(tikTokSearchResponse.body.apiResponse.itemList.indices, id: \.self) { index in
                    let item = tikTokSearchResponse.body.apiResponse.itemList[index]
                    let videoLinkHeaders = tikTokSearchResponse.body.apiResponse.other.videoLinkHeaders
                    TikTokSearchCardView(tikTokSearchResponseItem: item, videoLinkHeaders: videoLinkHeaders, justVideos: justVideos)
                        .frame(maxWidth: maxCardWidth)
                }
            }
            .padding(.horizontal)
        }
    }
}

//#Preview {
//    
//    TikTokSearchCardsView()
//
//}


PostStatsContainer.swift
//
//  PostStatsContainer.swift
//  SocialBackup
//
//  Created by Alex Coundouriotis on 10/11/24.
//

import SwiftUI

struct PostStatsContainer: View {
    
    var tikTokSearchResponseItem: TikTokSearchResponse.Item
    
    @Environment(\.managedObjectContext) private var viewContext
    
//    @State private var postInfo: GetPostInfoResponse?
//    @State private var postTranscriptions: [String] = []
    
    @State private var isLoading: Bool = false
    
    @State private var isLoadingSummary: Bool = false
    
    @State private var isShowingTranscriptions: Bool = false
    @State private var isShowingUltra: Bool = false
    
    var body: some View {
        Group {
            PostStatsView(
                tikTokSearchResponseItem: tikTokSearchResponseItem)
        }
        .ultraViewPopover(isPresented: $isShowingUltra)
    }
    
}

//#Preview {
//    
//    PostStatsContainer()
//
//}


PostStatsView.swift
//
//  PostStatsView.swift
//  SocialBackup
//
//  Created by Alex Coundouriotis on 10/11/24.
//

import SwiftUI

struct PostStatsView: View {
    
    var tikTokSearchResponseItem: TikTokSearchResponse.Item  // Using Item from TikTokSearchResponse

    @Environment(\.openURL) private var openURL

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                // Author Info
                if let author = tikTokSearchResponseItem.author {
                    HStack(spacing: 12) {
                        // Author Avatar
                        if let avatarURLString = author.avatarThumb, let avatarURL = URL(string: avatarURLString) {
                            Button(action: {
                                if let uniqueId = author.uniqueId,
                                   let profileURL = URL(string: "https://tiktok.com/@\(uniqueId)") {
                                    openURL(profileURL)
                                }
                            }) {
                                AsyncImage(url: avatarURL) { image in
                                    image.resizable()
                                        .aspectRatio(contentMode: .fill)
                                } placeholder: {
                                    Circle()
                                        .fill(Color.gray.opacity(0.3))
                                }
                                .frame(width: 50, height: 50)
                                .clipShape(Circle())
                                .overlay(alignment: .bottomTrailing) {
                                    // Source Icon (if any)
                                    if let sourceImageName = getSourceImageName(from: tikTokSearchResponseItem) {
                                        Image(sourceImageName)
                                            .resizable()
                                            .aspectRatio(contentMode: .fit)
                                            .frame(width: 28.0, height: 28.0)
                                            .offset(x: 6, y: 6)
                                    }
                                }
                            }
                        } else {
                            Circle()
                                .fill(Color.gray.opacity(0.3))
                                .frame(width: 50, height: 50)
                        }

                        // Author Name and Username
                        VStack(alignment: .leading) {
                            Text(author.nickname ?? "Unknown Author")
                                .font(.custom(Constants.FontName.heavy, size: 17.0))
                            Text("@\(author.uniqueId ?? "")")
                                .font(.custom(Constants.FontName.body, size: 12.0))
                        }
                    }
                }

                // Post Description
                if let description = tikTokSearchResponseItem.desc {
                    Text(description)
                        .font(.custom(Constants.FontName.heavy, size: 20.0))
                }

                // Post Stats
                if let stats = tikTokSearchResponseItem.stats {
                    LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], alignment: .leading) {
                        StatisticView(iconName: "play.fill", value: "\(stats.playCount ?? 0)")
                        StatisticView(iconName: "heart.fill", value: "\(stats.diggCount ?? 0)")
                        StatisticView(iconName: "bubble.right.fill", value: "\(stats.commentCount ?? 0)")
                        StatisticView(iconName: "arrowshape.turn.up.right.fill", value: "\(stats.shareCount ?? 0)")
                    }
                }
                
                // Video Duration
                if let duration = tikTokSearchResponseItem.video?.duration {
                    StatisticView(iconName: "clock.fill", value: formatDuration(Double(duration)))
                }

                // Open Transcriptions View (if any)
                // Implement as needed.

                // Tags and Challenges
                if let challenges = tikTokSearchResponseItem.challenges {
                    VStack(alignment: .leading, spacing: 8.0) {
                        Text("Tags:")
                            .font(.custom(Constants.FontName.heavy, size: 10.0))
                        SingleAxisGeometryReader(axis: .horizontal) { geo in
                            HStack {
                                FlexibleView(
                                    availableWidth: geo.magnitude,
                                    data: challenges.compactMap { $0.title },
                                    spacing: 8.0,
                                    alignment: .leading,
                                    content: { tag in
//                                        Button(action: { onSelectTag(tag) }) {
                                            Text(tag)
                                                .font(.custom(Constants.FontName.body, size: 14.0))
                                                .foregroundStyle(Colors.foregroundText)
                                                .padding(.horizontal)
                                                .padding(.vertical, 8)
                                                .background(Colors.foreground)
                                                .clipShape(RoundedRectangle(cornerRadius: 14.0))
//                                        }
                                    })
                                Spacer()
                            }
                        }
                    }
                }

                // Video URL and Actions
//                if let videoURLString = tikTokSearchResponseItem.video?.playAddr, let videoURL = URL(string: videoURLString) {
                if let authorID = tikTokSearchResponseItem.author?.uniqueId,
                   let videoID = tikTokSearchResponseItem.video?.id,
                   let videoURL = URL(string: "https://tiktok.com/@\(authorID)/video/\(videoID)") {
                    HStack {
                        VStack(alignment: .leading) {
                            Text("Video URL:")
                                .font(.custom(Constants.FontName.heavy, size: 14.0))
                            Text(videoURL.absoluteString)
                                .font(.body, 9.0)
                        }
                        Spacer()
                        Button(action: {
                            // Copy URL to clipboard
                            UIPasteboard.general.url = videoURL
                        }) {
                            Image(systemName: "doc.on.doc")
                                .font(.custom(Constants.FontName.body, size: 12.0))
                                .miniButtonStyle()
                        }
                        Button(action: {
                            openURL(videoURL)
                        }) {
                            HStack(spacing: 4.0) {
                                Text("Open")
                                Image(systemName: "chevron.right")
                                    .font(.custom(Constants.FontName.body, size: 10.0))
                            }
                            .miniButtonStyle()
                        }
                    }
                }
            }
            .foregroundStyle(Colors.foregroundText)
            .padding()
        }
    }

    func getSourceImageName(from item: TikTokSearchResponse.Item) -> String? {
        // Return the image name based on item source, if applicable
        return nil
    }

    // Helper function to format duration from seconds to "Xm Ys"
    func formatDuration(_ duration: Double) -> String {
        let totalSeconds = Int(duration)
        let minutes = totalSeconds / 60
        let seconds = totalSeconds % 60
        return "\(minutes)m \(seconds)s"
    }
    
}

// Helper view for displaying statistics
struct StatisticView: View {
    var iconName: String
    var value: String

    var body: some View {
        HStack(spacing: 4) {
            Image(systemName: iconName)
                .foregroundColor(.gray)
            Text(value)
                .font(.subheadline)
                .foregroundColor(.gray)
        }
    }
    
}

// Preview for PostStatsView
struct PostStatsView_Previews: PreviewProvider {
    
    static var previews: some View {
        // Create a sample Author for preview
        let sampleAuthor = TikTokSearchResponse.Author(
            avatarLarger: "https://example.com/avatarLarger.jpg",
            avatarMedium: "https://example.com/avatarMedium.jpg",
            avatarThumb: "https://example.com/avatarThumb.jpg",
            commentSetting: 1,
            downloadSetting: 1,
            duetSetting: 1,
            ftc: false,
            id: "author123456",
            nickname: "SampleUser",
            openFavorite: true,
            privateAccount: false,
            relation: 0,
            secUid: "SECUID123456",
            secret: false,
            signature: "This is a sample signature.",
            stitchSetting: 1,
            uniqueId: "sampleuser",
            verified: true
        )
        
        // Create a sample Video for preview
        let sampleVideo = TikTokSearchResponse.Video(
            bitrate: 720,
            cover: "https://example.com/videoCover.jpg",
            downloadAddr: "https://example.com/videoDownload.mp4",
            duration: 120,
            dynamicCover: "https://example.com/dynamicCover.jpg",
            encodeUserTag: "SampleTag",
            encodedType: "mp4",
            format: "mp4",
            height: 1280,
            id: "video123456",
            originCover: "https://example.com/originCover.jpg",
            playAddr: "https://example.com/playVideo.mp4",
            ratio: "16:9",
            reflowCover: "https://example.com/reflowCover.jpg",
            shareCover: ["https://example.com/shareCover1.jpg", "https://example.com/shareCover2.jpg"],
            videoQuality: "HD",
            width: 720
        )
        
        // Create a sample Stats for preview
        let sampleStats = TikTokSearchResponse.Stats(
            collectCount: 150,
            commentCount: 75,
            diggCount: 300,
            playCount: 5000,
            shareCount: 25
        )
        
        // Create a sample AuthorStats for preview
        let sampleAuthorStats = TikTokSearchResponse.AuthorStats(
            diggCount: 400,
            followerCount: 10000,
            followingCount: 500,
            heart: 200000,
            heartCount: 250000,
            videoCount: 150
        )
        
        // Create a sample Challenge for preview
        let sampleChallenge = TikTokSearchResponse.Challenge(
            coverLarger: "https://example.com/challengeCoverLarger.jpg",
            coverMedium: "https://example.com/challengeCoverMedium.jpg",
            coverThumb: "https://example.com/challengeCoverThumb.jpg",
            desc: "Join the Sample Challenge!",
            id: "challenge123",
            isCommerce: false,
            profileLarger: "https://example.com/challengeProfileLarger.jpg",
            profileMedium: "https://example.com/challengeProfileMedium.jpg",
            profileThumb: "https://example.com/challengeProfileThumb.jpg",
            title: "SampleChallenge"
        )
        
        // Create a sample DuetInfo for preview
        let sampleDuetInfo = TikTokSearchResponse.DuetInfo(
            duetFromId: "duetFrom123456"
        )
        
        // Create a sample Music for preview
        let sampleMusic = TikTokSearchResponse.Music(
            album: "Sample Album",
            authorName: "Sample Artist",
            coverLarge: "https://example.com/musicCoverLarge.jpg",
            coverMedium: "https://example.com/musicCoverMedium.jpg",
            coverThumb: "https://example.com/musicCoverThumb.jpg",
            duration: 180,
            id: "music123456",
            original: true,
            playUrl: "https://example.com/musicPlay.mp3",
            title: "Sample Music Title"
        )
        
        // Create a sample Sticker for preview
        let sampleSticker = TikTokSearchResponse.Sticker(
            stickerText: ["Sample Sticker"],
            stickerType: 1
        )
        
        // Create a sample TextExtra for preview
        let sampleTextExtra = TikTokSearchResponse.TextExtra(
            awemeId: "aweme123456",
            end: 50,
            hashtagId: "hashtag123",
            hashtagName: "SampleHashtag",
            isCommerce: false,
            secUid: "secUid123456",
            start: 0,
            subType: 1,
            type: 1,
            userId: "user123456",
            userUniqueId: "uniqueuser123"
        )
        
        // Create a sample Anchor for preview
        let sampleAnchor = TikTokSearchResponse.Anchor(
            description: "This is a sample anchor description.",
            extraInfo: TikTokSearchResponse.ExtraInfo(subtype: "subtype1"),
            icon: TikTokSearchResponse.Icon(urlList: ["https://example.com/icon1.jpg"]),
            id: "anchor123",
            keyword: "SampleKeyword",
            logExtra: "SampleLogExtra",
            schema: "sampleSchema",
            thumbnail: TikTokSearchResponse.Thumbnail(
                height: 100,
                urlList: ["https://example.com/thumbnail1.jpg"],
                width: 100
            ),
            type: 1
        )
        
        // Create the sample Item with all fields populated
        let sampleItem = TikTokSearchResponse.Item(
            author: sampleAuthor,
            authorStats: sampleAuthorStats,
            challenges: [sampleChallenge],
            collected: true,
            createTime: 1700000000, // Example timestamp
            desc: "This is a sample description for the TikTok video.",
            digged: true,
            duetEnabled: true,
            duetInfo: sampleDuetInfo,
            forFriend: false,
            id: "item123456",
            isAd: false,
            itemCommentStatus: 1,
            itemMute: false,
            music: sampleMusic,
            officalItem: false,
            originalItem: true,
            privateItem: false,
            secret: false,
            shareEnabled: true,
            showNotPass: false,
            stats: sampleStats,
            stickersOnItem: [sampleSticker],
            stitchEnabled: true,
            textExtra: [sampleTextExtra],
            video: sampleVideo,
            vl1: false,
            anchors: [sampleAnchor]
        )
        
        PostStatsView(
            tikTokSearchResponseItem: sampleItem
        )
        .background(Color.gray.opacity(0.1)) // Replace with Colors.background if defined
        .previewLayout(.sizeThatFits) // Adjust the preview layout as needed
    }
}


RoundedBorderModifier.swift
//
//  RoundedBorderModifier.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/22/23.
//

import SwiftUI

struct RoundedBorderModifier<S: ShapeStyle>: ViewModifier {
    
    var cornerRadius: CGFloat = 20.0
    var strokeStyle: S
    var lineWidth: CGFloat = 2.0
    
    func body(content: Content) -> some View {
        content
            .background(Colors.foreground)
            .clipShape(RoundedRectangle(cornerRadius: cornerRadius))
            .overlay(RoundedRectangle(cornerRadius: cornerRadius)
                .stroke(strokeStyle /* TODO: Is this fine here */, lineWidth: lineWidth))
    }
    
}

@available(iOS 17, *)
#Preview(traits: .sizeThatFitsLayout) {
    Text("Some Text")
        .padding()
        .modifier(RoundedBorderModifier(strokeStyle: Colors.elementBackground))
        .background(Colors.background)
}


BarItemsListRowView.swift
////
////  BarItemsListRowView.swift
////  Barback
////
////  Created by Alex Coundouriotis on 9/29/23.
////
//
//import SwiftUI
//
//struct BarItemsListRowView: View {
//    
//    @Environment(\.managedObjectContext) var viewContext
//    
//    @State var item: BarItem
//    
//    var body: some View {
//        VStack {
//            HStack {
//                VStack {
//                    HStack {
//                        if let title = item.item {
//                            Text(title)
//                                .font(.custom(Constants.FontName.heavy, size: 17.0))
//                            Spacer()
//                        } else {
//                            Text("No Title")
//                                .font(.custom(Constants.FontName.heavyOblique, size: 17.0))
//                            Spacer()
//                        }
//                    }
//                    HStack {
//                        if let updateDate = item.updateDate {
//                            Text(NiceDateFormatter.dateFormatter.string(from: updateDate))
//                                .font(.custom(Constants.FontName.lightOblique, size: 10.0))
//                        } else {
//                            Text("No Date")
//                                .font(.custom(Constants.FontName.lightOblique, size: 10.0))
//                        }
//                        Spacer()
//                    }
//                }
//                Spacer()
//                Image(systemName: "chevron.right")
//            }
//        }
//    }
//    
//}
//
//#Preview {
//    Text("")
////    BarItemsListRowView()
//}


DrinkGenerationManager.swift
////
////  DrinkGenerationManager.swift
////  Barback
////
////  Created by Alex Coundouriotis on 9/21/23.
////
//
//import Combine
//import CoreData
//import Foundation
//import SwiftUI
//
//class DrinkGenerationManager: ObservableObject {
//    
//    @Published var drinkObjectID: NSManagedObjectID?
//    
//    func create(ingredients: String, modifiers: String? = nil, expandIngredientsMagnitude: Int = 1) async throws {
//        // TODO: Comment and fix this lol, fix the ingredients and modifiers thing
//        guard let authToken = AuthHelper.get() else {
//            // TODO: Handle errors
//            print("Could not unwrap authToken when creating drink in DrinkGenerationManager!")
//            return
//        }
//        
//        DispatchQueue.main.async {
//            self.drinkObjectID = nil
//        }
//        
//        let drinkID = try await BarbackNetworkPersistenceManager.createSaveDrink(
//            authToken: authToken,
//            ingredients: ingredients,
//            modifiers: modifiers,
//            expandIngredientsMagnitude: expandIngredientsMagnitude)
//        
//        let newDrinkObjectID = try await DrinkCDClient.getDrinkPermanentID(drinkID: drinkID)
//        
//        DispatchQueue.main.async {
//            self.drinkObjectID = newDrinkObjectID
//        }
//        
//        do {
//            if let drinkID = try await DrinkCDClient.getDrinkID(drinkObjectID: newDrinkObjectID) {
//                Task {
//                    do {
//                        try await BarbackNetworkPersistenceManager.finalizeSaveDrink(
//                            authToken: authToken,
//                            drinkID: drinkID)
//                    } catch {
//                        // TODO: Handle errors
//                        print("Error finalizing saving drink in create in DrinkGenerationManager... \(error)")
//                    }
//                }
//                
//                Task {
//                    do {
//                        try await BarbackNetworkPersistenceManager.getSaveGlassColor(
//                            authToken: authToken,
//                            drinkID: Int(drinkID),
//                            to: newDrinkObjectID)
//                    }
//                }
//                
//                Task {
//                    do {
//                        try await BarbackNetworkPersistenceManager.getSaveGlass(
//                            authToken: authToken,
//                            drinkID: Int(drinkID),
//                            to: newDrinkObjectID)
//                    } catch {
//                        // TODO: Handle errors
//                        print("Error saving glass in create in DrinkGenerationManager... \(error)")
//                    }
//                }
//            } else {
//                // TODO: Handle errors
//                print("Could not unwrap drinkID from DrinkCDClient getDrinkID in create in DrinkGenerationManager!")
//            }
//        } catch {
//            // TODO: Handle errors
//            print("Error getting drink ID in create in DrinkGenerationManager... \(error)")
//        }
//    }
//    
//}


RecipesView.swift
//
//  RecipesView.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/12/24.
//

import SwiftUI

struct RecipesView: View {
    
    let onSelect: (_ recipe: Recipe) -> Void
    
    @Environment(\.managedObjectContext) private var viewContext
    
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Recipe.creationDate, ascending: false)],
        predicate: NSPredicate(format: "%K = %d", #keyPath(Recipe.saved), true),
        animation: .default
    ) private var recipes: FetchedResults<Recipe>
    
    @State private var recipeToDelete: Recipe?
    
    private var alertShowingRecipeToDelete: Binding<Bool> {
        Binding(
            get: {
                recipeToDelete != nil
            },
            set: { value in
                if !value {
                    recipeToDelete = nil
                }
            })
    }
    
    var body: some View {
        LazyVStack {
            if recipes.isEmpty {
                HStack {
                    Spacer()
                    Text("Tap \"Create a Recipe\" below to craft & save your first recipe.")
                        .font(.custom(Constants.FontName.body, size: 17.0))
                        .multilineTextAlignment(.center)
                    Spacer()
                }
                .padding()
                .background(Colors.foreground)
                .clipShape(RoundedRectangle(cornerRadius: 20.0))
            }
            ForEach(recipes) { recipe in
                Button(action: {
                    HapticHelper.doLightHaptic()
                    
                    onSelect(recipe)
//                    isShowingRecipeView = true
                }) {
                    ZStack {
                        RecipeMiniView.from(recipe: recipe)
                            .tint(Colors.foregroundText)
                            .padding()
                            .background(Colors.foreground)
                            .clipShape(RoundedRectangle(cornerRadius: 28.0))
                        
                        HStack {
                            Spacer()
                            Image(systemName: "chevron.right")
                                .imageScale(.medium)
                                .foregroundStyle(Colors.foregroundText)
                                .padding(.trailing)
                        }
                    }
                    .padding(.bottom, 2)
                }
                .contextMenu {
                    Button("Delete", systemImage: "trash", role: .destructive) {
                        recipeToDelete = recipe
                    }
                }
            }
        }
        .padding(.horizontal)
        .alert("Delete Recipe", isPresented: alertShowingRecipeToDelete, actions: {
            Button("Delete", role: .destructive) {
                Task {
                    if let recipeToDelete {
                        do {
                            try await RecipeCDClient.deleteRecipe(recipeToDelete, in: viewContext)
                        } catch {
                            // TODO: Handle Errors
                            print("Error deleting recipe in MainView... \(error)")
                        }
                    }
                    
                    recipeToDelete = nil
                }
            }
            Button("Cancel", role: .cancel) {
                
            }
        }) {
            Text("Are you sure you want to delete this recipe?")
        }
    }
}

#Preview {
    
    RecipesView(onSelect: { recipe in
        
    })
    .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
    
}


BarSelectionEditView.swift
////
////  BarSelectionEditView.swift
////  Barback
////
////  Created by Alex Coundouriotis on 9/29/23.
////
//
//import SwiftUI
//
//struct BarSelectionEditView: View {
//    
//    @Binding var isShowing: Bool
//    @Binding var elementColor: Color
//    
//    enum FilterStates: String, CaseIterable {
//        case all = "All"
//        case bases = "Base Alcohols"
//        case mixers = "Mixers"
//    }
//    
//    @Namespace var namespace
//    @Environment(\.managedObjectContext) var viewContext
//    @FetchRequest(sortDescriptors: [NSSortDescriptor(keyPath: \BarItem.item, ascending: false)], animation: .default) private var allBarItems: FetchedResults<BarItem>
//    @FetchRequest(sortDescriptors: [NSSortDescriptor(keyPath: \BarItem.item, ascending: false)], predicate: NSPredicate(format: "%K = %d", #keyPath(BarItem.isAlcohol), true), animation: .default) private var baseBarItems: FetchedResults<BarItem>
//    @FetchRequest(sortDescriptors: [NSSortDescriptor(keyPath: \BarItem.item, ascending: false)], predicate: NSPredicate(format: "%K = %d", #keyPath(BarItem.isAlcohol), false), animation: .default) private var mixerBarItems: FetchedResults<BarItem>
//    
//    @State var selectedFilterState: FilterStates = .all
//    @State var editingItem: BarItem?
//    
//    @State var shouldDeleteItem: BarItem?
//    
//    @State var isShowingInsertBarItemView: Bool = false
//    @State var isShowingEditBarItemView: Bool = false
//    @State private var alertShowingDeleteItem: Bool = false
//    
//    var body: some View {
//        ZStack {
//            VStack {
////                header
//                
//                filters
//                
//                //                ScrollView {
//                //                    VStack {
//                List(selectedFilterState == .all ? allBarItems : selectedFilterState == .bases ? baseBarItems : mixerBarItems) { item in
//                    
//                    ZStack {
//                        BarItemsListRowView(item: item)
//                            .background(Colors.foreground)
//                            .onTapGesture {
//                                if item != editingItem {
//                                    withAnimation {
//                                        editingItem = item
//                                        isShowingEditBarItemView = true
//                                    }
//                                } else {
//                                    withAnimation {
//                                        editingItem = nil
//                                        isShowingEditBarItemView = false
//                                    }
//                                }
//                            }
//                            .swipeActions(content: {
//                                Button(action: {
//                                    shouldDeleteItem = item
//                                    alertShowingDeleteItem = true
//                                }) {
//                                    Text("Delete")
//                                }
//                                .tint(Color(uiColor: .systemRed))
//                            })
//                    }
//                }
//                .listStyle(.insetGrouped)
//                //                    }
//                //                    .padding()
//                //                }
//                .background(Colors.background)
//            }
//        }
//        .overlay {
//            if isShowingInsertBarItemView {
//                Color.clear
//                    .background(Material.thin)
//                    .transition(.opacity)
//                GeometryReader { geometry in
//                    VStack {
//                        Spacer()
//                        HStack {
//                            Spacer()
//                            InsertBarItemView(
//                                isShowing: $isShowingInsertBarItemView,
//                                textFieldColor: Colors.foreground,
//                                elementColor: $elementColor)
//                                .padding(24.0)
//                                .background(Colors.background)
//                                .frame(width: geometry.size.width * (8 / 9))
//                                .cornerRadius(28.0)
//                            Spacer()
//                        }
//                        Spacer()
//                    }
//                }
//                .transition(.move(edge: .bottom))
//            }
//        }
//        .overlay {
//            if isShowingEditBarItemView {
//                Color.clear
//                    .background(Material.thin)
//                    .transition(.opacity)
//                GeometryReader { geometry in
//                    VStack {
//                        Spacer()
//                        HStack {
//                            Spacer()
//                            if let editingItem = editingItem {
//                                EditBarItemView(
//                                    item: editingItem,
//                                    isActive: $isShowingEditBarItemView,
//                                    elementColor: $elementColor)
//                                    .padding(24.0)
//                                    .background(Colors.foreground)
//                                    .frame(width: geometry.size.width * (8 / 9))
//                                    .clipShape(RoundedRectangle(cornerRadius: 28.0))
//                            }
//                            Spacer()
//                        }
//                        Spacer()
//                    }
//                }
//                .transition(.move(edge: .bottom))
//            }
//        }
//        .alert("Delete Item", isPresented: $alertShowingDeleteItem, actions: {
//            if let shouldDeleteItem = shouldDeleteItem {
//                Button("Back", role: .cancel, action: {
//                    self.shouldDeleteItem = nil
//                })
//            
//                Button("Delete", role: .destructive, action: {
//                    viewContext.delete(shouldDeleteItem)
//                    
//                    do {
//                        try viewContext.save()
//                        
//                        self.shouldDeleteItem = nil
//                    } catch {
//                        // TODO: Handle errors
//                        print("Error saving viewContext in BarSelectionEditView... \(error)")
//                    }
//                })
//            } else {
//                Button("Done", role: .cancel, action: {
//                    
//                })
//            }
//        }) {
//            if shouldDeleteItem != nil {
//                Text("Are you sure you want to delete this item?")
//            } else {
//                Text("This item cannot be deleted.")
//            }
//        }
//        .barbackHeader(
//            backgroundColor: elementColor,
//            showsDivider: true,
//            left: {
//                Button(action: {
//                    isShowing = false
//                }) {
//                    Text("Close")
//                        .font(.custom(Constants.FontName.heavy, size: 20.0))
//                        .foregroundStyle(Colors.elementText)
//                        .padding(.leading)
//                        .padding(.bottom, 10)
//                }
//            },
//            right: {
//                Button(action: {
//                    withAnimation {
//                        isShowingInsertBarItemView = true
//                    }
//                }) {
//                    Text(Image(systemName: "plus"))
//                        .font(.custom(Constants.FontName.heavy, size: 20.0))
//                        .foregroundStyle(Colors.elementText)
//                        .padding(.trailing)
//                        .padding(.bottom, 10)
//                }
//            })
//        .ignoresSafeArea()
//    }
//    
////    var header: some View {
////        ZStack {
////            HStack {
////                VStack {
////                    Spacer()
////                    Button(action: {
////                        isShowing = false
////                    }) {
////                        Text("Close")
////                            .font(.custom(Constants.FontName.heavy, size: 20.0))
////                            .foregroundStyle(Colors.elementText)
////                            .padding(.leading)
////                            .padding(.bottom, 10)
////                    }
////                }
////                Spacer()
////            }
////            
////            HStack {
////                Spacer()
////                VStack {
////                    Spacer()
////                    Text("Barback")
////                        .font(.custom(Constants.FontName.appname, size: 34.0))
////                        .foregroundStyle(Colors.elementText)
////                        .padding(4)
////                }
////                Spacer()
////            }
////            
////            HStack {
////                Spacer()
////                VStack {
////                    Spacer()
////                    Button(action: {
////                        withAnimation {
////                            isShowingInsertBarItemView = true
////                        }
////                    }) {
////                        Text(Image(systemName: "plus"))
////                            .font(.custom(Constants.FontName.heavy, size: 20.0))
////                            .foregroundStyle(Colors.elementText)
////                            .padding(.trailing)
////                            .padding(.bottom, 10)
////                    }
////                }
////            }
////        }
////        .frame(height: 100)
//////        .background(elementColor)
////    }
//    
//    var filters: some View {
//        HStack {
//            ForEach(FilterStates.allCases, id: \.self) { filterState in
////                        Spacer()
//                Button(action: {
//                    withAnimation {
//                        selectedFilterState = filterState
//                    }
//                }) {
//                    VStack {
//                        Text(filterState.rawValue)
//                            .font(.custom(selectedFilterState == filterState ? Constants.FontName.black : Constants.FontName.body, size: 17.0))
//                            .frame(minWidth: 40.0)
//                        if filterState == selectedFilterState {
//                            RoundedRectangle(cornerRadius: 17.0)
//                                .matchedGeometryEffect(id: "littleUnderline", in: namespace)
//                                .frame(maxHeight: 2)
//                        } else {
//                            Spacer()
//                        }
//                    }
//                }
////                        Spacer()
//            }
//            .padding([.leading, .top, .trailing])
//            .fixedSize(horizontal: true, vertical: true)
//        }
//    }
//    
//    func getItemsToSort(filterState: FilterStates) -> FetchedResults<BarItem> {
//        switch filterState {
//        case .all: allBarItems
//        case .bases: baseBarItems
//        case .mixers: mixerBarItems
//        }
//    }
//    
//}
//
//#Preview {
//    BarSelectionEditView(
//        isShowing: .constant(true),
//        elementColor: .constant(Colors.element))
//        .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
//        .background(Colors.background)
//        .presentationCompactAdaptation(.fullScreenCover)
//}


MainContainer.swift
//
//  MainContainer.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/27/24.
//

import PDFKit
import SwiftUI

struct MainContainer: View {
    
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.requestReview) private var requestReview
    
    @EnvironmentObject private var premiumUpdater: PremiumUpdater
    
    @StateObject private var recipeGenerator = RecipeGenerator()
    
    @State private var recipeGenerationSpec: RecipeGenerationSpec = RecipeGenerationSpec(
        pantryItems: [],
        suggestions: [],
        input: "",
        generationAdditionalOptions: .normal) // Shows RecipeGenerationView if filled
    
//    @State private var isShowingEntryView = false
    
    @State private var presentingPanel: Panel? = nil
    
//    var isShowingRecipeGenerationView: Binding<Bool> {
//        Binding(
//            get: {
//                recipeGenerationSpec != nil
//            },
//            set: { value in
//                if !value {
//                    recipeGenerationSpec = nil
//                }
//            })
//    }
    
    var body: some View {
        MainView(
            recipeGenerator: recipeGenerator,
            recipeGenerationSpec: recipeGenerationSpec,
            presentingPanel: $presentingPanel)
            .onOpenURL(perform: { url in
                if url.host == "recipe" || (url.host == "chitchatserver.com" && url.pathComponents[safe: 1] == "chefappdeeplink" && url.pathComponents[safe: 2] == "recipe") {
                    let recipeIDString = url.lastPathComponent
                    guard let recipeID = Int(recipeIDString) else {
                        // TODO: Handle Errors
                        print("Could not unwrap recipeID in MainContainer!")
                        return
                    }
                    
                    print("recipeID: \(recipeID)")
                    
                    Task {
                        // Ensure authToken
                        let authToken: String
                        do {
                            authToken = try await AuthHelper.ensure()
                        } catch {
                            // TODO: Handle Errors
                            print("Error ensuring authToken in MainContainer... \(error)")
                            return
                        }
                        
                        // Get recipe
                        do {
                            let recipe = try await ChefAppNetworkPersistenceManager.getAndDuplicateAndSaveRecipe(
                                authToken: authToken,
                                recipeID: recipeID,
                                recipeGenerator: recipeGenerator,
                                in: viewContext)
                        } catch {
                            // TODO: Handle Errors
                            print("Error getting and duplicating and saving recipe in MainContainer... \(error)")
                        }
                    }
                }
            })
    }
    
}

#Preview {
    
    return MainContainer()
        .environmentObject(PremiumUpdater())
    
}


SheetView.swift
//
//  SheetView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/20/23.
//

import Foundation
import SwiftUI

struct SheetView: View {
    
    @ObservedObject var recipeGenerator: RecipeGenerator
    @Binding var selectedPantryItems: [PantryItem]
    @Binding var inputFieldText: String
    @Binding var isShowingEntryView: Bool
    @Binding var selectedSuggestions: [String]
    @State var showsCraftText: Bool = false
    var textFieldPlaceholders: [String]
    let onGenerate: () -> Void
    
//    private let coordinator = GADInterstitialCoordinator()
    
//    var timer = Timer.publish(every: 8.0, on: .main, in: .common).autoconnect()
    
    @Environment(\.colorScheme) private var colorScheme
    
    @Namespace private var namespace
    
    @FocusState private var isTextFieldFocused: Bool
    
    @State private var textFieldPlaceholderIndex: Int = 0
    
    @State private var craftButtonBackgroundMatchedGeometryEffectID = "craftButtonBackground"
    @State private var craftButtonTextMatchedGeometryEffectID = "craftButtonText"
    @State private var craftButtonArrowMatchedGeometryEffectID = "craftButtonArrow"
    
    @State private var previousSuggestions: [String] = []
    
    @State private var yOffset: CGFloat = 0.0
    
    private var submitButtonDisabled: Bool {
        recipeGenerator.isCreating || (inputFieldText.isEmpty && selectedPantryItems.isEmpty && selectedSuggestions.isEmpty)
    }
    
//    @State private var buttonWidth: CGFloat = 0.0
    
    // TODO: Look up Form and Section
    
    
    var body: some View {
        ZStack {
//            let _ = Self._printChanges()
            VStack {
                ZStack {
                    if isShowingEntryView {
                        VStack(spacing: 0.0) {
                            pantryItemList
                            
                            HStack {
                                inputField
                                
                                submitButton
                            }
                            
                            if !selectedSuggestions.isEmpty {
                                suggestionsList
                                    .padding([.leading, .trailing])
                                    .padding(.bottom, 4)
                            }
                        }
                        .background(Colors.foreground)
                        .clipShape(RoundedRectangle(cornerRadius: 20.0))
                    } else {
                        showInputFieldButton
                    }
                }
            }
        }
    }
    
    var pantryItemList: some View {
        ScrollView(.horizontal) {
            HStack {
                Spacer()
                ForEach(selectedPantryItems.reversed()) { selectedPantryItem in
                    if let selectedPantryItemName = selectedPantryItem.name {
                        Button(action: {
                            HapticHelper.doLightHaptic()
                            
                            selectedPantryItems.removeAll(where: {$0 == selectedPantryItem})
                        }) {
                            Text(selectedPantryItemName)
                                .font(.custom(Constants.FontName.body, size: 12.0))
                            Text(Image(systemName: "xmark"))
                                .font(.custom(Constants.FontName.body, size: 12.0))
                        }
                        .padding(8)
                        .foregroundStyle(Colors.elementBackground)
                        .background(Colors.background)
                        .clipShape(RoundedRectangle(cornerRadius: 14.0))
                        .padding(.top, 4)
                    }
                }
            }
        }
        .scrollIndicators(.never)
    }
    
    var inputField: some View {
        TextField("", text: $inputFieldText, axis: .vertical)
            .textFieldTickerTint(colorScheme == .light ? Colors.elementBackground : Colors.foregroundText)
            .keyboardDismissingTextFieldToolbar("Done", color: Colors.elementBackground)
            .font(.custom(Constants.FontName.medium, size: 17.0))
            .placeholder(when: inputFieldText.isEmpty) {
                Text(textFieldPlaceholders[textFieldPlaceholderIndex])
                    .font(.custom(Constants.FontName.body, size: 17.0))
                    .foregroundStyle(Colors.foregroundText)
                    .opacity(0.4)
            }
            .focused($isTextFieldFocused)
            .padding()
    }
    
    var showInputFieldButton: some View {
        Button(action: {
            // Do light haptic
            HapticHelper.doLightHaptic()
            
            // Show entry view
            withAnimation {
                isShowingEntryView = true
            }
        }) {
            ZStack {
                Spacer()
                Text("Create Recipe")
                    .font(.custom("copperplate-bold", size: 24.0))
                    .foregroundStyle(Colors.elementText)
                    .matchedGeometryEffect(id: craftButtonTextMatchedGeometryEffectID, in: namespace)
                
                HStack {
                    Spacer()
                    
                    Text(recipeGenerator.isCreating ? "" : "\(Image(systemName: "arrow.right"))")
                        .font(.custom("copperplate-bold", size: 17.0))
                        .foregroundStyle(Colors.elementText)
                        .matchedGeometryEffect(id: craftButtonArrowMatchedGeometryEffectID, in: namespace)
                    
                    if recipeGenerator.isCreating {
                        ProgressView()
                            .tint(Colors.elementText)
                    }
                }
                Spacer()
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 14.0)
                    .fill(Colors.elementBackground)
                    .matchedGeometryEffect(id: craftButtonBackgroundMatchedGeometryEffectID, in: namespace))
            .clipShape(RoundedRectangle(cornerRadius: 20.0))
        }
        .bounceable()
    }
    
    var suggestionsList: some View {
        SingleAxisGeometryReader(axis: .horizontal) { geo in
            HStack {
                FlexibleView(availableWidth: geo.magnitude, data: selectedSuggestions, spacing: 8.0, alignment: .leading, content: { suggestion in
                    Text(suggestion)
                        .font(.custom(Constants.FontName.medium, size: 12.0))
                        .foregroundStyle(Colors.foregroundText)
                        .padding(.horizontal, 4)
                        .padding(.vertical, 2)
                        .background(Colors.foreground)
                        .clipShape(Capsule())
                        .padding(.top, -6)
                    
                })
                
                Spacer()
            }
        }
    }
    
    var submitButton: some View {
        ZStack {
            KeyboardDismissingButton(action: {
                HapticHelper.doLightHaptic()
                
                // TODO: Do enable/disable stuff, for action generate
                Task {
                    do {
                        // Present drink generation view to start generating drink
                        withAnimation {
                            onGenerate()
                        }
                        
//                        // Create drink
//                        try await drinkGenerator.create(input: textFieldText)
                    } catch {
                        // TODO: Handle errors
                        print("Could not create using generationManager in SheetView body... \(error)")
                    }
                }
            }) {
                VStack {
                    ZStack {
                        HStack(spacing: 8.0) {
                            // TODO: Make this hug the bottom as the user keeps typing in text
                            
                            if showsCraftText {
                                Text("Create")
                                    .font(.custom("copperplate-bold", size: 19.0))
                                    .foregroundStyle(Colors.elementText)
                                    .matchedGeometryEffect(id: craftButtonTextMatchedGeometryEffectID, in: namespace)
                            }
                            
                            ZStack {
                                Text(recipeGenerator.isCreating ? "" : "\(Image(systemName: "arrow.up"))")
                                    .font(.custom("copperplate-bold", size: 17.0))
                                    .foregroundStyle(Colors.elementText)
                                    .matchedGeometryEffect(id: craftButtonArrowMatchedGeometryEffectID, in: namespace)
                                
                                if recipeGenerator.isCreating {
                                    ProgressView()
                                        .tint(Colors.elementText)
                                }
                            }
                        }
//                        Text("Craft \(Image(systemName: submitButtonImageName))")
////                            .resizable()
//                            .padding(8)
//                            .font(.custom("copperplate-bold", size: 17.0))
//                            .foregroundStyle(Colors.elementText)
                        
//                        if drinkGenerator.isCreating {
//                            ProgressView()
//                        }
                    }
                    .padding(8)
                }
            }
            .background(
                ZStack {
                    if showsCraftText {
                        RoundedRectangle(cornerRadius: 24.0)
                            .matchedGeometryEffect(id: craftButtonBackgroundMatchedGeometryEffectID, in: namespace)
                    } else {
                        RoundedRectangle(cornerRadius: 24.0)
                            .matchedGeometryEffect(id: craftButtonBackgroundMatchedGeometryEffectID, in: namespace)
                            .aspectRatio(contentMode: .fit)
                    }
                }
                .foregroundStyle(Colors.elementBackground)
            )
            .disabled(submitButtonDisabled)
            .opacity(submitButtonDisabled ? 0.4 : 1.0)
            .bounceable(disabled: submitButtonDisabled)
        }
//        .frame(width: 32.0, height: 32.0)
        .aspectRatio(contentMode: .fill)
        .padding([.trailing], 8)
        .onDisappear {
            // Dismiss entry view TODO: Is this a good place to do this?
            isShowingEntryView = false
        }
    }
    
}

#Preview {
    
    struct ContentView: View {
        
        @State var inputFieldText = "Input Field Text"
        @State var suggestionButtonPressed: Bool = false
        @State var selectedSuggestions: [String] = []
        
        private let textFieldPlaceholders = [
            "Test 1",
            "Test 2",
            "Tee hee :)"
        ]
        
        private let suggestions = [
            "Suggestion 1",
            "Another suggestion",
            "a third suggestion!"
        ]
        
        @State private var selectedSuggestionIndex: Int = 0
        
        var body: some View {
            VStack {
                Button(action: {
                    HapticHelper.doLightHaptic()
                    
                    if selectedSuggestionIndex >= suggestions.count {
                        selectedSuggestions.removeAll()
                        selectedSuggestionIndex = 0
                    } else {
                        selectedSuggestions.append(suggestions[selectedSuggestionIndex])
                        
                        selectedSuggestionIndex += 1
                    }
                }) {
                    Text("Change Suggestion Text")
                        .foregroundStyle(.blue)
                }
                
                SheetView(
                    recipeGenerator: RecipeGenerator(),
                    selectedPantryItems: .constant([]),
                    inputFieldText: $inputFieldText,
                    isShowingEntryView: .constant(true),
                    selectedSuggestions: $selectedSuggestions,
                    textFieldPlaceholders: textFieldPlaceholders,
                    onGenerate: {
                        
                    })
                .padding()
                .background(Colors.background)
                //            .cornerRadius(28.0)
            }
        }
    }
    
    return ContentView()
}


MainView.swift
//
//  MainView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/16/23.
//

import SwiftUI
import CoreData
import Combine

class MainViewModel: ObservableObject {
    
    @Published var panels: [Panel]?
    
    init() {
        // Setup create panels
        setupCreatePanels()
    }
    
    private func setupCreatePanels() {
        // If panelsJSON can be unwrapped and panels can be completely fetched from the file system, set the createPanelsData to the createPanels from the file system
        if let panelsJSON = CreatePanelsJSONPersistenceManager.get() {
            do {
                if let parsedCreatePanelsData = try PanelParser.parsePanelsGettingImagesFromFiles(fromJson: panelsJSON) {
                    DispatchQueue.main.async {
                        self.panels = parsedCreatePanelsData
                    }
                }
            } catch {
                // TODO: Handle errors
                print("Error parsing panels getting images from files... \(error)")
            }
        }
        
        // Update create panels fetching images from network
        Task {
            await updateCreatePanelsFetchingImagesFromNetwork()
        }
    }
    
    private func updateCreatePanelsFetchingImagesFromNetwork() async {
        do {
            // Get create save panels from PantrybackNetworkPersistenceManager
            try await ChefAppNetworkPersistenceManager.getSaveCreatePanels()
            
            if let panelsJSON = CreatePanelsJSONPersistenceManager.get() {
                do {
                    let parsedCreatePanelsData = try await PanelParser.parsePanelsUpdatingSavedImagesFromNetwork(fromJson: panelsJSON)
                    
                    DispatchQueue.main.async {
                        self.panels = parsedCreatePanelsData
                    }
                } catch {
                    print("Could not parse panel after getting and saving create panels in init in MainViewModel... \(error)")
                }
            }
        } catch {
            print("Could not get create save panels from network in init in MainViewModel... \(error)")
        }
    }
    
}

struct MainView: View {
    
    @ObservedObject var recipeGenerator: RecipeGenerator
    @ObservedObject var recipeGenerationSpec: RecipeGenerationSpec
//    @Binding var isShowingEntryView: Bool
    @Binding var presentingPanel: Panel?
    
    @Environment(\.managedObjectContext) var viewContext
    @Namespace var panelNamespace
    
    // Fetch requests for pantry items and recipes
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \PantryItem.updateDate, ascending: false)],
        animation: .default
    ) private var pantryItems: FetchedResults<PantryItem>
    
    // State objects and variables for various functionalities
    @StateObject private var mainViewModel = MainViewModel()
    @StateObject private var keyboardResponder = KeyboardResponder()
    
    @EnvironmentObject private var constantsUpdater: ConstantsUpdater
    @EnvironmentObject private var premiumUpdater: PremiumUpdater
    @EnvironmentObject private var productUpdater: ProductUpdater
    @EnvironmentObject private var remainingUpdater: RemainingUpdater
    
    @State private var isDisplayingSheetView = true
    @State private var isDisplayingHeader = true
    
    @State private var isShowingAddPantryItemDirectlyToCameraPopup = false
    @State private var isShowingAddPantryItemPopup = false
    @State private var isShowingEasyPantryUpdateContainer: Bool = false
    
//    @State private var generationItemsSelected: [PantryItem] = []
//    @State private var generationInput: String = ""
//    @State private var generationSuggestionsSelected: [String] = []
//    @State private var generationAdditionalOptions: RecipeGenerationAdditionalOptions = .normal
    
    @State private var isShowingPanelView: Bool = false
    @State private var canPresentPanel: Bool = true
    
    @State private var isShowingAllPantryItemsView: Bool = false
    @State private var presentingRecipe: Recipe? = nil
    
    @State private var isShowingSettingsView: Bool = false
    @State private var isShowingSwipeCardsEntryView: Bool = false
    @State private var isShowingUltraView: Bool = false
    //    @State private var recipeObjectIDShouldPopToRootAlsoDeprecateThisLol: Bool = false
    
    private var isShowingRecipeView: Binding<Bool> {
        Binding(
            get: {
                presentingRecipe != nil
            },
            set: { newValue in
                if !newValue {
                    presentingRecipe = nil
                }
            }
        )
    }

    private var shouldShowSheetCraftText: Bool {
        true
    }

    var body: some View {
        ZStack {
            NavigationStack {
                ZStack {
                    let _ = Self._printChanges()
                    ScrollView(.vertical) {
                        VStack(spacing: 0.0) {
//                            Spacer(minLength: 28)
//                                todayTitle
//                                craftTitle
//                                craftDisplay
                            recipeOfTheDay
                                .padding(.vertical)
//                                Spacer(minLength: 24.0)
//                                pantryTitle
//                                horizontalPantryDisplay
//                            Spacer(minLength: 16.0)
                            
//                                pantryTitle
                            
                            HStack {
                                quickCameraAddToPantryButton
                                showPantryButton
                            }
                            .padding([.leading, .trailing])
//                                .fixedSize(horizontal: false, vertical: true)
                            
                            if pantryItems.contains(where: {
                                if let updateDate = $0.updateDate {
                                    return updateDate <= Calendar.current.date(byAdding: .day, value: -constantsUpdater.easyPantryUpdateContainerOlderThanDays, to: Date())!
                                }
                                
                                return false
                            }) {
                                easyPantryUpdateButton
                            }
                            
                            Spacer(minLength: 24.0)
                            recipesTitle
                                .padding(.bottom, 8)
                            RecipesView(onSelect: { presentingRecipe = $0 })
                                .sheet(isPresented: isShowingRecipeView) {
                                    if let presentingRecipe = presentingRecipe {
                                        RecipeView(
                                            recipeGenerator: recipeGenerator,
                                            recipe: presentingRecipe,
                                            onDismiss: { isShowingRecipeView.wrappedValue = false }
                                        )
                                        .background(Colors.background)
                                        .presentationCompactAdaptation(.fullScreenCover)
                                    }
                                }
                            Spacer(minLength: 214.0)
                        }
                    }
                    .background(Colors.background)
                }
                .navigationBarTitleDisplayMode(.inline)
                .toolbar {
                    ToolbarItem(placement: .topBarLeading) {
                        Button(action: {
                            HapticHelper.doLightHaptic()
                            
                            isShowingSettingsView = true
                        }) {
                            Image(systemName: "gear")
                                .font(.custom(Constants.FontName.heavy, size: 17.0))
                                .foregroundStyle(Colors.elementBackground)
                        }
                    }
                    LogoToolbarItem(foregroundColor: Colors.elementBackground)
                    if !premiumUpdater.isPremium {
                        UltraToolbarItem(color: Colors.elementBackground)
                    }
                }
                .toolbar(isDisplayingHeader ? .visible : .hidden)
                .toolbarBackground(Colors.background, for: .navigationBar)
//                .toolbarBackground(.visible, for: .navigationBar)
                .navigationDestination(isPresented: $isShowingPanelView) {
                    if let panel = presentingPanel {
                        PanelView(
                            recipeGenerator: recipeGenerator,
                            panel: panel,
                            isShowing: $isShowingPanelView
                        )
                        .background(Colors.background)
                    }
                }
                .navigationDestination(isPresented: $isShowingSettingsView) {
                    SettingsView(
                        premiumUpdater: premiumUpdater,
                        isShowing: $isShowingSettingsView
                    )
                }
                .safeAreaInset(edge: .bottom) {
                    Button(action: {
                        // Do light haptic
                        HapticHelper.doLightHaptic()
                        
                        // Show entry view
                        withAnimation {
                            isShowingSwipeCardsEntryView = true
                        }
                    }) {
                        ZStack {
                            Spacer()
                            Text("Create Recipe")
                                .font(.custom("copperplate-bold", size: 24.0))
                                .foregroundStyle(Colors.elementText)
                            
                            HStack {
                                Spacer()
                                
                                Text(recipeGenerator.isCreating ? "" : "\(Image(systemName: "arrow.right"))")
                                    .font(.custom("copperplate-bold", size: 17.0))
                                    .foregroundStyle(Colors.elementText)
                                
                                if recipeGenerator.isCreating {
                                    ProgressView()
                                        .tint(Colors.elementText)
                                }
                            }
                            Spacer()
                        }
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 14.0)
                            .fill(Colors.elementBackground))
                    .clipShape(RoundedRectangle(cornerRadius: 20.0))
                    .bounceable()
                    .padding()
                    .background(Material.regular)
                }
            }
            .background(Colors.background)
            // Sheet for all pantry items view
            .fullScreenCover(isPresented: $isShowingAllPantryItemsView) {
                NavigationStack {
                    PantryContainer(
                        showsEditButton: true,
                        onDismiss: {
                            isShowingAllPantryItemsView = false
                        },
                        onCreateRecipe: { selectedItems in
                            // Set recipeGenerationSpec pantryItems to selectedItems
                            self.recipeGenerationSpec.pantryItems = selectedItems
                            
                            DispatchQueue.main.async {
                                self.isShowingAllPantryItemsView = false
                            }
                            
                            //                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.59) {
                            //                            self.isShowingEntryView = true
                            //                        }
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.59) {
                                self.isShowingSwipeCardsEntryView = true
                            }
                        })
                    .background(Colors.background)
                }
            }
            .fullScreenCover(isPresented: $isShowingSwipeCardsEntryView) {
                NavigationStack {
                    RecipeSaveGenerationSwipeContainer(
                        //                    recipeGenerator: recipeGenerator,
                        recipeGenerationSpec: recipeGenerationSpec,
                        onClose: {
                            isShowingSwipeCardsEntryView = false
                        })
                    .navigationBarTitleDisplayMode(.inline)
                    .toolbar {
                        LogoToolbarItem(foregroundColor: Colors.elementBackground)
                        
                        ToolbarItem(placement: .topBarTrailing) {
                            Button(action: {
                                isShowingSwipeCardsEntryView = false
                            }) {
                                Text("Close")
                                    .font(.heavy, 17)
                                    .foregroundStyle(Colors.elementBackground)
                            }
                        }
                    }
                }
            }
            // InsertPantryItemView popup
            .addToPantryPopup(isPresented: $isShowingAddPantryItemDirectlyToCameraPopup, showCameraOnAppear: true)
            .addToPantryPopup(isPresented: $isShowingAddPantryItemPopup, showCameraOnAppear: false)
            // EasyPantryUpdateContainer popup
            .easyPantryUpdateContainerPopup(isPresented: $isShowingEasyPantryUpdateContainer)
        }
    }
    
    // MARK: Components
    
    private var todayTitle: some View {
        HStack {
            Text("Today")
                .font(.custom(Constants.FontName.heavy, size: 20.0))
            Spacer()
        }
        .padding(.horizontal)
    }
    
    private var craftTitle: some View {
        HStack {
            Text("Craft")
                .font(.custom(Constants.FontName.black, size: 24.0))
                .foregroundStyle(Colors.foregroundText)
            Spacer()
        }
        .padding(.horizontal)
    }

    private var craftDisplay: some View {
        ScrollView(.horizontal) {
            let columns = Array(repeating: GridItem(.fixed(140)), count: 2)
            LazyHGrid(rows: columns) {
                if let panels = mainViewModel.panels {
                    ForEach(panels) { panel in
                        Button(action: {
                            HapticHelper.doLightHaptic()
                            
                            if canPresentPanel {
                                withAnimation(.spring(duration: 0.2)) {
                                    presentingPanel = panel
                                    isShowingPanelView = true
                                }
                            }
                        }) {
                            PanelMiniView(
                                panel: panel,
                                textStyle: Colors.foregroundText,
                                background: Colors.foreground,
                                namespace: panelNamespace
                            )
                            .background(Colors.foreground)
                            .clipShape(RoundedRectangle(cornerRadius: 28.0))
                        }
                        .tint(Colors.foregroundText)
                    }
                }
            }
            .padding(.horizontal)
        }
        .scrollIndicators(.never)
    }
    
    private var recipeOfTheDay: some View {
        RecipeOfTheDayContainer(
            onSelect: { recipe in
                presentingRecipe = recipe
            },
            onOpenAddToPantry: {
                isShowingAddPantryItemPopup = true
            })
    }
    
    private var pantryTitle: some View {
        HStack {
            Text("Pantry")
                .font(.custom(Constants.FontName.heavy, size: 20.0))
            Spacer()
        }
        .padding(.horizontal)
    }
    
    private var quickCameraAddToPantryButton: some View {
        Button(action: {
            HapticHelper.doLightHaptic()
            
            withAnimation(.bouncy(duration: 0.5)) {
                isShowingAddPantryItemDirectlyToCameraPopup = true
            }
        }) {
            ZStack {
                Text(Image(systemName: "camera"))
                    .font(.custom(Constants.FontName.body, fixedSize: 28.0))
                    .foregroundStyle(Colors.foregroundText)
                    .padding(8)
//                    .offset(x: -1, y: -1)
                    .frame(maxHeight: .infinity)
                    .background(RoundedRectangle(cornerRadius: 14.0)
                        .fill(Colors.foreground)
                        .aspectRatio(1, contentMode: .fill))
                //                .clipShape(RoundedRectangle(cornerRadius: 14.0))
                
                Image(systemName: "plus")
                    .foregroundStyle(Colors.foreground)
                    .fontWeight(.black)
                    .scaleEffect(x: 1.2, y: 1.2)
                    .offset(x: 15, y: 10)
                
                Image(systemName: "plus")
                    .foregroundStyle(Colors.elementBackground)
                    .fontWeight(.black)
                    .offset(x: 15, y: 10)
            }
        }
    }
    
    private var showPantryButton: some View {
        Button(action: {
            HapticHelper.doLightHaptic()
            
            withAnimation {
                isShowingAllPantryItemsView = true
            }
        }) {
            ZStack {
                HStack {
                    Spacer()
                    Text("\(Image(systemName: "list.bullet")) View Pantry")
                        .font(.custom(Constants.FontName.heavy, size: 20.0))
                    Spacer()
                }
                
//                HStack {
//                    Spacer()
//                    
//                    Image(systemName: "chevron.right")
//                        .imageScale(.medium)
//                }
            }
            .foregroundStyle(Colors.foregroundText)
            .padding()
            .background(Colors.foreground)
            .clipShape(RoundedRectangle(cornerRadius: 14.0))
        }
    }
    
    private var easyPantryUpdateButton: some View {
        Button(action: {
            isShowingEasyPantryUpdateContainer = true
        }) {
            HStack {
                Image(systemName: "exclamationmark")
                    .foregroundStyle(Colors.elementBackground)
                    .font(.custom(Constants.FontName.heavy, size: 17.0))
                    .padding(.horizontal)
                
                VStack(alignment: .leading) {
                    Text("Update Pantry")
                        .font(.custom(Constants.FontName.heavy, size: 17.0))
                    Text("Easily remove old items...")
                        .font(.custom(Constants.FontName.body, size: 14.0))
                }
                
                Spacer()
                
                Image(systemName: "chevron.right")
            }
            .foregroundStyle(Colors.foregroundText)
            .padding()
            .background(Colors.foreground)
            .clipShape(RoundedRectangle(cornerRadius: 14.0))
        }
        .padding(.vertical, 8)
        .padding(.horizontal)
    }

    private var recipesTitle: some View {
        HStack {
            Text("Recipes")
                .font(.custom(Constants.FontName.heavy, size: 20.0))
            Spacer()
        }
        .padding(.horizontal)
    }

//    // Overlay for introduction view
//    private var introOverlay: some View {
//        Group {
//#if !DEBUG // TODO: Remove this!
//            if introNotComplete.wrappedValue {
//                IntroViewSimple()
//            }
//#endif
//        }
//    }
}

#Preview {
    MainView(
        recipeGenerator: RecipeGenerator(),
        recipeGenerationSpec: RecipeGenerationSpec(
            pantryItems: [],
            suggestions: [],
            input: "",
            generationAdditionalOptions: .normal),
//        isShowingEntryView: .constant(false),
        presentingPanel: .constant(nil)
    )
        .environment(\.managedObjectContext, CDClient.mainManagedObjectContext)
        .environmentObject(ConstantsUpdater())
        .environmentObject(PremiumUpdater())
        .environmentObject(ProductUpdater())
        .environmentObject(RemainingUpdater())
}



RecipeMiniView.swift
//
//  RecipeMiniView.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/18/23.
//

import Foundation
import SwiftUI

struct RecipeMiniView: View {
    
    var title: String
    var summary: String?
    var image: UIImage?
    var date: Date
    
    static func from(recipe: Recipe) -> RecipeMiniView? {
        guard let title = recipe.name else {
            // TODO: Handle errors
            return nil
        }
        
        let summary = recipe.summary
        let date = recipe.updateDate ?? Date.distantPast
        let image = recipe.imageFromAppData
        
        return RecipeMiniView(
            title: title,
            summary: summary,
            image: image,
            date: date)
    }
    
    var body: some View {
        HStack(alignment: .top) {
            VStack {
                ZStack {
                    Group {
                        if let image = image {
                            Image(uiImage: image) // TODO: Fix image size and modifiers
                                .resizable()
                                .aspectRatio(1, contentMode: .fill)
                        } else {
                            ZStack {
                                Colors.background
                                ProgressView()
                                    .tint(Colors.foregroundText)
                            }
                        }
                    }
                    .clipShape(RoundedRectangle(cornerRadius: 14.0))
                    .frame(width: 48.0, height: 48.0)
                }
                
                HStack {
                    RoundedRectangle(cornerRadius: 14.0)
                        .frame(width: 2)
                        .foregroundStyle(Colors.background)
                        .padding(.leading)
                        .padding(.top, 8)
                }
            }
            Spacer(minLength: 15)
            VStack {
                VStack {
                    HStack(alignment: .top) {
                        Text(title)
                            .font(.custom(Constants.FontName.black, size: 17.0))
                            .multilineTextAlignment(.leading)
                        Spacer()
                        Text(NiceDateFormatter.dateFormatter.string(from: date))
                            .font(.custom(Constants.FontName.body, size: 12.0))
                    }
                    if let description = summary {
                        Spacer()
                        HStack {
                            Text(description)
                                .lineLimit(nil)
                                .fixedSize(horizontal: false, vertical: true)
                                .font(.custom(Constants.FontName.body, size: 14.0))
                                .multilineTextAlignment(.leading)
                            Spacer()
                        }
                        Spacer()
                    }
                }
            }
        }
    }
    
}

struct RecipeMiniView_PreviewProvider: PreviewProvider {
    
    static var previews: some View {
        ZStack {
            RecipeMiniView(
                title: "Title",
                summary: "Description",
                image: UIImage(named: "HighballTest")!,
                date: Date())
        }
        .environmentObject(PremiumUpdater())
        .environmentObject(ProductUpdater())
        .environmentObject(RemainingUpdater())
    }
    
}


AppDelegate.swift
//
//  AppDelegate.swift
//  WriteSmith-SwiftUI
//
//  Created by Alex Coundouriotis on 3/24/24.
//

import AppsFlyerLib
import AppTrackingTransparency
import FacebookCore
import Foundation
import SwiftUI

class AppDelegate: UIResponder, UIApplicationDelegate {
    
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {
        
        // Configure AppsFlyer
        // Request push notifications, which will later request tracking
        Task {
            let center = UNUserNotificationCenter.current()
            try await center.requestAuthorization(options: [.badge, .sound, .alert])
            
            // 3
            await MainActor.run {
                application.registerForRemoteNotifications()
            }
        }
        
        return true
    }
    
    func applicationDidBecomeActive(_ application: UIApplication) {
        // Start AppsFlyer
        AppsFlyerLib.shared().start()
    }
    
    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        Task {
            do {
                let registerAPNSRequest = APNSRegistrationRequest(
                    authToken: try await AuthHelper.ensure(),
                    deviceID: deviceToken)
                
                let response = try await ChefAppNetworkService.registerAPNS(request: registerAPNSRequest)
                
                // TODO: Handle Response
            } catch {
                // TODO: Handle Errors if Necessary
                print("Error registering APNS in AppDelegate... \(error)")
            }
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
#if DEBUG
                AppsFlyerLib.shared().isDebug = true
#endif
                AppsFlyerLib.shared().appsFlyerDevKey = Keys.AppsFlyer.devKey
                AppsFlyerLib.shared().appleAppID = Keys.AppsFlyer.appKey
                AppsFlyerLib.shared().waitForATTUserAuthorization(timeoutInterval: 120.0)
                AppsFlyerLib.shared().delegate = self
                //        NotificationCenter.default.addObserver(self, selector: NSSelectorFromString("sendLaunch"), name: UIApplication.didBecomeActiveNotification, object: nil) // SceneDelegate support
                
                DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2.0) {
                    ATTrackingManager.requestTrackingAuthorization { (status) in
                        // Set Facebook Advertising Tracking Enabled to True
                        Settings.shared.isAdvertiserTrackingEnabled = true
                        Settings.shared.isAdvertiserIDCollectionEnabled = true
                        
                        // Do stuff for status
                        switch status {
                        case .denied:
                            print("AuthorizationSatus is denied")
                        case .notDetermined:
                            print("AuthorizationSatus is notDetermined")
                        case .restricted:
                            print("AuthorizationSatus is restricted")
                        case .authorized:
                            print("AuthorizationSatus is authorized")
                        @unknown default:
                            print("Invalid authorization status")
                        }
                    }
                }
            }
        }
    }
    
    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
        print(error)
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
#if DEBUG
            AppsFlyerLib.shared().isDebug = true
#endif
            AppsFlyerLib.shared().appsFlyerDevKey = Keys.AppsFlyer.devKey
            AppsFlyerLib.shared().appleAppID = Keys.AppsFlyer.appKey
            AppsFlyerLib.shared().waitForATTUserAuthorization(timeoutInterval: 120.0)
            AppsFlyerLib.shared().delegate = self
            //        NotificationCenter.default.addObserver(self, selector: NSSelectorFromString("sendLaunch"), name: UIApplication.didBecomeActiveNotification, object: nil) // SceneDelegate support
            
            DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2.0) {
                ATTrackingManager.requestTrackingAuthorization { (status) in
                    // Set Facebook Advertising Tracking Enabled to True
                    Settings.shared.isAdvertiserTrackingEnabled = true
                    Settings.shared.isAdvertiserIDCollectionEnabled = true
                    
                    // Do stuff for status
                    switch status {
                    case .denied:
                        print("AuthorizationSatus is denied")
                    case .notDetermined:
                        print("AuthorizationSatus is notDetermined")
                    case .restricted:
                        print("AuthorizationSatus is restricted")
                    case .authorized:
                        print("AuthorizationSatus is authorized")
                    @unknown default:
                        print("Invalid authorization status")
                    }
                }
            }
        }
    }
    
    //    func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
    //
    //    }
    
    func applicationWillTerminate(_ application: UIApplication) {
        // Set notFirstLaunchEver to true
        UserDefaults.standard.set(true, forKey: Constants.UserDefaults.storedNotFirstLaunchEver)
    }
    
}


extension AppDelegate: AppsFlyerLibDelegate {
    
    func onConversionDataSuccess(_ conversionInfo: [AnyHashable : Any]) {
        print("Conversion data success in App Delegate!")
        
        if let status = conversionInfo["af_status"] as? String {
            if status == "Non-organic" {
                if let sourceID = conversionInfo["media_source"],
                   let campaign = conversionInfo["campaign"] {
                    NSLog("[AFSDK] This is a Non-Organic install. Media source: \(sourceID)  Campaign: \(campaign)")
                }
            } else {
                NSLog("[AFSDK] This is an organic install.")
            }
            if let is_first_launch = conversionInfo["is_first_launch"] as? Bool,
               is_first_launch {
                NSLog("[AFSDK] First Launch")
            } else {
                NSLog("[AFSDK] Not First Launch")
            }
        }
    }
    
    func onConversionDataFail(_ error: Error) {
        print("Conversion data fail in App Delegate... \(error)")
    }
    
}



NetworkingError.swift
//
//  HTTPSError.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 6/24/23.
//

import Foundation

enum NetworkingError: Int, Error {
    case success = 1
    case jsonError = 4
    case missingRequiredRequestObject = 5
    case capReachedError = 51
    case oaiGPTError = 60
    case invalidAssociatedIDError = 70
    case illegalArgument = 80
    case serverUnhandledError = 99
    case clientUnhandledError = 100
    
    case unknown = -1
}


TikTokSearchGeneratorError.swift
//
//  TikTokSearchGeneratorError.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/3/24.
//

import Foundation

enum TikTokSearchGeneratorError: Error {
    
    case nilCursor
    
}


PantryItemPersistenceError.swift
//
//  BarItemPersistenceError.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/30/23.
//

import Foundation

enum PantryItemPersistenceError: Error {
    case duplicatePantryItemNames([String])
}


GenerationError.swift
//
//  GenerationError.swift
//  PantryPal
//
//  Created by Alex Coundouriotis on 7/19/23.
//

import Foundation

enum GenerationError: Error {
    case auth
    case missingInput
    case request
    case response
}


PersistenceError.swift
//
//  PersistenceError.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/18/23.
//

import Foundation

enum PersistenceError: Error {
    case duplicateObject
    case invalidObjectID
    case noObject
}


RecipeOfTheDayError.swift
//
//  RecipeOfTheDayError.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 11/30/24.
//

import Foundation

enum RecipeOfTheDayError: Error {
    
    case recipeOfTheDayExistsForTimeframe
    
}


MigrationAssistant.swift
//
//  MigrationAssistant.swift
//  ChefApp-SwiftUI
//
//  Created by Alex Coundouriotis on 12/10/24.
//

import CoreData
import Foundation
import UIKit

class MigrationAssistant {
    
    static func migrateCoreDataImagesToAppGroupSaveLocations(in managedContext: NSManagedObjectContext) async {
        // Get Recipes
        let recipes: [Recipe]
        do {
            let fetchRequest = Recipe.fetchRequest()
            fetchRequest.fetchLimit = 15
            fetchRequest.predicate = NSPredicate(format: "%K != nil", #keyPath(Recipe.imageData))
            recipes = try await managedContext.perform { try managedContext.fetch(fetchRequest) }
        } catch {
            // TODO: Handle Errors
            print("Error fetching recipes in MigrationAssistant... \(error)")
            return
        }
        
        // If no more recipes return
        if recipes.isEmpty {
            return
        }
        
        // Migrate each Recipe's image and delete the imageData
        for recipe in recipes {
            let image = await managedContext.perform {
                if let imageData = recipe.imageData {
                    return UIImage(data: imageData)
                }
                
                return nil
            }
            
            if let image {
                do {
                    try await RecipeCDClient.updateRecipe(recipe, uiImage: image, in: managedContext)
                } catch {
                    // TODO: Handle Errors
                    print("Error updating recipe with image in app group location in MigrationAssistant, continuing... \(error)")
                }
            }
            
            do {
                try await managedContext.perform {
                    recipe.imageData = nil
                    
                    try managedContext.save()
                }
            } catch {
                // TODO: Handle Errors
                print("Error updating and saving recipe imageData in MigrationAssistant, continuing... \(error)")
            }
        }
        
        // Call recursively
        await migrateCoreDataImagesToAppGroupSaveLocations(in: managedContext)
    }
    
}


RecipeDirectionsAndIdeaRecipeIngredientsRegenerator.swift
////
////  RecipeDirectionsAndIdeaRecipeIngredientsRegenerator.swift
////  PantryPal
////
////  Created by Alex Coundouriotis on 7/19/23.
////
//
//import CoreData
//import Foundation
//
//class RecipeDirectionsAndIdeaRecipeIngredientsRegenerator {
//    
//    static func regenerateInsertUpdateRecipeDirectionsAndIdeaRecipeIngredients(authToken: String, recipe: Recipe, in managedContext: NSManagedObjectContext) async throws {
//        // Ensure recipeMeasuredIngredients and ideaRecipe are not nil and recipe measuredIngredients count is greater than 0, otherwise throw GenerationError missingInput
//        guard recipe.measuredIngredients != nil, recipe.measuredIngredients!.count > 0 else {
//            throw GenerationError.missingInput
//        }
//        
//        // Get and unwrap recipeMeasuredIngredientsArray, otherwise throw GenerationError request
//        guard let recipeMeasuredIngredientsArray = recipe.measuredIngredients?.allObjects as? [RecipeMeasuredIngredient] else {
//            throw GenerationError.request
//        }
//        
//        // Create regenerateRecipeDirectionsAndIdeaRecipeIngredientsRequest
//        let regenerateRecipeDirectionsAndIdeaRecipeIngredientsRequest = RegenerateRecipeMeasuredIngredientsAndDirectionsAndIdeaRecipeIngredientsRequest(
//            authToken: authToken,
//            ideaID: recipe.recipeID,
//            measuredIngredients: stringArrayFrom(recipeMeasuredIngredientArray: recipeMeasuredIngredientsArray))
//        
//        // Get regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse
//        let regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse = try await ChefAppNetworkService.regenerateRecipeDirectionsAndIdeaRecipeIngredients(request: regenerateRecipeDirectionsAndIdeaRecipeIngredientsRequest)
//        
//        // Replace ingredients and directions in recipe
//        if let receivedMeasuredIngredients = regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse.body.ideaRecipeIngredients, !receivedMeasuredIngredients.isEmpty {
//            try await RecipeMeasuredIngredientCDClient.deleteAllMeasuredIngredients(for: recipe, in: managedContext)
//            try await RecipeMeasuredIngredientCDClient.appendMeasuredIngredients(ingredientsAndMeasurements: receivedMeasuredIngredients, to: recipe, in: managedContext)
//        }
//        
//        let receivedDirections = regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse.body.recipeDirections
//        if !receivedDirections.isEmpty {
//            // Map receivedDirections to index and string touple
//            var receivedDirectionsWithIndices: [(index: Int16, string: String)] = receivedDirections.enumerated().map { (index, string) in (index: Int16(index), string: string) }
//            
//            try await RecipeDirectionCDClient.deleteAllDirections(for: recipe, in: managedContext)
//            try await RecipeDirectionCDClient.appendDirections(content: receivedDirectionsWithIndices, to: recipe, in: managedContext)
//        }
//        
//        // Update feasibility in recipe
//        if let feasibility = regenerateRecipeDirectionsAndIdeaRecipeIngredientsResponse.body.feasibility {
//            try await RecipeCDClient.updateRecipe(recipe, feasibility: Int16(feasibility), in: managedContext)
//        }
//    }
//    
//    private static func stringArrayFrom(recipeMeasuredIngredientArray: [RecipeMeasuredIngredient]) -> [String] {
//        // Converts recipe measured ingredient array to string array using nameAndAmountModified if it can be unwrapped otherwise nameAndAmounts
//        var stringArray: [String] = []
//        for recipeMeasuredIngredient in recipeMeasuredIngredientArray {
//            // Ensure recipeManagedIngredient markedForDeletion is false, otherwise continue to ensure it is not appended to the string array TODO: I changed deleteOnRegenerate to markedForDeletion here, assuming they would have similar functionality or have the same functionality
//            guard !recipeMeasuredIngredient.markedForDeletion else {
//                continue
//            }
//            
//            // Append nameAndAmountModified if it can be unwrapped, otherwise use nameAndAmount if it can be unwrapped
//            if let nameAndAmountModified = recipeMeasuredIngredient.nameAndAmountModified {
//                stringArray.append(nameAndAmountModified)
//            } else if let nameAndAmount = recipeMeasuredIngredient.nameAndAmount {
//                stringArray.append(nameAndAmount)
//            }
//        }
//        
//        return stringArray
//    }
//    
//}


PersistenceController.swift
//
//  PersistenceController.swift
//  Barback
//
//  Created by Alex Coundouriotis on 9/16/23.
//

import CoreData

struct PersistenceController {
    static let shared = PersistenceController()

    static var preview: PersistenceController = {
        let result = PersistenceController(inMemory: true)
        let viewContext = result.container.viewContext

        do {
            try viewContext.save()
        } catch {

        }
//        for _ in 0..<10 {
//            let newItem = Item(context: viewContext)
//            newItem.timestamp = Date()
//        }
//        do {
//            try viewContext.save()
//        } catch {
//            // Replace this implementation with code to handle the error appropriately.
//            // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
//            let nsError = error as NSError
//            fatalError("Unresolved error \(nsError), \(nsError.userInfo)")
//        }
        return result
    }()

    let container: NSPersistentContainer

    init(inMemory: Bool = false) {
        container = NSPersistentContainer(name: "Barback")
        if inMemory {
            container.persistentStoreDescriptions.first!.url = URL(fileURLWithPath: "/dev/null")
        }
        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
            if let error = error as NSError? {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.

                /*
                 Typical reasons for an error here include:
                 * The parent directory does not exist, cannot be created, or disallows writing.
                 * The persistent store is not accessible, due to permissions or data protection when the device is locked.
                 * The device is out of space.
                 * The store could not be migrated to the current model version.
                 Check the error message to determine what the actual problem was.
                 */
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        })
        container.viewContext.automaticallyMergesChangesFromParent = true
    }
}

//////
//////  Persistence.swift
//////  Barback
//////
//////  Created by Alex Coundouriotis on 9/16/23.
//////
////
////import CoreData
////
////struct PersistenceController {
////    static let shared = PersistenceController()
////
////    static var preview: PersistenceController = {
////        let result = PersistenceController(inMemory: true)
////        let viewContext = result.container.viewContext
////        for _ in 0..<10 {
////            let newItem = Item(context: viewContext)
////            newItem.timestamp = Date()
////        }
////        do {
////            try viewContext.save()
////        } catch {
////            // Replace this implementation with code to handle the error appropriately.
////            // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
////            let nsError = error as NSError
////            fatalError("Unresolved error \(nsError), \(nsError.userInfo)")
////        }
////        return result
////    }()
////
////    let container: NSPersistentContainer
////
////    init(inMemory: Bool = false) {
////        container = NSPersistentContainer(name: "Barback")
////        if inMemory {
////            container.persistentStoreDescriptions.first!.url = URL(fileURLWithPath: "/dev/null")
////        }
////        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
////            if let error = error as NSError? {
////                // Replace this implementation with code to handle the error appropriately.
////                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
////
////                /*
////                 Typical reasons for an error here include:
////                 * The parent directory does not exist, cannot be created, or disallows writing.
////                 * The persistent store is not accessible, due to permissions or data protection when the device is locked.
////                 * The device is out of space.
////                 * The store could not be migrated to the current model version.
////                 Check the error message to determine what the actual problem was.
////                 */
////                fatalError("Unresolved error \(error), \(error.userInfo)")
////            }
////        })
////        container.viewContext.automaticallyMergesChangesFromParent = true
////    }
////}


